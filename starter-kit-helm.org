#+TITLE: Helm Customizations
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args :tangle yes

This is part of the [[file:starter-kit.org][Emacs Starter Kit]].

It controls helm and projectile.


* First, make sure that =ido-everywhere= is disabled

See https://github.com/emacs-helm/helm/issues/2085

#+BEGIN_SRC emacs-lisp :tangle no
;;(cl-assert (null ido-everywhere)
;;             nil "ido-everywhere is incompatible with helm, please disable it")
#+END_SRC
* Starting out the helm magic

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helm
  :ensure t
  :diminish helm-mode
  :init 
  (helm-mode 1)
  (require 'helm-config))
#+END_SRC

#+RESULTS:
|   |

* Daniel Mai's stuff 

From: https://github.com/danielmai/.emacs.d/blob/master/config.org

** =helm-swoop=

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helm-swoop
  :ensure t
  :after helm-mode
  ;; :bind ("H-w" . helm-swoop)
  )
#+END_SRC

* Key bindings 

The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
Changed to "C-c h". Note: We must set "C-c h" globally, because we
cannot change `helm-command-prefix-key' once `helm-config' is loaded.

#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "C-c h") 'helm-command-prefix)
(global-unset-key (kbd "C-x c"))

    ;; Make M-x be equal to M-x helm-M-x
(global-set-key (kbd "M-x") 'helm-M-x)

(setq helm-M-x-fuzzy-match t) ;; optional fuzzy matching for helm-M-x

    ;; Command: helm-show-kill-ring
(global-set-key (kbd "M-y") 'helm-show-kill-ring)

    ;; Command: helm-mini
(global-set-key (kbd "C-x b") 'helm-mini)
#+END_SRC

#+RESULTS:
: helm-mini

* Search options
** Fuzzy matching 
To enable fuzzy matching, add the following settings:

On semantic, read https://tuhdo.github.io/helm-intro.html: Semantic is a package that provides language-aware editing commands based on 'source-code parsers'. When enabled, each file you visit is automatically parsed. Semantic provides execellent support for C/C++. To enable Semantic mode, execute (semantic-mode 1).

Helm offers an interface to both Semantic and Imenu at the same time: If `semantic-mode' is active in the current buffer, then use semantic for generating tags, otherwise fall back to imenu. If point is on a symbol, helm feeds the symbol into input prompt by default.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq helm-buffers-fuzzy-matching t
      helm-recentf-fuzzy-match    t)

    ;; Command: helm-find-files
    ;; helm-find-files is file navigation on steroids:
(global-set-key (kbd "C-x C-f") 'helm-find-files)
;;(global-set-key (kbd "<s-escape>") 'helm-recentf)

;; =C-x C-f= you start a =helm-find-files= session. There you can do =C-s= to recursively grep a selected directory.  Every time you type a character, helm updates grep result immediately. You can use ack-grep to replace grep with this configuration:

(when (executable-find "ack-grep")
  (setq helm-grep-default-command "ack-grep -Hn --no-group --no-color %e %p %f"
        helm-grep-default-recurse-command "ack-grep -H --no-group --no-color %e %p %f"))

;; Command: helm-semantic-or-imenu
(semantic-mode 1)
(setq helm-semantic-fuzzy-match t
      helm-imenu-fuzzy-match    t)

(global-set-key (kbd "M-i") 'helm-semantic-or-imenu)

;; Command: helm-locate
(setq helm-locate-fuzzy-match t)

;; From ambrevar: Fallback on 'find' if 'locate' is not available.
(unless (executable-find "locate")
  (setq helm-locate-recursive-dirs-command "find %s -type d -regex .*%s.*$"))

;; See https://github.com/emacs-helm/helm/issues/1962.
(defun ambrevar/helm-locate-meta (&optional update)
  "Like `helm-locate' but also use the databases found in /media and /run/media.
With prefix argument, UPDATE the databases with custom uptions thanks to the
'updatedb-local' script."
  (interactive "P")
  (let ((user-db (expand-file-name "~/.cache/locate.db"))
        (media-dbs (apply 'append
                          (mapcar
                           (lambda (root) (ignore-errors (file-expand-wildcards (concat root "/*/locate.db"))))
                           (list (concat "/run/media/" (user-login-name))
                                 (concat "/media/" (user-login-name))
                                 "/media")))))
    (when update
      (with-temp-buffer
        (if (= (shell-command "updatedb-local" (current-buffer)) 0)
            (message "%s" (buffer-string))
          (error "%s" (current-buffer)))))
    (helm-locate-with-db
     (mapconcat 'identity
                (cons user-db media-dbs)
                ":")
     nil (thing-at-point 'filename))))

;; Command: helm-occur
;; search for patterns in current buffer
(global-set-key (kbd "C-c h o") 'helm-occur)
(global-set-key (kbd "s-;") 'helm-occur)

;; Command: helm-lisp-completion-at-point
;; To enable fuzzy matching, add this setting:
(setq helm-lisp-fuzzy-completion t)

;; Command: helm-all-mark-rings
(global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)

;; Command: helm-register
(global-set-key (kbd "C-c h x") 'helm-register)
#+END_SRC

#+RESULTS:
: helm-register

*** From Ambrevar: 

Do not exclude any files from 'git grep'.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq helm-grep-git-grep-command "git --no-pager grep -n%cH --color=always --full-name -e %p -- %f")

(defun ambrevar/helm-grep-git-or-ag (arg)
  "Run `helm-grep-do-git-grep' if possible; fallback to `helm-do-grep-ag' otherwise.
Requires `call-process-to-string' from `functions'."
  (interactive "P")
  (require 'vc)
  (require 'functions)
  (if (and (vc-find-root default-directory ".git")
           (or arg (split-string (ambrevar/call-process-to-string "git" "ls-files" "-z") "\0" t)))
      (helm-grep-do-git-grep arg)
    (helm-do-grep-ag nil)))

(defun ambrevar/helm-grep-git-all-or-ag ()
  "Run `helm-grep-do-git-grep' over all git files."
  (interactive)
  (helm-grep-do-git-grep t))
#+END_SRC

#+RESULTS:
: ambrevar/helm-grep-git-all-or-ag

More stuff from Ambrevar

#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key [remap query-replace-regexp] 'helm-regexp)
(unless (boundp 'completion-in-region-function)
  (define-key lisp-interaction-mode-map [remap completion-at-point] 'helm-lisp-completion-at-point)
  (define-key emacs-lisp-mode-map       [remap completion-at-point] 'helm-lisp-completion-at-point))
#+END_SRC

#+RESULTS:

And still more on grep, but they are already defined in the =exwm= shortcuts, so I take them out

#+BEGIN_SRC emacs-lisp :tangle no
(ambrevar/global-set-keys
 "C-x M-g" 'ambrevar/helm-grep-git-or-ag
 "C-x M-G" 'helm-do-grep-ag)
#+END_SRC

** Google 

#+BEGIN_SRC emacs-lisp :tangle yes
;; helm-google-suggest
(global-set-key (kbd "C-c h g") 'helm-google-suggest)
#+END_SRC

** Eldoc 

#+BEGIN_SRC emacs-lisp :tangle yes
;; helm-eval-expression-with-eldoc
(global-set-key (kbd "C-c h M-:") 'helm-eval-expression-with-eldoc)
#+END_SRC

** Eshell

#+BEGIN_SRC emacs-lisp :tangle yes
;; Command: helm-eshell-history
(require 'helm-eshell)

(add-hook 'eshell-mode-hook
          '(lambda ()
             (define-key eshell-mode-map (kbd "C-c h C-c h")  'helm-eshell-history)))
#+END_SRC

*** Ambrevar's eshell

#+BEGIN_SRC emacs-lisp :tangle yes
;;; Eshell
(defun ambrevar/helm/eshell-set-keys ()
  (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete)
  (define-key eshell-mode-map (kbd "M-p") 'helm-eshell-history)
  (define-key eshell-mode-map (kbd "M-s") nil) ; Useless when we have 'helm-eshell-history.
  (define-key eshell-mode-map (kbd "M-s f") 'helm-eshell-prompts-all))
(add-hook 'eshell-mode-hook 'ambrevar/helm/eshell-set-keys)
#+END_SRC

#+RESULTS:
| ambrevar/helm/eshell-set-keys | (lambda nil (define-key eshell-mode-map (kbd C-c h C-c h) 'helm-eshell-history)) | helm-gtags-mode | tramp-eshell-directory-change | (lambda nil (define-key eshell-mode-map  'eshell-bol)) | ess-r-package-activate-directory-tracker |

** Comint 
Disabled as it gives rise to lisp error
#+BEGIN_SRC emacs-lisp :tangle no
;; Command: helm-comint-input-ring
;; (define-key shell-mode-map (kbd "C-c h C-c h") 'helm-comint-input-ring)
#+END_SRC

#+RESULTS:

** Mini-buffer history 

#+BEGIN_SRC emacs-lisp :tangle yes
;; Command: helm-mini-buffer-history
(define-key minibuffer-local-map (kbd "C-c h C-c h") 'helm-minibuffer-history)
#+END_SRC

* helm-descbinds

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'helm-descbinds)
(helm-descbinds-mode)
#+END_SRC
* Helm and gtags

Further customization of =gtags= with =helm=, from http://tuhdo.github.io/c-ide.html.

Check out: http://tuhdo.github.io/c-ide.html

#+begin_src emacs-lisp :tangle yes
    ;; Tuhdo says to put this but if I do emacs spits error mesage on start up.
    ;;(require 'setup-helm)
    ;;(require 'setup-helm-gtags)

    (require 'helm-gtags)

    ;; Enable helm-gtags-mode
    (add-hook 'dired-mode-hook 'helm-gtags-mode)
    (add-hook 'eshell-mode-hook 'helm-gtags-mode)
    (add-hook 'c-mode-hook 'helm-gtags-mode)
    (add-hook 'c++-mode-hook 'helm-gtags-mode)
    (add-hook 'asm-mode-hook 'helm-gtags-mode)

    (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
    (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
    (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
    (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
    (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
    (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)

    (setq
     helm-gtags-ignore-case t
     helm-gtags-auto-update t
     helm-gtags-use-input-at-cursor t
     helm-gtags-pulse-at-cursor t
     helm-gtags-prefix-key "C-c g"
     helm-gtags-suggested-key-mapping t)
#+end_src

#+RESULTS:
: t

* Helm-bibtex
And now the bit by Ista Zahn in tip from: https://github.com/izahn/dotemacs but modified to use helm instead of ivy.
This allows you to search your BibTeX files for references to insert into the current document. For it to work you will need to set `bibtex-completion-bibliography` to the location of your BibTeX files.
Initiate a citation search with ivy-bibtex, bound to C-c r.

Commented out by DGM: not sure it is working and i can use ivy with helm

#+begin_src emacs-lisp :tangle yes
;; (setq ivy-bibtex-default-action 'bibtex-completion-insert-citation)
(use-package helm-bibtex
  :ensure t)
(global-set-key (kbd "<s-backspace>") 'helm-bibtex)
#+end_src

#+RESULTS:
: helm-bibtex

Tip from =titus= for =helm-bibtex=: I use the menu key as the prefix key for all helm commands and bind helm-bibtex to b. Helm-bibtex can then be started using <menu> b. It is also useful to bind helm-resume to <menu> in helm-command-map. With this binding, <menu> <menu> can be used to reopen the last helm search.

** Bibtex-completion

Bibtex-completion depends on helm-bibtex. That's why I paste it here.

From https://github.com/tmalsburg/helm-bibtex

Helm-bibtex and ivy-bibtex allow you to search and manage your BibTeX bibliography. They both share the same generic backend, bibtex-completion, but one uses the Helm completion framework and the other Ivy as a front-end.

check titus: https://github.com/tmalsburg/helm-bibtex

A minimal configuration involves telling bibtex-completion where your bibliographies can be found.
I am leaving it as not a list.
I am commenting it out now as I am using the variable =helm-bibtex-bibliography= in =starter-kit-helm.org=.

#+BEGIN_EXAMPLE
(setq bibtex-completion-bibliography 
      '("/media/dgm/blue/documents/bibs/socbib.bib"))  
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle yes
(setq bibtex-completion-bibliography "/media/dgm/blue/documents/bibs/socbib.bib")
#+END_SRC

#+RESULTS:
: /media/dgm/blue/documents/bibs/socbib.bib

Specify where PDFs can be found: Bibtex-completion assumes that the name of a PDF consists of the BibTeX key followed plus a user-defined suffix (.pdf by default). For example, if a BibTeX entry has the key Darwin1859, bibtex-completion searches for Darwin1859.pdf.

I am commenting out as I have the variable =helm-bibtex-library-path= in =starter-kit-helm.org=

#+BEGIN_SRC emacs-lisp :tangle yes
(setq bibtex-completion-library-path '("/media/dgm/blue/documents/elibrary/org/references/pdfs"))
#+END_SRC

#+RESULTS:
| /media/dgm/blue/documents/elibrary/org/references/pdfs/ |


Bibtex-completion supports two methods for storing notes. It can either store all notes in one file or store notes in multiple files, one file per publication. In the first case, the customization variable bibtex-completion-notes-path has to be set to the full path of the notes file:
I am commenting it out as I have the variable =helm-bibtex-notes-path= in =starter-kit-helm.org=

#+BEGIN_SRC emacs-lisp :tangle yes
(setq bibtex-completion-notes-path "/media/dgm/blue/documents/elibrary/org/references")
#+END_SRC

#+RESULTS:
: /media/dgm/blue/documents/elibrary/org/references/readings.org

(See also Kitchin on setting these paths here https://github.com/jkitchin/org-ref.)

Symbols used for indicating the availability of notes and PDF files

#+BEGIN_SRC emacs-lisp :tangle yes
(setq bibtex-completion-pdf-symbol "⌘")
(setq bibtex-completion-notes-symbol "✎")
#+END_SRC

#+RESULTS:
: ✎

Open pdf with system pdf viewer

#+BEGIN_SRC emacs-lisp :tangle yes
(setq bibtex-completion-pdf-open-function 'org-open-file)
#+END_SRC

#+RESULTS:
: org-open-file

** The Reddit workflow

From: https://www.reddit.com/r/emacs/comments/4gudyw/help_me_with_my_orgmode_workflow_for_notetaking/

With this setup helm-bibtex points to the same notes file as org-ref. Just run M-x helm-bibtex and select the article you want. Instead of pressing <return>, press <tab>. This opens up helm's alternate action list where you can choose to Edit notes. This opens up the exact notes file created by org-ref.

#+BEGIN_SRC emacs-lisp :tangle yes
 (setq helm-bibtex-bibliography "/media/dgm/blue/documents/bibs/socbib.bib" 
       helm-bibtex-library-path "/media/dgm/blue/documents/elibrary/org/references/pdfs/"
       helm-bibtex-notes-path "/media/dgm/blue/documents/elibrary/org/references/readings.org")
#+END_SRC

#+RESULTS:
: /media/dgm/blue/documents/elibrary/org/references/readings.org

* Ambrevar's stuff

;;; TODO: helm-ff should allow opening several marks externally, e.g.  sxiv for
;;; pics. See
;;; https://github.com/emacs-helm/helm/wiki/Find-Files#open-files-externally.
;;; What about the default program?  It currently defaults to ~/.mailcap, which is
;;; not so customizable.  Would ranger's rifle be useful here?  See
;;; https://github.com/emacs-helm/helm/issues/1796.  There is the `openwith' package.

;;; TODO: Batch-open torrent files automatically.  Add to mailcap?  Same as
;;; above, C-c C-x does not allow for opening several files at once.

;;; TODO: helm-find in big folders sometimes leads bad results, like exact match
;;; not appearing first. Better sorting?

;;; TODO: Implement alternating-color multiline lists.
;;; See https://github.com/emacs-helm/helm/issues/1790.


#+BEGIN_SRC emacs-lisp :tangle yes
(when (< emacs-major-version 26)
  (when (require 'linum-relative nil t)
    (helm-linum-relative-mode 1)))

;; (when (require 'helm-descbinds nil t)
;;    (helm-descbinds-mode))

(when (require 'wgrep-helm nil t)
  (setq wgrep-auto-save-buffer t
        wgrep-enable-key (kbd "C-c h w")))

(when (require 'helm-ls-git nil t)
  ;; `helm-source-ls-git' must be defined manually.
  ;; See https://github.com/emacs-helm/helm-ls-git/issues/34.
  (setq helm-source-ls-git
        (and (memq 'helm-source-ls-git helm-ls-git-default-sources)
             (helm-make-source "Git files" 'helm-ls-git-source
               :fuzzy-match helm-ls-git-fuzzy-match))))
#+END_SRC


** Generic configuration

#+BEGIN_SRC emacs-lisp :tangle yes
(setq
 helm-follow-mode-persistent t
 helm-reuse-last-window-split-state t
 helm-findutils-search-full-path t
 helm-show-completion-display-function nil
 helm-completion-mode-string ""
 helm-dwim-target 'completion
 helm-echo-input-in-header-line t
 helm-use-frame-when-more-than-two-windows nil
 ;; helm-apropos-fuzzy-match t
 ;; helm-buffers-fuzzy-matching t
 ;; helm-eshell-fuzzy-match t
 ;; helm-imenu-fuzzy-match t
 ;; helm-M-x-fuzzy-match t
 ;; helm-recentf-fuzzy-match t
 ;; Use woman instead of man.
 helm-man-or-woman-function nil
 ;; https://github.com/emacs-helm/helm/issues/1910
 helm-buffers-end-truncated-string "…"
 helm-buffer-max-length 22
 helm-window-show-buffers-function 'helm-window-mosaic-fn
 helm-window-prefer-horizontal-split t)
#+END_SRC

** Apropos 

#+BEGIN_SRC emacs-lisp :tangle yes
;; Command: helm-apropos
;; To enable fuzzy matching, add this setting:
(setq helm-apropos-fuzzy-match t)
(global-set-key [remap apropos-command] 'helm-apropos)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
;;; Add bindings to `helm-apropos`. TODO: Does not work most of the times.
;;; https://github.com/emacs-helm/helm/issues/1140
(defun ambrevar/helm-def-source--emacs-commands (&optional default)
  (helm-build-in-buffer-source "Commands"
    :init `(lambda ()
             (helm-apropos-init 'commandp ,default))
    :fuzzy-match helm-apropos-fuzzy-match
    :filtered-candidate-transformer (and (null helm-apropos-fuzzy-match)
                                         'helm-apropos-default-sort-fn)
    :candidate-transformer 'helm-M-x-transformer-1
    :nomark t
    :action '(("Describe Function" . helm-describe-function)
              ("Find Function" . helm-find-function)
              ("Info lookup" . helm-info-lookup-symbol))))
#+END_SRC

#+RESULTS:
: ambrevar/helm-def-source--emacs-commands

** The =M-s= prefix

Use the =M-s= prefix just like `occur'.

Note that the =s= in the prefix is the letter =s= and not the =super= key.

#+BEGIN_SRC emacs-lisp :tangle yes
(define-key prog-mode-map (kbd "M-s f") 'helm-semantic-or-imenu)
;;; The text-mode-map binding targets structured text modes like Markdown.
(define-key text-mode-map (kbd "M-s f") 'helm-semantic-or-imenu)
(with-eval-after-load 'org
  (require 'helm-org-contacts nil t)
  (define-key org-mode-map (kbd "M-s f") 'helm-org-in-buffer-headings))
(with-eval-after-load 'woman
  (define-key woman-mode-map (kbd "M-s f") 'helm-imenu))
(with-eval-after-load 'man
  (define-key Man-mode-map (kbd "M-s f") 'helm-imenu))
#+END_SRC

#+RESULTS:

** More stuff!!!

#+BEGIN_SRC emacs-lisp :tangle yes
(setq helm-source-names-using-follow '("Occur" "Git-Grep" "AG" "mark-ring" "Org Headings" "Imenu"))

;;; From https://www.reddit.com/r/emacs/comments/5q922h/removing_dot_files_in_helmfindfiles_menu/.
(defun ambrevar/helm-skip-dots (old-func &rest args)
  "Skip . and .. initially in helm-find-files.  First call OLD-FUNC with ARGS."
  (apply old-func args)
  (let ((sel (helm-get-selection)))
    (if (and (stringp sel) (string-match "/\\.$" sel))
        (helm-next-line 2)))
  (let ((sel (helm-get-selection))) ; if we reached .. move back
    (if (and (stringp sel) (string-match "/\\.\\.$" sel))
        (helm-previous-line 1))))

(advice-add #'helm-preselect :around #'ambrevar/helm-skip-dots)
(advice-add #'helm-ff-move-to-first-real-candidate :around #'ambrevar/helm-skip-dots)

(with-eval-after-load 'desktop
  (add-to-list 'desktop-globals-to-save 'kmacro-ring)
  (add-to-list 'desktop-globals-to-save 'last-kbd-macro)
  (add-to-list 'desktop-globals-to-save 'kmacro-counter)
  (add-to-list 'desktop-globals-to-save 'kmacro-counter-format)
  (add-to-list 'desktop-globals-to-save 'helm-ff-history)
  (add-to-list 'desktop-globals-to-save 'comint-input-ring))

(helm-top-poll-mode)
;;; Column indices might need some customizing. See `helm-top-command' and
;;; https://github.com/emacs-helm/helm/issues/1586 and
;;; https://github.com/emacs-helm/helm/issues/1909.
#+END_SRC

#+RESULTS:
: t

** Convenience

#+BEGIN_SRC emacs-lisp :tangle yes
;;; Convenience.
(defun ambrevar/helm-toggle-visible-mark-backwards (arg)
  (interactive "p")
  (helm-toggle-visible-mark (- arg)))
;; (define-key helm-map (kbd "S-SPC") 'ambrevar/helm-toggle-visible-mark-backwards)

;; (global-set-key  (kbd "C-<f4>") 'helm-execute-kmacro)
#+END_SRC

* Uncle Dave

Lines from uncle dave at https://github.com/daedreth/UncleDavesEmacs and Tuhdo  https://tuhdo.github.io/helm-intro.html


#+BEGIN_SRC emacs-lisp :tangle yes
(define-key helm-find-files-map (kbd "C-b") 'helm-find-files-up-one-level)
;; (define-key helm-find-files-map (kbd "C-f") 'helm-execute-persistent-action)
(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action but this gives rise to problems. See https://github.com/jkitchin/org-ref/issues/527
(define-key helm-map (kbd "C-i")   'helm-execute-persistent-action) ; make TAB work in terminal
(define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z... direct from Tuhdo! 
#+END_SRC

#+RESULTS:
: helm-select-action

* Projectile 
#+srcname: projectile
#+BEGIN_SRC emacs-lisp :tangle yes
    ;; Projectile
    (use-package projectile
      :ensure t
      :config (projectile-global-mode t))

    (setq projectile-enable-caching t) ;; update 22 nov 2018. In C-h v projectile-indexing-method they recommend to have it set to aliena to have this other variable set to true. If it does not work, revert to instructions in emacs's cheatsheet.
    ;; (setq projectile-enable-caching nil) ; see https://emacs.stackexchange.com/questions/2164/projectile-does-not-show-all-files-in-project

    ;; https://github.com/bbatsov/projectile/issues/1183
    ;; trying to fix slow behaviour of emacs
    (setq projectile-mode-line
         '(:eval (format " Projectile[%s]"
                        (projectile-project-name))))

    ;; from https://github.com/bbatsov/projectile#usage
    ;; (projectile-mode +1) ;; don't know what this does.
    (define-key projectile-mode-map (kbd "s--") 'projectile-command-map)
    ;;(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

    (define-key projectile-mode-map [?\s-d] 'projectile-switch-project)
    (define-key projectile-mode-map [?\s-D] 'projectile-find-dir-dwim)
    (define-key projectile-mode-map [?\s-y] 'projectile-ag)      


    (use-package helm-projectile
      :ensure t
      :after helm-mode 
      :init     
      (setq projectile-completion-system 'helm)
      :commands helm-projectile
    ;;   :bind ("C-c p h" . helm-projectile)
    )

    (helm-projectile-on)   ;;; creo que no hace falta tras decir =ensure t= in use-package.
    (define-key projectile-mode-map [?\s-u] 'helm-projectile-find-file-in-known-projects) 
    (setq projectile-switch-project-action 'helm-projectile)
    (global-set-key (kbd "<s-return>") 'helm-projectile)
  ;; from https://projectile.readthedocs.io/en/latest/usage/
  ;; You can go one step further and set a list of folders which Projectile is automatically going to check for projects:

  (setq projectile-project-search-path '("~/.emacs.d/"
                                         "~/texmf/"
                                         "~/Dropbox/gtd/"
                                         "/media/dgm/blue/documents/proyectos/mtj/"
                                         "/media/dgm/blue/documents/dropbox/"
                                         "/media/dgm/blue/documents/UNED/"
                                         "/media/dgm/blue/documents/data/eurostat"
                                         "/media/dgm/blue/documents/templates"))
#+END_SRC

#+RESULTS: projectile
| ~/.emacs.d/ | ~/texmf/ | ~/Dropbox/gtd/ | /media/dgm/blue/documents/proyectos/mtj/ | /media/dgm/blue/documents/dropbox/ | /media/dgm/blue/documents/UNED/ | /media/dgm/blue/documents/data/eurostat | /media/dgm/blue/documents/templates |


Need to use =helm-projectile-find-other-file= bound to =s-- a=

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'projectile-other-file-alist '("org" "el")) ;; switch from org -> el 
(add-to-list 'projectile-other-file-alist '("el" "org")) ;; switch from el -> org 
(add-to-list 'projectile-other-file-alist '("Rnw" "R"))
(add-to-list 'projectile-other-file-alist '("R" "Rnw"))
(add-to-list 'projectile-other-file-alist '("Rnw" "tex"))
(add-to-list 'projectile-other-file-alist '("tex" "Rnw"))
(add-to-list 'projectile-other-file-alist '("org" "tex"))
(add-to-list 'projectile-other-file-alist '("tex" "org"))
(add-to-list 'projectile-other-file-alist '("tex" "log"))
(add-to-list 'projectile-other-file-alist '("log" "tex"))
(add-to-list 'projectile-other-file-alist '("org" "html"))
(add-to-list 'projectile-other-file-alist '("html" "org"))
#+END_SRC

#+RESULTS:
| html | org  |     |     |     |     |     |     |     |   |    |
| org  | html |     |     |     |     |     |     |     |   |    |
| log  | tex  |     |     |     |     |     |     |     |   |    |
| tex  | log  |     |     |     |     |     |     |     |   |    |
| tex  | org  |     |     |     |     |     |     |     |   |    |
| org  | tex  |     |     |     |     |     |     |     |   |    |
| tex  | Rnw  |     |     |     |     |     |     |     |   |    |
| Rnw  | tex  |     |     |     |     |     |     |     |   |    |
| R    | Rnw  |     |     |     |     |     |     |     |   |    |
| Rnw  | R    |     |     |     |     |     |     |     |   |    |
| el   | org  |     |     |     |     |     |     |     |   |    |
| org  | el   |     |     |     |     |     |     |     |   |    |
| R    | Rnw  | tex |     |     |     |     |     |     |   |    |
| org  | el   | tex | log |     |     |     |     |     |   |    |
| cpp  | h    | hpp | ipp |     |     |     |     |     |   |    |
| ipp  | h    | hpp | cpp |     |     |     |     |     |   |    |
| hpp  | h    | ipp | cpp | cc  |     |     |     |     |   |    |
| cxx  | h    | hxx | ixx |     |     |     |     |     |   |    |
| ixx  | h    | hxx | cxx |     |     |     |     |     |   |    |
| hxx  | h    | ixx | cxx |     |     |     |     |     |   |    |
| c    | h    |     |     |     |     |     |     |     |   |    |
| m    | h    |     |     |     |     |     |     |     |   |    |
| mm   | h    |     |     |     |     |     |     |     |   |    |
| h    | c    | cc  | cpp | ipp | hpp | cxx | ixx | hxx | m | mm |
| cc   | h    | hh  | hpp |     |     |     |     |     |   |    |
| hh   | cc   |     |     |     |     |     |     |     |   |    |
| vert | frag |     |     |     |     |     |     |     |   |    |
| frag | vert |     |     |     |     |     |     |     |   |    |
| nil  | lock | gpg |     |     |     |     |     |     |   |    |
| lock |      |     |     |     |     |     |     |     |   |    |
| gpg  |      |     |     |     |     |     |     |     |   |    |

** Advice from Tuhdo for ignoring files

From https://github.com/bbatsov/projectile/issues/184

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'projectile-globally-ignored-files "*.png")
(setq projectile-globally-ignored-file-suffixes '(".cache"))
#+END_SRC

#+RESULTS:
| .cache |

* =helm-ag=:  Interface with Ag ("The Silver Searcher")

The Silver Searcher is grep-like program implemented by =C=. An attempt to make something better than =ack-grep=.

It searches pattern about 3–5x faster than ack-grep. It ignores file patterns from your .gitignore and .hgignore. 

[[https://github.com/ggreer/the_silver_searcher][The Silver Searcher]] is a very fast, smart code search tool, similar to
ack. Install it via homebrew. The emacs interface, `ag-mode`, is [[https://github.com/Wilfred/ag.el/#agel][described here]].

** Critical options: 

1. =-n --norecurse= Don't recurse into directories 
2. =-r --recurse= Recurse into directories when searching. Default it true.

#+BEGIN_SRC emacs-lisp :tangle yes
;; Originally in starter-kit-bindings.org like this
;;  (require 'ag)
;;  (define-key global-map "\C-x\C-a" 'ag) 
;;  (define-key global-map "\C-x\C-r" 'ag-regexp)

;; new bindings by DGM to try and use 'helm-ag
;;  (define-key global-map "\C-x\C-a" 'helm-ag) 
;;  (define-key global-map "\C-x\C-r" 'helm-ag-regexp)

(use-package ag 
  :ensure t)

(use-package helm-ag
  :ensure t
  :after (helm-mode ag)
  :bind ("M-p" . helm-projectile-ag)
  :init (setq helm-ag-base-command "/usr/bin/ag"
              helm-ag-insert-at-point t
              helm-ag-fuzzy-match     t
              helm-ag-command-option " --hidden" 
              helm-ag-use-agignore t)) 
#+END_SRC

#+RESULTS:
: helm-projectile-ag
 
* EXWM

Basic commands with for interfacing with =exwm= with =helm=

#+BEGIN_SRC emacs-lisp :tangle yes
(with-eval-after-load 'helm
  ;; Need `with-eval-after-load' here since 'helm-map is not defined in 'helm-config.
  ;;  (ambrevar/define-keys helm-map "s-\\" 'helm-toggle-resplit-and-swap-windows) ;; already used in starter-kit-exwm.org for ambrevar/toggle-window-split
  (exwm-input-set-key (kbd "s-c") #'helm-resume)
  (exwm-input-set-key (kbd "s-b") #'helm-mini)
  (exwm-input-set-key (kbd "s-f") #'helm-find-files)
  (exwm-input-set-key (kbd "s-F") #'helm-locate)
  (when (fboundp 'ambrevar/helm-locate-meta)
    (exwm-input-set-key (kbd "s-F") #'ambrevar/helm-locate-meta))
  (exwm-input-set-key (kbd "s-a") #'helm-ag)
  (exwm-input-set-key (kbd "s-A") #'helm-do-grep-ag)
  (exwm-input-set-key (kbd "s-g") 'ambrevar/helm-grep-git-or-ag)
  (exwm-input-set-key (kbd "s-G") 'ambrevar/helm-grep-git-all-or-ag))
#+END_SRC

** EXWM buffers with helm and make =helm-mini= almighty

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'helm-bookmark)

(when (require 'helm-exwm nil t)
  (add-to-list 'helm-source-names-using-follow "EXWM buffers")
  (setq helm-exwm-emacs-buffers-source (helm-exwm-build-emacs-buffers-source))
  (setq helm-exwm-source (helm-exwm-build-source))
  (setq helm-mini-default-sources `(helm-exwm-emacs-buffers-source
                                    helm-exwm-source
                                    helm-source-buffers-list
                                    helm-source-recentf
                                    ,(when (boundp 'helm-source-ls-git) 'helm-source-ls-git)
                                    helm-source-bookmarks
                                    helm-source-bookmark-set
                                    helm-source-buffer-not-found)))
;; Not sure how this works
;; (ambrevar/define-keys
;; helm-exwm-map
;;   "M-d" 'helm-buffer-run-kill-persistent
;;   "S-<return>" 'helm-buffer-switch-other-window)
  ;; Launcher
  (exwm-input-set-key (kbd "s-r") 'helm-run-external-command)
  ;; Web browser
  (exwm-input-set-key (kbd "s-w") #'helm-exwm-switch-browser)
  (exwm-input-set-key (kbd "s-W") #'helm-exwm-switch-browser-other-window)
#+END_SRC

#+RESULTS:

* Allowing =ido= mode

#+BEGIN_SRC emacs-lisp :tangle yes
(defun ido-recentf-open ()
  "Use `ido-completing-read' to find a recent file."
  (interactive)
  (if (find-file (ido-completing-read "Find recent file: " recentf-list))
      (message "Opening file...")
    (message "Aborting")))

(global-set-key (kbd "C-x f") 'ido-recentf-open)

(add-to-list 'helm-completing-read-handlers-alist '(ido-recentf-open  . ido))
#+END_SRC

#+RESULTS:
: ((ido-use-virtual-buffers . ido) (ido-recentf-open . ido) (recentf-open-files . ido) (describe-function . helm-completing-read-symbols) (describe-variable . helm-completing-read-symbols) (describe-symbol . helm-completing-read-symbols) (debug-on-entry . helm-completing-read-symbols) (find-function . helm-completing-read-symbols) (disassemble . helm-completing-read-symbols) (trace-function . helm-completing-read-symbols) (trace-function-foreground . helm-completing-read-symbols) (trace-function-background . helm-completing-read-symbols) (find-tag . helm-completing-read-default-find-tag) (org-capture . helm-org-completing-read-tags) (org-set-tags . helm-org-completing-read-tags) (ffap-alternate-file) (tmm-menubar) (find-file) (find-file-at-point . helm-completing-read-sync-default-handler) (ffap . helm-completing-read-sync-default-handler) (execute-extended-command) (dired-do-rename . helm-read-file-name-handler-1) (dired-do-copy . helm-read-file-name-handler-1) (dired-do-symlink . helm-read-file-name-handler-1) (dired-do-relsymlink . helm-read-file-name-handler-1) (dired-do-hardlink . helm-read-file-name-handler-1))

* Provide

#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'starter-kit-helm)
#+END_SRC

#+RESULTS:
: starter-kit-helm

* Final message
#+source: message-line
#+begin_src emacs-lisp :tangle yes
(message "Starter Kit Helm File loaded.")
#+end_src

#+RESULTS: message-line
: Starter Kit User File loaded.

