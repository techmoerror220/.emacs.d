#+TITLE: Starter Kit Python
#+OPTIONS: toc:nil num:nil ^:nil

This is part of the [[file:starter-kit.org][Emacs Starter Kit]].

* Starter kit Python

Support for the Python programming language.

** Check Dependencies

Determine whether required packages are installed. If not, use ELPA to
install them.
#+begin_src emacs-lisp
;; commented out because ipython not available  (dolist (package '(python-mode ipython))
  (dolist (package '(python-mode))
    (unless (package-installed-p package)
      (package-install package)))
#+end_src

** Use Python's python-mode.el instead of Emacs' python.el
   :PROPERTIES:
   :CUSTOM_ID: python
   :END:
Replace the Python mode that comes with Emacs by the Python mode
supplied by the Python distribution itself.
#+begin_src emacs-lisp
    
  (autoload 'python-mode "python-mode" "Python Mode." t)
  (add-to-list 'auto-mode-alist '("\\.py\\'" . python-mode))
  (add-to-list 'interpreter-mode-alist '("python" . python-mode))
    
  (setq
;;   python-shell-interpreter "ipython"
   python-shell-interpreter "python3"
   python-shell-interpreter-args ""
   python-shell-prompt-regexp "In \\[[0-9]+\\]: "
   python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
   python-shell-completion-setup-code
     "from IPython.core.completerlib import module_completion"
   python-shell-completion-module-string-code
   "';'.join(module_completion('''%s'''))\n"
   python-shell-completion-string-code
     "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")
    
#+end_src

** Use Cython mode
   :PROPERTIES:
   :CUSTOM_ID: cython
   :END:
#+begin_src emacs-lisp
  (when (require 'cython-mode nil 'no-error)
    (add-to-list 'auto-mode-alist '("\\.pyx\\'" . cython-mode))
    (add-to-list 'auto-mode-alist '("\\.pxd\\'" . cython-mode))
    (add-to-list 'auto-mode-alist '("\\.pxi\\'" . cython-mode)))
#+end_src

#+source: message-line
#+begin_src emacs-lisp
  (message "Starter Kit Python loaded.")
#+end_src

** Tip from Ista Zahn
tip from: https://github.com/izahn/dotemacs

Emacs has decent python support out of the box. As with other programming languages you can get completion suggestions with the tab key, and evaluate code with C-ret. Many more features are provided and are accessible via the menu.

I commment it out until i discover what modification is preventing auto-completion to run in python mode.

#+begin_src emacs-lisp
  (with-eval-after-load "python"
    ;; try to get indent/completion working nicely
    (setq python-indent-trigger-commands '(company-indent-for-tab-command indent-for-tab-command yas-expand yas/expand))
    ;; readline support is wonky at the moment
    (setq python-shell-completion-native-enable nil))

  ;; simple evaluation with C-ret originally in Ista's code that I, dgm, have changed to S-return to mimic behaviour in R as explained by the great KHJ in
  ;; https://kieranhealy.org/blog/archives/2009/10/12/make-shift-enter-do-a-lot-in-ess/
;;  (require 'eval-in-repl-python)
;;  (define-key python-mode-map "\C-c\C-c" 'eir-eval-in-python)
;;  (define-key python-mode-map (kbd "<M-return>") 'eir-eval-in-python)
;;  (define-key python-mode-map (kbd "<S-return>") 'eir-eval-in-python) 
#+end_src

#+RESULTS:
: eir-eval-in-python

Nota: 
Comento la última parte del código con los key bindings porque no funcionaban: están superceded by ELPY mode, where, by the way, C-return is already bound to send code, so no need to do anything. 

Respecto a la línea  de input line extra, no es nada grave pero un poco molesto... no sé cómo corregirlo. ahhh, no está bien! Lo que pasa es que si hay una línea vacía tras una operación, el cursor va a esa línea, la envia a REPL y esta repite el número de input, tal y como haría si doy a =return= en la línea de input en REPL, aka iPython.


** Getting rid of Warning message

Elpy fix for "native completion" warning as resolved according to cpitclaudel's solution posted at https://github.com/jorgenschaefer/elpy/issues/887
Ideally this segment belongs at lisp/progmodes/python.el:3292

#+BEGIN_SRC emacs-lisp
  (defun python-shell-completion-native-try ()
    "Return non-nil if can trigger native completion."
    (with-eval-after-load 'python
      '(let ((python-shell-completion-native-enable t)
             (python-shell-completion-native-output-timeout
              python-shell-completion-native-try-output-timeout)
             (python-shell-completion-native-get-completions
              (get-buffer-process (current-buffer))
              nil "_")))
      ))

#+END_SRC


#+RESULTS:
: python-shell-completion-native-try





