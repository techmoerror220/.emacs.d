# -*- coding: utf-8 -*-
# -*- find-file-hook: org-babel-execute-buffer -*-

#+TITLE: Local User Customizations
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args :tangle yes

Adding this line to test magit.

* Starter Kit kjhealy
This file contains local customizations---ones that in some cases
you will not be able to just drop in and use because, e.g., they
involve references to particular files on my own machine. It's
included here for completeness, and as and example of the kind of
things you might put in your own user-specific file.

Some of the settings here depend on additional software that you may
not have installed by default. E.g., the "Use GNU ls" section below
depends on you having GNU coreutils installed. To ignore these
sections, add `:tangle no` to any code block you don't want to use.

To use the customizations here yourself, /you must change the name of
 this file to match your own user name or system name/. Those are the
 values of the Emacs variables =user-login-name= or =system-name=, so
 that it will be picked up by =init.el= when Emacs starts up, and get
 loaded properly. To find the current value of these variables on your
 system, launch emacs and do =C-h-v system-name [RET]= or =C-h-v
 user-login-name [RET]=. For example, on my system =user-login-name=
 is 'kjhealy', so this file is named =kjhealy.org=, and when Emacs
 starts up with the starter kit it creates the file =kjhealy.el=.

You will also need to change the values for the location of bibtex
 databases, pandoc and orgmode-mobile specified below, and some other
 settings. *Search for 'kjhealy' in this file* to find the paths that
 need to be updated. Change them as needed or delete them if you don't
 need these features.

** Local Miscellaneous Settings
*** Use GNU ls
OS X ships with BSD's ls command which doesn't have all the features of GNU ls (used internally by dired). Install `coreutils` with homebrew (`brew install coreutils`) and use `gls` instead.

#+source: gnu-ls
#+begin_src emacs-lisp :tangle yes
  (setq insert-directory-program (executable-find "ls"))
#+end_src

#+RESULTS: gnu-ls
: /bin/ls

*** One space after period

Use =M-e= for sentence-level navigation, but without having to put two spaces after a period like an animal.

#+source: periods
#+begin_src emacs-lisp :tangle yes
  (setq sentence-end-double-space nil)
#+end_src

#+RESULTS: periods

*** Run Emacs in Full Screen
  I find it very useful to run Emacs in full-screen mode. There is no
    completely satisfactory way to accomplish this on Mac OS X. What
    works depends on the flavor of emacs you are using,
    unfortunately. Choose as appropriate from the following options. Enable one of them by changing the value of =:tangle= to =yes=.

Bind full screen to `C-c f`.

#+source: fullscreen-4
#+begin_src emacs-lisp :tangle yes
    (defun fullscreen (&optional f)
      (interactive)
      (set-frame-parameter f 'fullscreen
                           (if (frame-parameter f 'fullscreen) nil 'fullboth)))
    (global-set-key (kbd "C-c f") 'fullscreen)        
    (add-hook 'after-make-frame-functions 'fullscreen)
#+end_src

#+RESULTS: fullscreen-4
| fullscreen | x-dnd-init-frame |

*** COMMENT Mac Key mode
    Used with Mitsuharu Yamamoto's carbon-patched Emacs, which turns
    off support for default mac bindings. Turned off by default.
#+srcname: mac-keys
#+begin_src emacs-lisp :tangle yes
   (require 'mac-key-mode)
   (mac-key-mode 1)
   (add-hook 'mac-key-mode-hook
       (lambda()
         (interactive)
         (if mac-key-mode
             (setq mac-option-modifier 'meta)
             (setq mac-option-modifier nil)
             )))
#+end_src

** Dired
*** Dired-x

Dired extensions. Dired-x (Dired Extra) is not like Dired-plus. The former is part of the standard distribution of emacs. 

Modified following the advice in the *info* node on installation of dired-x

#+source: Dired-x
#+begin_src emacs-lisp :tangle yes
;;  (load "dired-x")
     (add-hook 'dired-load-hook
               (lambda ()
                 (load "dired-x")
                 ;; Set dired-x global variables here.  For example:
                 ;; (setq dired-guess-shell-gnutar "gtar")
                 ;; (setq dired-x-hands-off-my-keys nil)
                 ))
     (add-hook 'dired-mode-hook
               (lambda ()
                 ;; Set dired-x buffer-local variables here.  For example:
                 ;; (dired-omit-mode 1)
                 ))
#+end_src

#+RESULTS: Dired-x
| (lambda nil) | (lambda nil (let ((now (lookup-key dired-mode-map J))) (if (and now (not (eq now 'undefined))) nil (define-key dired-mode-map J 'bmkp-dired-jump)) (setq now (lookup-key dired-mode-map |


Further customization that I originally had within the block on dired plus that I actually do not use!

First I set dired listing options. Originally, among the options there was a =p= in =-alDhp= but in https://www.reddit.com/r/emacs/comments/9flask/dired_mode_move_directory/ they explain that this causes failure when moving directories. The =p= flag to =ls= appends a slash (=/=) indicator to directories.

Then I added to option to list directories first that I found in https://www.emacswiki.org/emacs/DiredSorting

#+BEGIN_SRC emacs-lisp :tangle yes
(if (eq system-type 'gnu/linux)
    (setq dired-listing-switches "-alDh --group-directories-first")) 
(defun ensure-buffer-name-ends-in-slash ()
  "change buffer name to end with slash"
  (let ((name (buffer-name)))
    (if (not (string-match "/$" name))
        (rename-buffer (concat name "/") t))))
(add-hook 'dired-mode-hook 'ensure-buffer-name-ends-in-slash)
(add-hook 'dired-mode-hook
          (lambda()
             (setq truncate-lines 1)))
#+END_SRC

Open files in external programs (from http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html
Consider replacing with https://github.com/thamer/runner.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-open-in-external-app (&optional file)
  "Open the current file or dired marked files in external app.
The app is chosen from your OS's preference."
  (interactive)
  (let (doIt
        (myFileList
         (cond
          ((string-equal major-mode "dired-mode")
           (dired-get-marked-files))
          ((not file) (list (buffer-file-name)))
          (file (list file)))))
    (setq doIt (if (<= (length myFileList) 5)
                   t
                 (y-or-n-p "Open more than 5 files? ")))
    (when doIt
      (cond
       ((string-equal system-type "windows-nt")
        (mapc
         (lambda (fPath)
           (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)))
         myFileList))
       ((string-equal system-type "darwin")
        (mapc
         (lambda (fPath)
           (shell-command (format "open \"%s\"" fPath)))
         myFileList))
       ((string-equal system-type "gnu/linux")
        (mapc
         (lambda (fPath)
           (let ((process-connection-type nil))
             (start-process "" nil "xdg-open" fPath))) myFileList))))))
;; use zip/unzip to compress/uncompress zip archives
(with-eval-after-load "dired-aux"
  (add-to-list 'dired-compress-file-suffixes
               '("\\.zip\\'" "" "unzip"))
  ;; open files from dired with "E"
  (define-key dired-mode-map (kbd "E") 'xah-open-in-external-app))
#+END_SRC

*** Dired open multiple files
In dired mode, visit all marked files using. Bound to the "F" key.
#+source: dired-F
#+begin_src emacs-lisp :tangle yes
  (eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "F" 'my-dired-find-file)
     (defun my-dired-find-file (&optional arg)
       "Open each of the marked files, or the file under the point, or when prefix arg, the next N files "
       (interactive "P")
       (let* ((fn-list (dired-get-marked-files nil arg)))
         (mapc 'find-file fn-list)))))
#+end_src

#+RESULTS: dired-F
: my-dired-find-file

*** Stripe Dired buffers

Use different background colors for even and odd lines. Info here https://github.com/sabof/stripe-buffer

With the help of library hl-line-mode yet another color can be used for the current line.

**** highlight line

#+BEGIN_SRC emacs-lisp  :tangle yes
(use-package hl-line)
;; (global-hl-line-mode t)
;;(set-face-background 'hl-line "#bebebe")
#+END_SRC

#+RESULTS:

Use different background colors for even and odd lines. With =(add-hook 'dired-mode-hook 'stripe-listify-buffer)= I could get a horizontal line instead of a cursor. It uses the stripe-hl-line face, which you might wish to customize.

#+name: stripe-dired
#+begin_src emacs-lisp :tangle yes
(use-package stripe-buffer)
(add-hook 'org-mode-hook 'org-table-stripes-enable)
;; (add-hook 'dired-mode-hook 'stripe-listify-buffer)  
#+END_SRC

*** diff-hl 
Emacs package for highlighting uncommitted changes. See https://github.com/dgutov/diff-hl

diff-hl-mode highlights uncommitted changes on the left side of the window, allows you to jump between and revert them selectively.

For the usage instructions and the list of commands, see the Commentary section inside the file.

Tested with Git, Mercurial, Bazaar and SVN. May work with other VC backends, too.

The package also contains auxiliary modes:

    diff-hl-dired-mode provides similar functionality in Dired.
    diff-hl-margin-mode changes the highlighting function to use the margin instead of the fringe.
    diff-hl-amend-mode shifts the reference revision back by one.
    diff-hl-flydiff-mode implements highlighting changes on the fly. It requires Emacs 24.4 or newer.

Check out the Commentary section in each respective file for the usage instructions.

#+begin_src emacs-lisp :tangle no
(use-package diff-hl)
(global-diff-hl-mode)
;; (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
(remove-hook 'dired-mode-hook 'diff-hl-dired-mode)
(remove-hook 'dired-mode-hook 'hl-line-mode)
#+END_SRC

#+RESULTS:
| (lambda nil (let ((now (lookup-key dired-mode-map J))) (if (and now (not (eq now 'undefined))) nil (define-key dired-mode-map J 'bmkp-dired-jump)) (setq now (lookup-key dired-mode-map |

** Avy Mode
From: http://oremacs.com/2016/01/23/avy-0.4.0/

For example, suppose you have:

=(global-set-key (kbd "M-t") 'avy-goto-word-1)=

Here's what you can do now to a word that starts with a "w" and is select-able with "a":

    To jump there: =M-t w a=.
    To copy the word instead of jumping to it: =M-t w na=
    To mark the word after jumping to it: =M-t w ma=.
    To kill the word after jumping to it: =M-t w xa=.

Note I have binded to =C-o= instead of =M-t=:

Further words from Uncle Dave at https://github.com/daedreth/UncleDavesEmacs:

-  avy and why it’s the best thing in existence
Many times have I pondered how I can move around buffers even quicker. I’m glad to say, that avy is precisely what I needed, and it’s precisely what you need as well. In short, as you invoke one of avy’s functions, you will be prompted for a character that you’d like to jump to in the visible portion of the current buffer. Afterwards you will notice how all instances of said character have additional letter on top of them. Pressing those letters, that are next to your desired character will move your cursor over there. Admittedly, this sounds overly complicated and complex, but in reality takes a split second and improves your life tremendously.

I like M-s for it, same as C-s is for moving by searching string, now M-s is moving by searching characters.

#+name: avy-mode
#+begin_src emacs-lisp :tangle yes
(use-package avy
  :ensure t
  :bind
    ("s-z" . avy-goto-char))  ;; goes literally to any char

(define-key global-map (kbd "C-o") 'avy-goto-word-1) ;; goes to word that starts with a given char
#+end_src

#+RESULTS: avy-mode
: avy-goto-word-1

* dgm's own customizations of emacs appearance
** GROUP: Convenience -> Linum

Next tip from http://tuhdo.github.io/emacs-tutor3.html
It enables linum only in programming modpes

#+srcname: line-numbering
#+begin_src emacs-lisp :tangle yes
 (add-hook 'prog-mode-hook 'linum-mode)
#+end_src

#+RESULTS: line-numbering
| linum-mode | (lambda nil (highlight-symbol-mode)) | highlight-numbers-mode | clean-aindent-mode |

Tip from https://www.emacswiki.org/emacs/SmoothScrolling

#+BEGIN_SRC emacs-lisp :tangle yes
;; Delay updates to give Emacs a chance for other changes
(setq linum-delay t)
#+END_SRC

** GROUP: Convenience -> Whitespace

Whenever you create useless whitespace, the whitespace is highlighted

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))

;; activate whitespace-mode to view all whitespace characters
(global-set-key (kbd "C-c w") 'whitespace-mode)
#+END_SRC    

#+RESULTS:
: whitespace-mode

*** speed-type

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package speed-type)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23592 62602 668192 845000) :init (23592 62602 668160 862000) :config (23592 62602 667754 576000) :config-secs (0 0 16 248000) :init-secs (0 0 713 570000) :use-package-secs (0 0 795 338000)))


*** iedit mode
Check this post: https://www.masteringemacs.org/article/iedit-interactive-multi-occurrence-editing-in-your-buffer

#+begin_src emacs-lisp :tangle yes
(use-package iedit)

;; activate this function by Mickey Petersen if you wish to use iedit only in current function and not all across the buffer.
;; (defun iedit-dwim (arg)
;;   "Starts iedit but uses \\[narrow-to-defun] to limit its scope."
;;   (interactive "P")
;;   (if arg
;;       (iedit-mode)
;;     (save-excursion
;;       (save-restriction
;;         (widen)
;;         ;; this function determines the scope of `iedit-start'.
;;         (if iedit-mode
;;             (iedit-done)
;;           ;; `current-word' can of course be replaced by other
;;           ;; functions.
;;           (narrow-to-defun)
;;           (iedit-start (current-word) (point-min) (point-max)))))))

(global-set-key (kbd "C-;") 'iedit-dwim)
#+end_src

#+RESULTS:
: iedit-dwim

** =ggtags= customization from tuhdo

#+srcname: ggtags-customization
#+begin_src emacs-lisp :tangle yes
(add-hook 'c-mode-common-hook
    (lambda ()
      (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
  (ggtags-mode 1))))
#+end_src

#+RESULTS: ggtags-customization
| lambda | nil | (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode) (ggtags-mode 1))       |
| lambda | nil | (if (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode) (progn (ggtags-mode 1))) |

#+RESULTS:
| lambda | nil | (when (derived-mode-p (quote c-mode) (quote c++-mode) (quote java-mode) (quote asm-mode)) (ggtags-mode 1)) |

** GROUP: Editing -> Editing Basics from http://tuhdo.github.io/emacs-tutor3.html

*** ring-max

#+srcname: ring-max
#+BEGIN_SRC emacs-lisp :tangle yes
(setq global-mark-ring-max 5000     ; increase mark ring to contain 5000 entries
      mark-ring-max 5000            ; increase kill ring to contain 5000 entries
      mode-require-final-newline t) ; add a newline to end of file
#+END_SRC

#+RESULTS: ring-max
: t

#+RESULTS:
: 5000

#+srcname: killing
#+BEGIN_SRC emacs-lisp :tangle yes
(setq
 kill-ring-max 5000 ; increase kill-ring capacity
;; kill-whole-line t  ; if NIL, killwhole line and move the next line up / commented out by dgm as it might interere with kill-whole-line-or-region mode
)
#+END_SRC

#+RESULTS: killing
: t

#+RESULTS:
: t

*** tab-width

Default to 4 visible spaces to display a tab. Sacha has it at 2: =(setq-default tab-width 2)=

#+srcname: tab-width
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default tab-width 4)
#+END_SRC

#+RESULTS: tab-width
: 4

*** workgroups

From https://github.com/pashinin/workgroups2 and http://tuhdo.github.io/emacs-tutor3.html

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (require 'workgroups2)

  ;; Change workgroups session file
  ;; (setq wg-session-file "~/.emacs.d/.emacs_workgroups")
  ;; (wg-find-session-file "~/.emacs.d/.emacs_workgroups") ;; for emacs to load this file on startup... but it doesn't work... don't know why...

  ;; Set your own keyboard shortcuts to reload/save/switch WGs:
  ;; "s" == "Super" or "Win"-key, "S" == Shift, "C" == Control
  ;; (global-set-key (kbd "<pause>")     'wg-reload-session)
  ;; (global-set-key (kbd "C-S-<pause>") 'wg-save-session)
  ;; (global-set-key (kbd "s-z")         'wg-switch-to-workgroup)
  ;; (global-set-key (kbd "s-/")         'wg-switch-to-previous-workgroup)

  ;; What to do on Emacs exit / workgroups-mode exit?
  ;; (setq wg-emacs-exit-save-behavior           'save)      ; Options: 'save 'ask nil
  ;; (setq wg-workgroups-mode-exit-save-behavior 'save)      ; Options: 'save 'ask nil

  ;; (workgroups-mode 1)   ; put this one at the bottom of .emacs
#+END_SRC

#+RESULTS:

*** diff-mode 
#+srcname: whitespace
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'diff-mode-hook (lambda ()
                              (setq-local whitespace-style
                                          '(face
                                            tabs
                                            tab-mark
                                            spaces
                                            space-mark
                                            trailing
                                            indentation::space
                                            indentation::tab
                                            newline
                                            newline-mark))
                              (whitespace-mode 1)))
#+END_SRC

*** Attach multiple files

Attach multiple files to mu4e email message. (Tip from http://www.djcbsoftware.nl/code/mu/mu4e/Attaching-files-with-dired.html).

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'gnus-dired)
;; make the `gnus-dired-mail-buffers' function also work on
;; message-mode derived modes, such as mu4e-compose-mode
(defun gnus-dired-mail-buffers ()
  "Return a list of active message buffers."
  (let (buffers)
    (save-current-buffer
      (dolist (buffer (buffer-list t))
        (set-buffer buffer)
        (when (and (derived-mode-p 'message-mode)
                (null message-sent-message-via))
          (push (buffer-name buffer) buffers))))
    (nreverse buffers)))

(setq gnus-dired-mail-mode 'mu4e-user-agent)
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
#+END_SRC

#+RESULTS:
| diff-hl-dired-mode | stripe-listify-buffer | (lambda nil (setq truncate-lines 1)) | ensure-buffer-name-ends-in-slash | (lambda nil) | turn-on-gnus-dired-mode | helm-gtags-mode |

*** Volatile 

=volatile= makes so that when you yank (paste) something, the yanked (pasted) region will be highlighted.
See http://tuhdo.github.io/emacs-tutor3.html

#+srcname: volatile
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package volatile-highlights)
(volatile-highlights-mode t)
#+END_SRC

#+RESULTS: volatile
: t

#+RESULTS:
: t

*** Clean-indent

#+srcname: clean-indent
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package clean-aindent-mode)
(add-hook 'prog-mode-hook 'clean-aindent-mode)

 (defun my-pkg-init()
   (electric-indent-mode -1)  ; no electric indent, auto-indent is sufficient
   (clean-aindent-mode t)
   (setq clean-aindent-is-simple-indent t)
   (define-key global-map (kbd "RET") 'newline-and-indent))
 (add-hook 'after-init-hook 'my-pkg-init)
#+END_SRC

#+RESULTS: clean-indent
| my-pkg-init | #[0 \303\211\235\203 \304"\301\305!\210\210	\205 \306 \210\307\211\207 [command-line-args desktop-save-mode inhibit-startup-screen --no-desktop delete 0 desktop-read t] 4] | global-company-mode | ambrevar/reset-file-name-handler-alist | ambrevar/reset-gc-cons-threshold | x-wm-set-size-hint | tramp-register-archive-file-name-handler | table--make-cell-map | magit-auto-revert-mode--init-kludge | magit-startup-asserts | magit-version |


*** Undo-tree 

undo-tree set up from http://pragmaticemacs.com/emacs/advanced-undoredo-with-undo-tree/
More info here: https://www.emacswiki.org/emacs/UndoTree

Sacha Chua says: People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo. 

This lets you use C-x u (undo-tree-visualize) to visually walk through the changes you've made, undo back to a certain point
(or redo), and go down different branches. 

#+srcname: undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))

;; make ctrl-z undo
(global-set-key (kbd "C-z") 'undo)
;; make ctrl-Z redo
(defalias 'redo 'undo-tree-redo)
(global-set-key (kbd "C-S-z") 'redo)
#+END_SRC

#+RESULTS: undo-tree
: redo

See https://www.reddit.com/r/emacs/comments/5h7k1r/undo_lost_hours_of_work//
Also read http://ergoemacs.org/emacs/emacs_undo_cult_problem.html
However, with =helm-ag= I'm getting errors that seem related to undo-tree, plus I got issues with the git repository changing just because of the undo history and it is not worthwhile, so I comment this out.


#+BEGIN_SRC emacs-lisp :tangle no
;;(setq undo-tree-auto-save-history t)
;;(setq undo-tree-history-directory-alist
;;    (quote (("" . "~/.emacs.d/undo_hist"))))
#+END_SRC

#+RESULTS:
: t

*** auto-file-revert
#+srcname: file-revert
#+BEGIN_SRC emacs-lisp :tangle yes
;; update any change made on file to the current buffer
(global-auto-revert-mode)
#+END_SRC

#+RESULTS:
: t

*** fill-column 

#+srcname: fill-column
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default fill-column 72)
#+END_SRC

*** ibuffer-use-other-window

#+srcname: ibuffer
#+BEGIN_SRC emacs-lisp :tangle yes
;; always display ibuffer in another window
(setq ibuffer-use-other-window t)
#+END_SRC

*** COMMENT Company mode 

Included in =starter-kit-completion.org=

#+srcname: company
#+BEGIN_SRC emacs-lisp :tangle no
;; (add-hook 'after-init-hook 'global-company-mode) 
#+END_SRC

#+RESULTS: company
| my-pkg-init | #[0 \303\211\235\203 \304"\301\305!\210\210	\205 \306 \210\307\211\207 [command-line-args desktop-save-mode inhibit-startup-screen --no-desktop delete 0 desktop-read t] 4] | global-company-mode | ambrevar/reset-file-name-handler-alist | ambrevar/reset-gc-cons-threshold | x-wm-set-size-hint | tramp-register-archive-file-name-handler | table--make-cell-map | magit-auto-revert-mode--init-kludge | magit-startup-asserts | magit-version |


*** Duplicate-thing

#+srcname: duplicate
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package duplicate-thing)
(global-set-key (kbd "M-D") 'duplicate-thing)
#+END_SRC

#+srcname: ibuffer-vc
#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'ibuffer-hook
          (lambda ()
            (ibuffer-vc-set-filter-groups-by-vc-root)
            (unless (eq ibuffer-sorting-mode 'alphabetic)
              (ibuffer-do-sort-by-alphabetic))))

(setq ibuffer-formats
      '((mark modified read-only vc-status-mini " "
              (name 18 18 :left :elide)
              " "
              (size 9 -1 :right)
              " "
              (mode 16 16 :left :elide)
              " "
              (vc-status 16 16 :left)
              " "
              filename-and-process)))
#+END_SRC

#+RESULTS: ibuffer-vc
| mark | modified | read-only | vc-status-mini |   | (name 18 18 :left :elide) |   | (size 9 -1 :right) |   | (mode 16 16 :left :elide) |   | (vc-status 16 16 :left) |   | filename-and-process |

*** Dired plus

#+srcname: dired+
#+BEGIN_SRC emacs-lisp :tangle yes
;; (require 'dired+)

;; copied  by dgm from: http://emacs-leuven.readthedocs.io/en/latest/?badge=latest

    ;; Don't hide details in Dired.
;;    (setq diredp-hide-details-initially-flag nil)

    ;; Don't display the next Dired buffer the same way as the last.
;;    (setq diredp-hide-details-propagate-flag nil)

    ;; Don't wrap "next" command around to buffer beginning.
    ;; (setq diredp-wrap-around-flag nil)

    ;; Dired `find-file' commands reuse directories.
    ;; (diredp-toggle-find-file-reuse-dir 1)

    ;; Up, reusing Dired buffers.
    ;; (define-key dired-mode-map (kbd "C-x C-j")
    ;;  #'diredp-up-directory-reuse-dir-buffer)

;; tips from Ista Zahn. Not sure if they require dired+
;; https://github.com/izahn/dotemacs

;;; Dired and Dired+ configuration
;; this is commented as it is reapplied somewhere else in this file
;; (add-hook 'dired-mode-hook
;;          (lambda()
;;            (diff-hl-dired-mode)
;;            (diff-hl-margin-mode)))

#+END_SRC

Set emacs to open Bookmark+ on start. From Xah Emacs. Disabled now that I use =Dashboard=

#+srcname: bookmarks
#+BEGIN_SRC emacs-lisp :tangle no
  ;; included by dgm
;;   (setq inhibit-splash-screen t)
  ;; (require 'bookmark+) ;; no longer available in MELPA
;;  (bookmark-bmenu-list)
;;  (switch-to-buffer "*Bookmark List*")
  ;; '(initial-buffer-choice "*Bookmark List*")
  ;; (setq initial-buffer-choice "*Bookmark List*")
#+END_SRC


#+RESULTS: bookmarks


#+srcname: custom-setup
#+BEGIN_SRC emacs-lisp :tangle no
;;    Load the files in CustomDir using mapc:
;; (mapc 'load (directory-files "~/.emacs.d/customDir" t ".*\.el"))
;; (add-to-list 'load-path "~/.emacs.d/customDir/")
;; (require 'setup-programming)
#+END_SRC


I disable this as flycheck makes emacs too slow.
#+srcname: flycheck-tip
#+BEGIN_SRC emacs-lisp :tangle yes
;;  (require 'flycheck-tip)
;;  (define-key global-map (kbd "\C-c \C-n") 'flycheck-tip-cycle)
;;  (setq flycheck-display-errors-function 'ignore)
#+END_SRC

#+RESULTS: flycheck-tip
: ignore

#+RESULTS:
: ignore


For now, I deactivate the golden-ratio mode because it distract me too much.

#+srcname: golden-ratio
#+BEGIN_SRC emacs-lisp :tangle no
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: golden-ratio                         ;;
  ;;                                               ;;
  ;; GROUP: Environment -> Windows -> Golden Ratio ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; activate for helm when helm is installed
  ;; (require 'golden-ratio)

  ;; (add-to-list 'golden-ratio-exclude-modes "ediff-mode")
  ;; (add-to-list 'golden-ratio-exclude-modes "helm-mode")
  ;; (add-to-list 'golden-ratio-exclude-modes "dired-mode")
  ;; (add-to-list 'golden-ratio-exclude-modes "ess-mode")

  ;; I dont want the golden ratio with the Helm window
  ;;  (defun pl/helm-alive-p ()
  ;;   (if (boundp 'helm-alive-p)
  ;;       (symbol-value 'helm-alive-p)))

  ;;  (add-to-list 'golden-ratio-inhibit-functions 'pl/helm-alive-p)

  ;; do not enable golden-ratio in theses modes
;;   (setq golden-ratio-exclude-modes '("ediff-mode"
;;                                      "gud-mode"
;;                                      "gdb-locals-mode"
;;                                      "gdb-registers-mode"
;;                                      "gdb-breakpoints-mode"
;;                                      "gdb-threads-mode"
;;                                      "gdb-frames-mode"
;;                                      "gdb-inferior-io-mode"
;;                                      "gud-mode"
;;                                      "gdb-inferior-io-mode"
;;                                      "gdb-disassembly-mode"
;;                                      "gdb-memory-mode"
;;   ;;                                   "magit-log-mode"
;;   ;;                                   "magit-reflog-mode"
;;   ;;                                   "magit-status-mode"
;;                                      "IELM"
;;                                      "eshell-mode"
;;                                      "dired-mode"
;;                                      "helm-mode"
;;                                      "ess-mode"))
  ;; delete "dired-mode"  from the above list if you want golden-ratio to apply to helm

;;   (golden-ratio-mode)
#+END_SRC

#+RESULTS: golden-ratio :tangle no


I disable this as it is dealt with in -misc.org
#+srcname: frame-title
#+BEGIN_SRC emacs-lisp :tangle no
;; more useful frame title, that show either a file or a
;; buffer name (if the buffer isn't visiting a file)
;; taken from prelude-ui.el
;; (setq frame-title-format
;;      '("" invocation-name " - " (:eval (if (buffer-file-name)
;;                                                    (abbreviate-file-name (buffer-file-name))
;;                                                  "%b"))))
#+END_SRC

#+RESULTS: frame-title
|   | invocation-name | - | (:eval (if (buffer-file-name) (abbreviate-file-name (buffer-file-name)) %b)) |

*** highlight-numbers-and-symbols

#+srcname: highlight-numbers-and-symbols
#+BEGIN_SRC emacs-lisp :tangle yes

(use-package highlight-numbers)
(use-package highlight-symbol)

(add-hook 'prog-mode-hook 'highlight-numbers-mode)

(highlight-symbol-nav-mode)

(add-hook 'prog-mode-hook (lambda () (highlight-symbol-mode)))
(add-hook 'org-mode-hook (lambda () (highlight-symbol-mode)))

(setq highlight-symbol-idle-delay 0.2
      highlight-symbol-on-navigation-p t)

(global-set-key [(control shift mouse-1)]
                (lambda (event)
                  (interactive "e")
                  (goto-char (posn-point (event-start event)))
                  (highlight-symbol-at-point)))

;; keybinds conflict so...
;;(global-set-key (kbd "M-n") 'highlight-symbol-next)
;;(global-set-key (kbd "M-p") 'highlight-symbol-prev)
#+END_SRC

#+RESULTS: highlight-numbers-and-symbols
| lambda | (event) | (interactive e) | (goto-char (posn-point (event-start event))) | (highlight-symbol-at-point) |

*** Info Plus
#+srcname: info+
#+BEGIN_SRC emacs-lisp :tangle yes
;; (use-package info+) ;;no longer available in MELPA?
#+END_SRC

#+RESULTS: info+
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23561 13963 178544 695000) :init (23561 13963 178532 465000) :init-secs (0 0 15510 311000) :use-package-secs (0 4 529907 38000)))

*** Discover my major 
#+srcname: discover-my-major
#+BEGIN_SRC emacs-lisp :tangle yes
;; A quick major mode help with discover-my-major
(global-unset-key (kbd "C-h h"))        ; original "\C-h h" displays "hello world" in different languages
(define-key 'help-command (kbd "h m") 'discover-my-major)
#+END_SRC

#+RESULTS: discover-my-major
: discover-my-major

*** Rainbow mode
#+srcname: rainbow-mode
#+BEGIN_SRC emacs-lisp :tangle yes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PACKAGE: rainbow-mode              ;;
;;                                    ;;
;; GROUP: Help -> Rainbow             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(use-package rainbow-mode
  :ensure t
  :config
  (add-hook 'prog-mode-hook         #'rainbow-mode)
  (add-hook 'html-mode-hook         #'rainbow-mode)
  (add-hook 'css-mode-hook          #'rainbow-mode)
  (add-hook 'org-mode-hook          #'rainbow-mode)
  (add-hook 'latex-mode-hook        #'rainbow-mode)
  (add-hook 'R-mode-hook            #'rainbow-mode)
  (add-hook 'inferior-ess-mode-hook #'rainbow-mode)
  (add-hook 'python-mode-hook       #'rainbow-mode)
 )

;;R-mode-hook runs when you open a new source buffer, so anything you put in that will only effect your source buffers.inferior-ess-mode-hook runs when you start an R console, so anything in there should only apply to the console buffer and not the source.
#+END_SRC

#+RESULTS: rainbow-mode
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23593 1042 76652 672000) :init (23593 1042 76606 522000) :config (23593 1042 76259 444000) :config-secs (0 0 777 90000) :init-secs (0 0 1377 923000) :use-package-secs (0 0 1502 38000)))

*** Kurecolor

- See this video to watch it live: https://www.youtube.com/watch?v=OMIxZhLU71U

- Documentation here: https://github.com/emacsfodder/kurecolor

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package kurecolor)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23593 3701 118599 80000) :init (23593 3701 118292 444000) :init-secs (0 0 61 29000) :use-package-secs (0 0 537 230000)))

*** Nyam-mode

Only turn on if a window system is available. This prevents error under terminal that does not support X.

#+srcname: nyan-mode
#+BEGIN_SRC emacs-lisp :tangle no
(case window-system
  ((x w32) (nyan-mode)))
#+END_SRC

#+RESULTS: nyan-mode
: t


#+srcname: spaceline
#+BEGIN_SRC emacs-lisp :tangle yes
;; (require 'spaceline-config)
;; (spaceline-emacs-theme)
;; (spaceline-helm-mode)
#+END_SRC

#+RESULTS: spaceline
: t


#+srcname: powerline
#+begin_src emacs-lisp :tangle no
;;  (require 'powerline)
;;  (powerline-default-theme)
#+end_src

#+srcname: modeline
#+begin_src emacs-lisp :tangle yes
;; (require 'smart-mode-line)
;;       (require 'smart-mode-line-powerline-theme)
;;       (sml/apply-theme 'powerline)


;; (setq powerline-arrow-shape 'curve)
;; (setq powerline-default-separator-dir '(right . left))
;; (setq sml/theme 'powerline)
;; (setq sml/mode-width 0)
;; (setq sml/name-width 20)
;; (rich-minority-mode 1)
;; (setf rm-blacklist "")
;; (sml/setup)


;; (if (require 'smart-mode-line nil 'noerror)
;;     (progn
;;       (setq sml/name-width 20)
;;       (setq sml/mode-width 'full)
;;       (setq sml/shorten-directory t)
;;       (setq sml/shorten-modes t)
;;
;;       (rich-minority-mode 1)
;; ;;      (setq rm-blacklist '(" GitGutter" " MRev" " company" " mate" " Projectile"))
;;
;;       (if after-init-time
;;         (sml/setup)
;;         (add-hook 'after-init-hook 'sml/setup))))
;;
      ;; Alternatives:
      ;; (sml/apply-theme 'powerline)
      ;; (sml/apply-theme 'dark)
      ;; (sml/apply-theme 'light)
      ;; (sml/apply-theme 'respectful)
      ;; (sml/apply-theme 'automatic)

;;      (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/" ":DB:"))
;;      (add-to-list 'sml/replacer-regexp-list '("^~/Code/" ":CODE:"))
;;      (add-to-list 'sml/replacer-regexp-list '("^:CODE:investor-bridge" ":IB:"))
;;      (add-to-list 'sml/replacer-regexp-list '("^~/.*/lib/ruby/gems" ":GEMS" ))))
#+end_src

*** Stata
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'load-path "/home/dgm/.emacs.d/src/ado-mode-1.15.1.4/lisp")
(require 'ado-mode)
#+END_SRC

#+RESULTS:
: ado-mode

*** Which-key
This mode shows a keymap when an incomplete command is entered. It is especially useful for families of commands with a prefix, e.g., =C-c C-o= for outline-mode commands, or ==C-c C-v= for org-babel commands. Just start ktyping your command and pause if you want a hint.

tip from: https://github.com/izahn/dotemacs

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package which-key)
(which-key-mode)
#+END_SRC

*** General REPL (comint) config
Tip from: https://github.com/izahn/dotemacs

Many programs using REPLs are derived from comint-mode, so we can affect all of them by changing comint-mode settings. Here we disable line wrapping and ask programs to echo the input.

Load eval-in-repl for bash, elisp, and python interaction.

#+BEGIN_SRC emacs-lisp :tangle yes
;; require the main file containing common functions
(use-package eval-in-repl
  :ensure t
  :config 
  (setq comint-process-echoes t)
  ;; truncate lines in comint buffers
  (add-hook 'comint-mode-hook
            (lambda()
              (setq truncate-lines 1)))
  ;; Scroll down for input and output
  (setq comint-scroll-to-bottom-on-input t)
  (setq comint-scroll-to-bottom-on-output t)
  (setq comint-move-point-for-output t))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23547 54059 64969 29000) :init (23547 54059 64933 102000) :config (23547 54059 64322 241000) :config-secs (0 0 1142 991000) :init-secs (0 0 2390 167000) :use-package-secs (0 0 2547 628000)))

*** Comint fix

From: https://www.emacswiki.org/emacs/ComintMode

Comint mode is a package that defines a general command-interpreter-in-a-buffer. The idea is that you can build specific process-in-a-buffer modes on top of comint mode – e.g., lisp, shell, scheme, T, soar, …. This way, all these specific packages share a common base functionality, and a common set of bindings, which makes them easier to use (and saves code, implementation time, etc., etc.).

When closing many processes, from shell to racket, I get a comint error like this:

#+BEGIN_EXAMPLE
Debugger entered--Lisp error: (wrong-type-argument processp nil)
  process-mark(nil)
  ansi-color-process-output("")
  run-hook-with-args(ansi-color-process-output "")
  comint-send-input()
  funcall-interactively(comint-send-input)
  call-interactively(comint-send-input nil nil)
  command-execute(comint-send-input)
#+END_EXAMPLE

I'm trying to fix this.

First tip from https://www.reddit.com/r/emacs/comments/8y144a/avoid_accidental_execution_in_comint_mode/

#+BEGIN_SRC emacs-lisp :tangle yes
(setq comint-get-old-input (lambda () (end-of-buffer) (comint-get-old-input-default)))
#+END_SRC

#+RESULTS:
| lambda | nil | (end-of-buffer) | (comint-get-old-input-default) |

**** Trying to avoid the error about "ansi-color-process-output("")"

For =(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)= to have an effect, =ansi-color-process-output= must be in =comint-output-filter-functions=. If not, use the following line to add it.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
#+END_SRC

#+RESULTS:
| ansi-color-process-output | comint-postoutput-scroll-to-bottom | comint-watch-for-password-prompt |


*** COMMENT shx

Commented out in an attempt to speed up evaluation in R and Stata... and BINGO!!! this was the little motherfucker that made R and Stata super slow interactively. It also caused an error on exit.

Enhance comint-mode. See https://github.com/riscy/shx-for-emacsl

#+BEGIN_SRC emacs-lisp :tangle no
(use-package shx            
  :ensure t
  :init (shx-global-mode 1))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23563 38338 822346 339000) :init (23563 38338 822317 934000) :config (23563 38338 821844 459000) :config-secs (0 0 13 374000) :init-secs (0 0 2171 786000) :use-package-secs (0 0 2344 520000)))

Alternativa from https://github.com/malb/emacs.d/blob/master/malb.org

#+BEGIN_SRC emacs-lisp :tangle no
(use-package shx
  :after comint
  :config (progn
            ;;(with-eval-after-load 'python
            ;;  (add-hook 'inferior-python-mode-hook #'shx-mode))
            ;; (with-eval-after-load 'sage-shell-mode
            ;;   (add-hook 'sage-shell-mode-hook #'shx-mode))
            (with-eval-after-load 'shell
              (add-hook 'shell-mode-hook #'shx-mode)))
            ;; from https://github.com/riscy/shx-for-emacs
           (setq
             ;; vastly improve display performance by breaking up long output lines
             shx-max-output 1024
             ;; prevent input longer than macOS's typeahead buffer from going through
             shx-max-input 1024
             ;; prefer inlined images to have a height of 250 pixels
             shx-img-height 250
             ;; don't show any incidental hint messages about how to use shx
             shx-show-hints nil
             ;; flash the previous comint prompt for a full second when using C-c C-p
             shx-flash-prompt-time 1.0
             ;; use `#' to prefix shx commands instead of the default `:'
             shx-leader "#"))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23563 39460 592701 842000) :init (23563 39460 592655 127000) :config (23563 39460 592361 613000) :config-secs (0 0 651 835000) :init-secs (0 0 1187 492000) :use-package-secs (0 0 1286 219000)))

*** Run R in emacs (ESS)
Tip from: https://github.com/izahn/dotemacs

Support for R in Emacs is good, thanks to http://ess.r-project.org/. As with other programming languages this configuration enables completion via the tab key and code evaluation with C-ret. Many more features are provided by ESS, refer to http://ess.r-project.org/ for details.

#+begin_src emacs-lisp :tangle yes
  ;;;  ESS (Emacs Speaks Statistics)

;; ;; Start R in the working directory by default
;; (setq ess-ask-for-ess-directory nil)
;;
;; ;; Make sure ESS is loaded before we configure it
;; (autoload 'julia "ess-julia" "Start a Julia REPL." t)
;; (with-eval-after-load "ess-site"
;;   ;; disable ehoing input
;;   (setq ess-eval-visibly nil)
;;   ;; Start R in the working directory by default
;;   (setq ess-ask-for-ess-directory nil)
;;   ;; Use tab completion
;;   (setq ess-tab-complete-in-script t)
;;   ;; extra ESS stuff inspired by https://github.com/gaborcsardi/dot-emacs/blob/master/.emacs
;;   (ess-toggle-underscore nil)
;;   (defun my-ess-execute-screen-options (foo)
;;     "cycle through windows whose major mode is inferior-ess-mode and fix width"
;;     (interactive)
;;     (setq my-windows-list (window-list))
;;     (while my-windows-list
;;       (when (with-selected-window (car my-windows-list) (string= "inferior-ess-mode" ;; major-mode))
;;         (with-selected-window (car my-windows-list) (ess-execute-screen-options t)))
;;       (setq my-windows-list (cdr my-windows-list))))
;;   (add-to-list 'window-size-change-functions 'my-ess-execute-screen-options)
;;   (define-key ess-mode-map (kbd "<C-return>") ;; 'ess-eval-region-or-function-or-paragraph-and-step)
;;   ;; truncate long lines in R source files
;;   (add-hook 'ess-mode-hook
;;             (lambda()
;;               ;; don't wrap long lines
;;               (toggle-truncate-lines t)
;;               (outline-minor-mode t))))
#+end_src

Note: for me "C-return" does not work... Comento todo esto porque me temo que entra en conflicto con la costumization del gran Kieran Healy en =starter-kit-stats.org= donde veo que la evaluación está bound a =shift-return= and that works indeed for me.

*** emacs lisp REPL (ielm)
Tip from: https://github.com/izahn/dotemacs

If you want to get the most out of Emacs, you’ll eventually need to learn a little Emacs-lisp. This configuration helps by providing a standard C-ret evaluation key binding, and by providing completion with the tab key.

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load "elisp-mode"
  (require 'company-elisp)
  ;; ielm
  (require 'eval-in-repl-ielm)
  ;; For .el files
  (define-key emacs-lisp-mode-map "C-c C-c" 'eir-eval-in-ielm)
  (define-key emacs-lisp-mode-map (kbd "<C-return>") 'eir-eval-in-ielm)
  ;; For *scratch*
  (define-key lisp-interaction-mode-map "C-c C-c" 'eir-eval-in-ielm)
  (define-key emacs-lisp-mode-map (kbd "<C-return>") 'eir-eval-in-ielm)
  ;; For M-x info
  (define-key Info-mode-map "C-c C-c" 'eir-eval-in-ielm)
  ;; Set up completions
  (add-hook 'emacs-lisp-mode-hook
            (lambda()
              ;; make sure completion calls company-elisp first
              (require 'company-elisp)
              (setq-local company-backends
                          (delete-dups (cons 'company-elisp (cons 'company-files company-backends)))))))
#+end_src

#+RESULTS:
| (lambda nil (require 'company-elisp) (setq-local company-backends (delete-dups (cons 'company-elisp (cons 'company-files company-backends))))) | esk-remove-elc-on-save | run-starter-kit-coding-hook | turn-on-eldoc-mode |

*** Demonstration tools (command-log-mode)

Tip from: https://github.com/izahn/dotemacs

=command-log-mode= is useful for giving emacs demonstrations/tutorials. It shows the keys you’ve pressed and the commands they called.

#+begin_src emacs-lisp :tangle yes
;;(setq command-log-mode-auto-show t)
;;(global-set-key (kbd "\C-x c l") 'global-command-log-mode)
#+end_src

#+RESULTS:
: global-command-log-mode

Good idea but it seems that I don't have the =command-log-mode=... ah, it's a package. i will install in future.

*** auto-complete
Following Drew advice on setting up emacs as a Python IDE (https://www.youtube.com/watch?v=6BlTGPsjGJk).

Gives basic auto completion for most programming modes. But doesn't know syntax. However, it has a nice interface for other packages providing completions like =jedi=.

For now I comment it out because following Drew's advice has meant that I've lost auto completion in elpy mode.

#+begin_src emacs-lisp :tangle yes
;; (require 'auto-complete-config)
;; (ac-config-default)

;; if you really like the menu
;;(setq ac-show-menu-immediately-on-auto-complete t)
#+end_src

#+RESULTS:
: t

** Other stuff from Tuhdo
- Stuff from http://tuhdo.github.io/emacs-tutor3.html

*** New beginning of line
Sometimes, we want to adjust or improve the behaviours of some commands in certain contexts. Consider this situation: C-a, which runs move-beginning-of-line, always move to the beginning of line. However, sometimes we don't always to move to the beginning of line, but move to the first non-whitespace character of that line.

See http://tuhdo.github.io/emacs-tutor3.html

#+BEGIN_SRC emacs-lisp :tangle yes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Customized functions                ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun prelude-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first. If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key (kbd "\C-a") 'prelude-move-beginning-of-line)
#+END_SRC

#+RESULTS:
: prelude-move-beginning-of-line

*** Recent files.

Info from  https://www.emacswiki.org/emacs/RecentFiles

Recentf is a minor mode that builds a list of recently opened files. This list is is automatically saved across sessions on exiting Emacs - you can then access this list through a command or the menu.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package recentf
  :ensure t)

(recentf-mode 1)
(setq recentf-max-menu-items 25)
(setq recentf-max-saved-items 25)
(global-set-key "\C-x\ \C-r" 'recentf-open-files)
(setq recentf-auto-cleanup 'never)
#+END_SRC

#+RESULTS:
: never

By default, Recentf saves the list of recent files on exiting Emacs (specifically, `recentf-save-list` is called on `kill-emacs-hook`). If Emacs exits abruptly for some reason the recent file list will be lost - therefore you may wish to call `recentf-save-list` periodically, e.g. every 5 minutes:
(DGM disables it because I find it too invasive)

#+BEGIN_SRC emacs-lisp :tangle no
;; (run-at-time nil (* 5 60) 'recentf-save-list)
#+END_SRC

#+RESULTS:

*** recentf-ext    

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package recentf-ext
  :ensure t)
#+END_SRC

*** ztree 

Since ztree works with files and directories, let's consider it in group Files

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ztree)
;;(use-package ztree-diff)
;;(use-package ztree-dir)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23561 15887 36543 611000) :init (23561 15887 36504 265000) :config (23561 15887 36024 575000) :config-secs (0 0 20 788000) :init-secs (0 0 911 118000) :use-package-secs (0 0 1056 805000)))

*** rebox2

Ojo: solo funciona si se llama M-x rebox-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rebox2)
(global-set-key [(meta q)] 'rebox-dwin-fill)
(global-set-key [(shift meta q)] 'rebox-dwin-no-fill)
#+END_SRC

*** helpful 

https://github.com/Wilfred/helpful

Note that the built-in `describe-function' includes both functions and macros. `helpful-function' is functions only, so we provide `helpful-callable' as a drop-in replacement.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helpful)

(global-set-key (kbd "\C-h f") #'helpful-callable)
(global-set-key (kbd "\C-h v") #'helpful-variable)
(global-set-key (kbd "\C-h k") #'helpful-key)
#+END_SRC

*** Lookup 

**** Lookup the current symbol at point. 

C-c C-d is a common keybinding for this in lisp modes.

#+BEGIN_SRC emacs-lisp :tangle no
(global-set-key (kbd "\C-s d") #'helpful-at-point)
#+END_SRC

**** Look up *F*unctions (excludes macros). 

By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
already links to the manual, if a function is referenced there.

#+BEGIN_SRC emacs-lisp :tangle no
(global-set-key (kbd "\C-s-f") #'helpful-function)
#+END_SRC

**** Look up *C*ommands. 

By default, C-h C is bound to describe `describe-coding-system'. I
don't find this very useful, but it's frequently useful to only
look at interactive functions.

#+BEGIN_SRC emacs-lisp :tangle no
(global-set-key (kbd "\C-s-c") #'helpful-command)
#+END_SRC

*** Peek definition with Emacs frame
- Stuff from http://tuhdo.github.io/emacs-frame-peek.html
- So far I have not made it work in this =dgm.org= file but maybe it works with other programming languages.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun rtags-peek-definition ()
  "Peek at definition at point using rtags."
  (interactive)
  (let ((func (lambda ()
                (rtags-find-symbol-at-point)
                (rtags-location-stack-forward))))
    (rtags-start-process-unless-running)
    (make-peek-frame func)))

(defun make-peek-frame (find-definition-function &rest args)
  "Make a new frame for peeking definition"
  (when (or (not (rtags-called-interactively-p)) (rtags-sandbox-id-matches))
    (let (summary
          doc-frame
          x y
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ;; 1. Find the absolute position of the current beginning of the symbol at point, ;;
          ;; in pixels.                                                                     ;;
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          (abs-pixel-pos (save-excursion
                           (beginning-of-thing 'symbol)
                           (window-absolute-pixel-position))))
      (setq x (car abs-pixel-pos))
      ;; (setq y (cdr abs-pixel-pos))
      (setq y (+ (cdr abs-pixel-pos) (frame-char-height)))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 2. Create a new invisible frame, with the current buffer in it. ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (setq doc-frame (make-frame '((minibuffer . nil)
                                    (name . "*RTags Peek*")
                                    (width . 80)
                                    (visibility . nil)
                                    (height . 15))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 3. Position the new frame right under the beginning of the symbol at point. ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (set-frame-position doc-frame x y)

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 4. Jump to the symbol at point. ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (with-selected-frame doc-frame
        (apply find-definition-function args)
        (read-only-mode)
        (when semantic-stickyfunc-mode (semantic-stickyfunc-mode -1))
        (recenter-top-bottom 0))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 5. Make frame visible again ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (make-frame-visible doc-frame))))

(global-set-key (kbd "M-s-p") 'rtags-peek-definition)
#+END_SRC

#+RESULTS:
: rtags-peek-definition

*** COMMENT eyebrowse configuration

Idea from http://pragmaticemacs.com/emacs/easily-manage-emacs-workspaces-with-eyebrowse/ but for some reason when I activate this bit of code, my configuration file does not work and everything fails.

I have commented this out because with =exwm= I think I don't need =eyebrowse= anymore.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package eyebrowse
  :ensure t
  :defer 1
  :init
  (setq eyebrowse-keymap-prefix (kbd "C-c z"))
  (global-unset-key (kbd "C-c C-w"))
  :diminish eyebrowse-mode
  :config (progn
            (define-key eyebrowse-mode-map (kbd "s-1") 'eyebrowse-switch-to-window-config-1)
            (define-key eyebrowse-mode-map (kbd "s-2") 'eyebrowse-switch-to-window-config-2)
            (define-key eyebrowse-mode-map (kbd "s-3") 'eyebrowse-switch-to-window-config-3)
            (define-key eyebrowse-mode-map (kbd "s-4") 'eyebrowse-switch-to-window-config-4)
            (define-key eyebrowse-mode-map (kbd "s-5") 'eyebrowse-switch-to-window-config-5)
            (define-key eyebrowse-mode-map (kbd "s-6") 'eyebrowse-switch-to-window-config-6)
            (define-key eyebrowse-mode-map (kbd "s-7") 'eyebrowse-switch-to-window-config-7)
            (define-key eyebrowse-mode-map (kbd "s-8") 'eyebrowse-switch-to-window-config-8)
            (define-key eyebrowse-mode-map (kbd "s-9") 'eyebrowse-switch-to-window-config-9)
            (define-key eyebrowse-mode-map (kbd "s-<") 'eyebrowse-prev-window-config)
            (define-key eyebrowse-mode-map (kbd "s->") 'eyebrowse-next-window-config)
            (eyebrowse-mode t)
            (setq eyebrowse-new-workspace t)))
#+END_SRC

#+RESULTS:
: t


So I'll try with this new code:

#+BEGIN_SRC emacs-lisp :tangle no
;;            (eyebrowse-mode t)
;;            (global-set-key (kbd "s-1") 'eyebrowse-switch-to-window-config-1)
;;            (global-set-key (kbd "s-2") 'eyebrowse-switch-to-window-config-2)
;;            (global-set-key (kbd "s-3") 'eyebrowse-switch-to-window-config-3)
;;            (global-set-key (kbd "s-4") 'eyebrowse-switch-to-window-config-4)
;;            (global-set-key (kbd "s-5") 'eyebrowse-switch-to-window-config-5)
;;            (global-set-key (kbd "s-6") 'eyebrowse-switch-to-window-config-6)
;;            (global-set-key (kbd "s-7") 'eyebrowse-switch-to-window-config-7)
;;            (global-set-key (kbd "s-8") 'eyebrowse-switch-to-window-config-8)
;;            (global-set-key (kbd "s-9") 'eyebrowse-switch-to-window-config-9)
;;            (setq eyebrowse-new-workspace t)
#+END_SRC

#+RESULTS:

But again, if I activate this bit of code, when I open emacs most of this file is not processed and I don't have my goodies running (helm, etc). However, if after I open emacs I run this code, then the code and all the rest works... why?

MISTERIO RESUELTO: cuando use' yasnippet para crear el snippet con elisp, me lo dio con begin_src y end_src en minusculas y esto es lo que causaba el caos (tambien pone lo del tangle yes o no pero creo que eso no es problema.)

*** COMMENT C  and C++ support.

- Tips from http://tuhdo.github.io/c-ide.html

Tuhdo tells how to install GNU Global and then the package =ggtags= from Melpa. 
I'm not sure if including this package in the =elpa.org= file will get this =ggtags= package or another with the same name but not from Melpa.

#+begin_src emacs-lisp :tangle no
;; sudo apt-get install global
#+end_src

** Magit

https://magit.vc/manual/magit.html#Installation

Key binding to get the Magit menu

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :ensure t
  :defer t
  :bind (("C-x g" . magit-status) 
         ("C-x M-l" . magit-log-buffer-file)
         ("C-x M-b" . magit-blame)))

(global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
#+END_SRC

#+RESULTS:
: magit-dispatch-popup

The following code makes magit-status run alone in the frame, and then restores the old window configuration when you quit out of magit.

No more juggling windows after commiting. It’s magit bliss.

Source: Magnar Sveen

#+BEGIN_SRC emacs-lisp :tangle yes
;; full screen magit-status
(defadvice magit-status (around magit-fullscreen activate)
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))
#+END_SRC

#+RESULTS:
: magit-quit-session

**** Edit With Emacs
Editing input boxes from Chrome with Emacs. Pretty useful to keep all significant text-writing on the web within emacs. I typically use this with posts on Discourse, which has a post editor that overrides normal Emacs key bindings with other functions. As such, markdown-mode is used (dgm comments this out to have the default text mode operative.)

Para usarlo creo que es necesario instalar la extension "edit with emacs" en la chrome web store. This extension has the following information:

Allow user to edit web-page textareas with Emacs (and other editors).  Edit with Emacs is an extension for Google's Chrome(ium) browser family
that allows you to edit text areas on your browser in a more full featured editor. It does this in conjunction with an "Edit Server" which services requests by the browser. This is because extensions cannot spawn new processes as a security measure.  For this reason and for the Chromium extension to work, you need to be running an "edit server" on your local machine. For emacs users it is recommended that you use the supplied native =edit-server.el=. 

The extension packages native elisp version that can be run inside GNU Emacs itself, just follow the instructions from the options page of the extension. It has been known to work with GNU Emacs and Aquamacs (MacOS); it is presently not compatible with XEmacs.

Other example edit servers can be found at the project homepage. There is no reason why other server scripts could not spawn other editors and currently a number of servers support the simple URL based protocol.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package edit-server
  :ensure t
  :config
   (when (locate-library "edit-server")
     (require 'edit-server)
     (setq edit-server-new-frame nil)
     (edit-server-start)))
;;  (setq edit-server-default-major-mode 'markdown-mode)
;;(setq edit-server-new-frame nil))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23563 43807 378915 313000) :init (23563 43807 378870 661000) :config (23563 43807 378554 538000) :config-secs (0 0 3329 984000) :init-secs (0 0 4027 761000) :use-package-secs (0 0 4264 968000)))

Not working for me. So I try =atomic-chrome= (see https://github.com/alpha22jp/atomic-chrome and https://www.reddit.com/r/emacs/comments/8jb4p5/editing_html_textareas_with_emacs_bye_bye_its_all/)

#+BEGIN_SRC emacs-lisp :tangle yes
 (use-package atomic-chrome
   :ensure t
   :custom
   (atomic-chrome-url-major-mode-alist
    '(("reddit\\.com" . markdown-mode)
      ;;("github\\.com" . gfm-mode)
      ("uned\\.es" . text-mode))
    "Major modes for URLs.")
   :config
   (atomic-chrome-start-server))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23564 17693 843954 826000) :init (23564 17693 843942 387000) :config (23564 17693 843735 478000) :config-secs (0 0 1721 187000) :init-secs (0 0 2112 456000) :use-package-secs (0 0 2188 501000)))

And this one works!!

Other options here: 
https://emacsnotes.wordpress.com/2018/05/14/editing-html-textareas-with-emacs-bye-bye-its-all-text-hello-textern/
(emacs_chrome, GhostText, It's All Text!, Textern, withExEditor.)

*** Make sure time stamps are in English

Tip from: https://stackoverflow.com/questions/28913294/emacs-org-mode-language-of-time-stamps

#+BEGIN_SRC emacs-lisp :tangle yes
;; System locale to use for formatting time values.
(setq system-time-locale "C")         ; Make sure that the weekdays in the
                                      ; time stamps of your Org mode files and
                                      ; in the agenda appear in English.
#+END_SRC

#+RESULTS:
: C

** Key bindings

#+BEGIN_SRC emacs-lisp :tangle yes
;;    (define-key global-map [?\s-u] 'undo)
;;    (define-key global-map [?\s-j] 'save-buffer)
;;    (define-key global-map [?\s-q] 'move-beginning-of-line)
;;    (define-key global-map [?\s-e] 'move-end-of-line)
;;    (define-key global-map [?\s-k] 'kill-buffer)
#+END_SRC

#+RESULTS:
: kill-buffer
** Harry R. Schwartz  stuff
- Taken from https://github.com/hrs/dotfiles/blob/master/emacs/.emacs.d/configuration.org
*** Rename file

#+begin_src emacs-lisp :tangle yes
(defun hrs/rename-file (new-name)
  (interactive "FNew name: ")
  (let ((filename (buffer-file-name)))
    (if filename
        (progn
          (when (buffer-modified-p)
             (save-buffer))
          (rename-file filename new-name t)
          (kill-buffer (current-buffer))
          (find-file new-name)
          (message "Renamed '%s' -> '%s'" filename new-name))
      (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))
#+end_src

#+RESULTS:
: hrs/rename-file

*** Generate scratch buffer
Rendered obsolete by =scratch= package? Not really because the scratch package forces the scratch buffer to be of the same mode as the current one.

#+begin_src emacs-lisp :tangle yes
(defun hrs/generate-scratch-buffer ()
  "Create and switch to a temporary scratch buffer with a random
     name."
  (interactive)
  (switch-to-buffer (make-temp-name "scratch-")))
#+end_src

#+RESULTS:
: hrs/generate-scratch-buffer

*** Visit last dired buffer

#+begin_src emacs-lisp :tangle yes
(defun hrs/visit-last-dired-file ()
  "Open the last file in an open dired buffer."
  (interactive)
  (end-of-buffer)
  (previous-line)
  (dired-find-file))
#+end_src

#+RESULTS:
: hrs/visit-last-dired-file

*** COMMENT Change window configuration

Tip from https://stackoverflow.com/questions/14881020/emacs-shortcut-to-switch-from-a-horizontal-split-to-a-vertical-split-in-one-move

Commented out because I am using =exwm= now.

#+BEGIN_SRC emacs-lisp :tangle no
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
         (next-win-buffer (window-buffer (next-window)))
         (this-win-edges (window-edges (selected-window)))
         (next-win-edges (window-edges (next-window)))
         (this-win-2nd (not (and (<= (car this-win-edges)
                     (car next-win-edges))
                     (<= (cadr this-win-edges)
                     (cadr next-win-edges)))))
         (splitter
          (if (= (car this-win-edges)
             (car (window-edges (next-window))))
          'split-window-horizontally
        'split-window-vertically)))
    (delete-other-windows)
    (let ((first-win (selected-window)))
      (funcall splitter)
      (if this-win-2nd (other-window 1))
      (set-window-buffer (selected-window) this-win-buffer)
      (set-window-buffer (next-window) next-win-buffer)
      (select-window first-win)
      (if this-win-2nd (other-window 1))))))

(global-set-key (kbd "s-c") 'toggle-window-split)
#+END_SRC

#+RESULTS:
: toggle-window-split

*** Yasnippet for R
See https://github.com/mattfidler/r-autoyas.el

#+begin_src emacs-lisp :tangle yes
;; (require 'r-autoyas)
;; (add-hook 'ess-mode-hook 'r-autoyas-ess-activate)
#+end_src

#+RESULTS:

*** Org customization
How do I change my dotfile so that when I call org-agenda it takes up the entire screen?
https://stackoverflow.com/questions/36873727/make-org-agenda-full-screen

#+BEGIN_SRC emacs-lisp :tangle yes
;; (setq org-agenda-window-setup 'only-window)
;; (setq org-export-dispatch 'only-window)
#+END_SRC

#+RESULTS:
: only-window

*** How to control in which window a buffer is displayed?

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-window-displaying-agenda-p (window)
    (equal (with-current-buffer (window-buffer window) major-mode)
        'org-agenda-mode)) 

(defun my-position-calendar-buffer (buffer alist)
  (let ((agenda-window (car (remove-if-not #'my-window-displaying-agenda-p (window-list)))))
    (when agenda-window
      (let ((desired-window (split-window agenda-window nil 'below)))
        (set-window-buffer desired-window  buffer)
        desired-window))))

(add-to-list 'display-buffer-alist (cons "\\*Calendar\\*" (cons #'my-position-calendar-buffer nil)))
#+END_SRC

#+RESULTS:
| \*Calendar\* | my-position-calendar-buffer |

From my question in https://emacs.stackexchange.com/questions/45650/in-org-mode-what-variable-controls-the-placement-of-the-calendar-view-when-call/45653#45653

The following will make the Calendar to use a window below the selected window

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'display-buffer-alist
             `(,(rx string-start "*Calendar*" string-end)
               (display-buffer-below-selected)))
#+END_SRC

** Ambrevar's stuff

From his =main.el=

#+BEGIN_SRC emacs-lisp :tangle yes
;;; Save M-: history.
(savehist-mode)

;;; Enforce horizontal splitting. 140 means that the window is large enough to
;;; hold 2 other windows of 70 columns.
(setq split-height-threshold nil
      split-width-threshold 140)

;;; Show matching parenthesis
(show-paren-mode 1)
;;; By default, there’s a small delay before showing a matching parenthesis. Set
;;; it to 0 to deactivate.
(setq show-paren-delay 0)
(setq show-paren-when-point-inside-paren t)

;;; Replace `kill-buffer' binding by `kill-this-buffer'.
(global-set-key (kbd "C-x k") 'kill-this-buffer)

;;; Initial scratch buffer message.
;; commented out as it was too distracting
;;(require 'functions) ; For `ambrevar/fortune-scratch-message'.
;;(let ((fortune (ambrevar/fortune-scratch-message)))
;;  (when fortune
;;    (setq initial-scratch-message fortune)))

;;; Save all visited URLs.
(setq url-history-track t
      url-history-file (expand-file-name "url/history" user-emacs-directory))
#+END_SRC

#+RESULTS:
: /home/dgm/.emacs.d/url/history

** =dired= do what I mean
- Tip from
https://emacs.stackexchange.com/questions/5603/how-to-quickly-copy-move-file-in-emacs-dired

#+BEGIN_SRC emacs-lisp :tangle yes
 (setq dired-dwim-target t)
#+END_SRC

#+RESULTS:
: t

** gpastel

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package gpastel
    :ensure t
    :config 
   (gpastel-start-listening))
#+END_SRC

#+RESULTS:
: t

** Customize =emacsclient=

#+BEGIN_SRC emacs-lisp :tangle yes
(setq default-frame-alist '((font . "Pragmata Pro Mono-16")))
(add-to-list 'default-frame-alist '(line-spacing . 0.06))
#+END_SRC

#+RESULTS:
: ((line-spacing . 0.06) (font . Pragmata Pro Mono-16))
 
** COMMENT =qutebrowser=
Originally from https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org with qutebrowser, but too unstable. Changed to chromium

DGM on 29 dic 2018: this is set in =starter-kit-misc.org=
#+BEGIN_SRC emacs-lisp :tangle no
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "chromium")
;      browse-url-generic-program "qutebrowser")
#+END_SRC

#+RESULTS:
: qutebrowser

** Tell emacs where =fortune= is
From 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package fortune)
(setq fortune-dir "/usr/share/games/fortunes"
      fortune-file "/usr/share/games/fortunes/fortunes")
#+END_SRC

** Better defaults

By the great Technomancy. 

Situation with =uniquify= solved here: https://github.com/jwiegley/use-package/issues/320

Uniquify buffer names is useful for when you have buffers with many similar names, as when there are various open files from different folders named =analysis.R= or similar. 

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'uniquify)
(setq ;;(setq uniquify-buffer-name-style 'reverse)
      ;; (setq uniquify-buffer-name-style 'forward) ;; technomancy's default
      ;;(setq uniquify-separator "|")
      uniquify-after-kill-buffer-p t
      uniquify-buffer-name-style 'post-forward-angle-brackets)  ;; default in kieran healy's config
   ;;(setq uniquify-ignore-buffers-re "^*")
#+END_SRC  

#+RESULTS:
: post-forward-angle-brackets

bbatov setup is like this (https://github.com/bbatsov/emacs.d/blob/master/init.el)

#+BEGIN_SRC emacs-lisp :tangle no
;; (use-package uniquify
;;  :config
;;  (setq uniquify-buffer-name-style 'forward)
;;  (setq uniquify-separator "/")
;;  ;; rename after killing uniquified
;;  (setq uniquify-after-kill-buffer-p t)
;;  ;; don't muck with special buffers
;; (setq uniquify-ignore-buffers-re "^\\*"))
#+END_SRC


Other stuff from Technomancy's better defaults

#+BEGIN_SRC emacs-lisp :tangle yes
(autoload 'zap-up-to-char "misc"
    "Kill up to, but not including ARGth occurrence of CHAR." t)
(global-set-key (kbd "M-z") 'zap-up-to-char)

(setq apropos-do-all t
      mouse-yank-at-point t)
#+END_SRC

#+RESULTS:
: t

** Caolan's stuff
From https://caolan.org/dotfiles/emacs.html#orgd96aeb0

*** Ediff
Some tips taken from the post Setting up Ediff.

Don't use the weird setup with a control panel in a separate frame, use a normal Emacs window instead.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

Split the windows horizontally instead of vertically as I find it easier to follow.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq ediff-split-window-function 'split-window-horizontally)
#+END_SRC

Restore the windows after Ediff quits. By default, when you quit the Ediff session with =q=, it just leaves the two diff windows around, instead of restoring the window configuration from when Ediff was started.

#+BEGIN_SRC emacs-lisp :tangle yes
;;(winner-mode)
;;(add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC

(Above code in =starter-kit-binding.org=)

Don't wait 3 seconds then ask about closing the merge buffer, just close it!

#+BEGIN_SRC emacs-lisp :tangle yes
;; write merge buffer.  If the optional argument save-and-continue is non-nil,
;; then don't kill the merge buffer
(defun caolan/ediff-write-merge-buffer-and-maybe-kill (buf file
                                                           &optional
                                                           show-file save-and-continue)
  (if (not (eq (find-buffer-visiting file) buf))
      (let ((warn-message
             (format "Another buffer is visiting file %s. Too dangerous to save the merge buffer"
                     file)))
        (beep)
        (message "%s" warn-message)
        (with-output-to-temp-buffer ediff-msg-buffer
          (princ "\n\n")
          (princ warn-message)
          (princ "\n\n")
          )
        (sit-for 2))
    (ediff-with-current-buffer buf
      (if (or (not (file-exists-p file))
              (y-or-n-p (format "File %s exists, overwrite? " file)))
          (progn
            ;;(write-region nil nil file)
            (ediff-with-current-buffer buf
              (set-visited-file-name file)
              (save-buffer))
            (if show-file
                (progn
                  (message "Merge buffer saved in: %s" file)
                  (set-buffer-modified-p nil)))
            (if (and (not save-and-continue))
                (ediff-kill-buffer-carefully buf)))))
    ))

(defun caolan/ediff-maybe-save-and-delete-merge (&optional save-and-continue)
  "Default hook to run on quitting a merge job.
This can also be used to save merge buffer in the middle of an Ediff session.

If the optional SAVE-AND-CONTINUE argument is non-nil, save merge buffer and
continue.  Otherwise:
If `ediff-autostore-merges' is nil, this does nothing.
If it is t, it saves the merge buffer in the file `ediff-merge-store-file'
or asks the user, if the latter is nil.  It then asks the user whether to
delete the merge buffer.
If `ediff-autostore-merges' is neither nil nor t, the merge buffer is saved
only if this merge job is part of a group, i.e., was invoked from within
`ediff-merge-directories', `ediff-merge-directory-revisions', and such."
  (let ((merge-store-file ediff-merge-store-file)
        (ediff-autostore-merges ; fake ediff-autostore-merges, if necessary
         (if save-and-continue t ediff-autostore-merges)))
    (if ediff-autostore-merges
        (cond ((stringp merge-store-file)
               ;; store, ask to delete
               (caolan/ediff-write-merge-buffer-and-maybe-kill
                ediff-buffer-C merge-store-file 'show-file save-and-continue))
              ((eq ediff-autostore-merges t)
               ;; ask for file name
               (setq merge-store-file
                     (read-file-name "Save the result of the merge in file: "))
               (caolan/ediff-write-merge-buffer-and-maybe-kill
                ediff-buffer-C merge-store-file nil save-and-continue))
              ((and (ediff-buffer-live-p ediff-meta-buffer)
                    (ediff-with-current-buffer ediff-meta-buffer
                                               (ediff-merge-metajob)))
               ;; The parent metajob passed nil as the autostore file.
               nil)))
    ))

(add-hook 'ediff-quit-merge-hook #'caolan/ediff-maybe-save-and-delete-merge)
#+END_SRC

Fully expand Org files in Ediff (otherwise it's hard to see the changes between files). This tip taken from the Emacs Stackexchange, which also has an interesting solution to unfold/fold Org elements as Ediff selects/deselects changes, but I found just showing everything to work more reliably.

Note, show-all is marked obsolete in Emacs 25.1 in favor of outline-show-all. But the latter symbol is not bound in 24.5, and since I use Debian stable (Jessie) on my desktop which provides Emacs 24.4, I need to use the older show-all for now.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'ediff-prepare-buffer-hook #'outline-show-all)
#+END_SRC

#+RESULTS:
| outline-show-all |


*** Cut/copy/comment current line if no region selected
In many programs, like SlickEdit, TextMate and VisualStudio, "cut" and "copy" act on the current line if no text is visually selected. For this, I originally used code from Tim Krones Emacs config, but now I'm using the whole-line-or-region package, which can be customised to use the same line-or-region style for comments too. See comments in whole-line-or-region.el for details.

However, I disable it or else the copy/paste emacs bindings won't work in external apps PLUS uncle dave has defined handy functions to do the copying and killing on current words and lines.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package whole-line-or-region
  :ensure t)

(add-to-list 'whole-line-or-region-extensions-alist
             '(comment-dwim whole-line-or-region-comment-dwim nil))

(whole-line-or-region-global-mode 1)
#+END_SRC

#+RESULTS:
: t
*** Place cursor at beginning of search matches
From: http://www.emacswiki.org/emacs/IncrementalSearch#toc4. With this hook, both ‘C-g’ and ‘RET’ exit the search at the begining of the search string rather than the end. To get back to where you started the search, just use ‘C-x C-x’. This works because isearch sets the mark at the search start.

I (dgm) don't find a use case for it, so I disable it. 

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'isearch-mode-end-hook 'my-goto-match-beginning)

(defun my-goto-match-beginning ()
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end)))

(defadvice isearch-exit (after my-goto-match-beginning activate)
  "Go to beginning of match."
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end)))
#+END_SRC

#+RESULTS:
: isearch-exit

*** Environment variables
Set environment variable so running CHICKEN Scheme suites via the 'test' egg will display colour output.
#+BEGIN_SRC emacs-lisp :tangle yes
(setenv "TEST_USE_ANSI" "1")
#+END_SRC

#+RESULTS:
: 1

Add my home bin directory to PATH (when I have it) (check next section that is currently commented out because I'm using Purcell's package for setting the environment variables.)

#+BEGIN_SRC emacs-lisp :tangle no
(setenv "PATH" (concat "/home/dgm/bin:" (getenv "PATH")))
#+END_SRC

*** COMMENT Trying to get =M-x stata= working

Originally this got stata working when I called it interactively with =M-x stata=
#+BEGIN_SRC emacs-lisp :tangle no
;; (setenv "PATH" (concat "/usr/local/stata14:/usr/local/stata:" (getenv "PATH")))
;; (setenv "PATH" (concat (getenv "PATH") ":/usr/local/stata"))
;; (setq exec-path (append exec-path '("/usr/local/stata")))
#+END_SRC

#+RESULTS:

However, once I used the script sent from Stata Corp. to make stata work after updating it, this does not work. So I have changed it to:

#+BEGIN_SRC emacs-lisp :tangle no
;; (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin/stata"))
;; (setq exec-path (append exec-path '("/usr/local/bin/stata")))
#+END_SRC

#+RESULTS:

However, I've tangled it up to "no" because I think this is not needed now that I use Purcell's package =exec-path-from-shell=.

*** Flyspell and flycheck
When I start the shell I get a backtrace error related to not finding flyspell, so I get it here. The message is:

Debugger entered--Lisp error: (void-function flycheck-mode)
  flycheck-mode()
  run-hooks(change-major-mode-after-body-hook comint-mode-hook shell-mode-hook)
  apply(run-hooks (change-major-mode-after-body-hook comint-mode-hook shell-mode-hook))
  run-mode-hooks(shell-mode-hook)
  shell-mode()
  shell()
  (lambda nil (shell))()
  shell-pop--switch-to-shell-buffer(1)
  shell-pop-up(1)
  shell-pop(nil)
  funcall-interactively(shell-pop nil)
  call-interactively(shell-pop nil nil)
  command-execute(shell-pop)

Note =flyspell= is part of emacs so you don't need =use-package=.

UUUGGHHGGHGH: tangled to no. The message refers to flycheck-mode, not flyspell!!!

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'flyspell)
(setq flyspell-mode-on t)
#+END_SRC

#+RESULTS:
: t


Now, I follow https://github.com/flycheck/flycheck/blob/master/doc/user/installation.rst

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck)
;;  :ensure t)
;;  :init (global-flycheck-mode))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23562 65398 372429 797000) :init (23562 65398 372385 594000) :config (23562 65398 371859 359000) :config-secs (0 0 22 237000) :init-secs (0 0 962 713000) :use-package-secs (0 0 1171 921000)))

*** Shell pop-up terminal

Its window behavour is crazy, plus I can define an easy shortcut for popping a shell, so I don't see the point.

From http://pragmaticemacs.com/emacs/pop-up-a-quick-shell-with-shell-pop/. Opens a quick ANSI terminal in the directory of the currently open file.

Code originally by Caolan that made shell-pop a read-only buffer in https://caolan.org/dotfiles/emacs.html. But it had an erratic window behaviour. In the end, I kind of fixed it by using the code in https://www.emacswiki.org/emacs/ShellPop.
The only issue remaining is that the first time round I call shell-pop it splits the window wrongly. Afterwards, it does it alright.

NOTE: font-lock of the shell-prompt did not work until I bumped onto   https://emacs.stackexchange.com/questions/14876/how-can-i-make-ansi-color-codes-inside-the-prompt-show-up-in-shell-mode
and I added the bit of code here and 


~PS1="\[\e[00;32m\]\u\[\e[00m\]@\[\e[00;36m\]\h\[\e[00m\]:\[\e[00;34m\]\w\[\e[00m\]\n\$(printf \"[\[\e[01;31m\]%.*s\[\e[00m\]]\" \$? \$?) \$ "~


in =.bashrc=.

However, to actually get the colors, I followed  http://amitp.blogspot.com/2007/04/emacs-color-in-shell-buffers.html and his choice of colors

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package shell-pop
  :ensure t
  :bind ("<s-escape>" . shell-pop))

;;  (setq shell-pop-default-directory "/home/dgm")
  (setq shell-pop-set-internal-mode "shell")
  (setq shell-pop-set-internal-mode-shell "/bin/bash")
  (setq shell-pop-set-window-height 30) ;the number for the percentage of the selected window. if 100, shell-pop use the whole of selected window, not spliting.
  (setq shell-pop-set-window-position "bottom") ;shell-pop-up position. You can choose "top" or "bottom".

  ;; https://emacs.stackexchange.com/questions/14876/how-can-i-make-ansi-color-codes-inside-the-prompt-show-up-in-shell-mode
  (set-face-attribute 'comint-highlight-prompt nil
                      :inherit nil)

  ;;;;;;;;;;;;;;;;;;;;;; http://amitp.blogspot.com/2007/04/emacs-color-in-shell-buffers.html
  (setq ansi-color-names-vector ; better contrast colors
        ["black" "red4" "green4" "yellow4"
         "blue3" "magenta4" "cyan4" "white"])
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

  ;; (setq shell-pop-window-size 30)
  ;;(setq shell-pop-full-span t)
  ;;(setq shell-pop-window-position "bottom")
  ;;:config
  ;;(setq shell-pop-shell-type (quote ("shell" "*shell*" (lambda nil (shell shell-pop-term-shell)))))
  ;;(setq shell-pop-term-shell "/bin/bash")
  ;; need to do this manually or not picked up by `shell-pop'
  ;;(shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC

#+RESULTS:
| ansi-color-for-comint-mode-on | company-mode | flycheck-mode | yas-minor-mode | shell-mode-company-init | ess-r-package-activate-directory-tracker |

This next bit is from https://github.com/syl20bnr/spacemacs/issues/6820 to try and get the shell and IPython at the bottom of the screen 

#+BEGIN_SRC emacs-lisp :tangle yes
(push (cons "\\*shell\\*" display-buffer--same-window-action) display-buffer-alist)
(push (cons "\\*IPython3\\*" display-buffer--same-window-action) display-buffer-alist)
(push (cons "\\*IPython\\*" display-buffer--same-window-action) display-buffer-alist)
(push (cons "\\*stata\\*" display-buffer--same-window-action) display-buffer-alist)
#+END_SRC

#+RESULTS:
| \*stata\*        | display-buffer-same-window      | (inhibit-same-window) |
| \*IPython\*      | display-buffer-same-window      | (inhibit-same-window) |
| \*IPython3\*     | display-buffer-same-window      | (inhibit-same-window) |
| \*shell\*        | display-buffer-same-window      | (inhibit-same-window) |
| \*stata\*        | display-buffer-same-window      | (inhibit-same-window) |
| \*stata\*        | display-buffer-same-window      | (inhibit-same-window) |
| \*IPython\*      | display-buffer-same-window      | (inhibit-same-window) |
| \*IPython3\*     | display-buffer-same-window      | (inhibit-same-window) |
| \*shell\*        | display-buffer-same-window      | (inhibit-same-window) |
| \*stata\*        | display-buffer-same-window      | (inhibit-same-window) |
| \*IPython\*      | display-buffer-same-window      | (inhibit-same-window) |
| \*IPython3\*     | display-buffer-same-window      | (inhibit-same-window) |
| \*shell\*        | display-buffer-same-window      | (inhibit-same-window) |
| \`\*Calendar\*\' | (display-buffer-below-selected) |                       |
| \*Calendar\*     | my-position-calendar-buffer     |                       |

*** COMMENT Start a regular shell at the bottom.
#+begin_src emacs-lisp  :tangle no
;;(global-set-key (kbd "s--") 'shell)
#+end_src

#+RESULTS:
: shell

And open it at the bottom of current window


#+BEGIN_SRC emacs-lisp :tangle no
;; (add-to-list 'display-buffer-alist
;;              `(,(rx string-start "*shell*" string-end)
;;               (display-buffer-below-selected)))
#+END_SRC

#+RESULTS:
*** Using dumb-jump to jump to definitions
The dumb-jump package provides 'jump to definition' support for multiple languages by simply searching for possible definitions using The Silver Searcher ag, ripgrep rg, or grep. It does not require building stored indexes (TAGS) or background processes etc.

Enable dumb-jump-mode globally:

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dumb-jump
  :ensure t
  :init (lambda ()
          (dumb-jump-mode)))
#+END_SRC

#+RESULTS:

If The Silver Searcher is installed it will use it, otherwise it will revert back to =grep=.

*** EditorConfig plugin
Reads EditorConfig files to set coding style options according to current project.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+END_SRC

#+RESULTS:
: t

*** Thesaurus
Many of the thesaurus packages use an online service, synosaurus gives you the option of using a local Wordnet install. It also has a nice 'replace word' interface.

NOTE: this requires you to install wordnet

#+BEGIN_EXAMPLE
 sudo apt install wordnet
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package synosaurus
  :ensure t
  :config (progn
            (setq synosaurus-backend 'synosaurus-backend-wordnet)
            (setq synosaurus-choose-method 'default)))
#+END_SRC 

#+RESULTS:
: t

*** Dictionary
Since I already use a local Wordnet as a thesaurus, I'm using it for a dictionary as well via the wordnut package.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package wordnut
  :ensure t)
#+END_SRC

#+RESULTS:

*** Olivetti minor mode
A minor mode for a nice writing environment.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package olivetti
  :ensure t
  :config (setq olivetti-body-width 90))
#+END_SRC

#+RESULTS:
: t

** Uncle Dave
https://github.com/daedreth/UncleDavesEmacs
*** async
Already in =init.el=

#+BEGIN_SRC emacs-lisp :tangle no
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; async ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; activate for all packages. Advised in Helm's wiki
;; also, uncle dave says: Lets us use asynchronous processes wherever
;; possible, pretty useful.

;;(use-package async
;;  :ensure t
;;  :init (dired-async-mode 1))

;;(setq async-bytecomp-allowed-packages '(all))
#+END_SRC

#+RESULTS:
| all |

*** Screenshots
I don’t need scrot to take screenshots, or shutter or whatever tools you might have. This is enough. These won’t work in the terminal version or the virtual console, obvious reasons.

***** Screenshotting the entire screen

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/take-screenshot ()
  "Takes a fullscreen screenshot of the current workspace"
  (interactive)
  (when window-system
  (loop for i downfrom 3 to 1 do
        (progn
          (message (concat (number-to-string i) "..."))
          (sit-for 1)))
  (message "Cheese!")
  (sit-for 1)
  (start-process "screenshot" nil "import" "-window" "root" 
             (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
  (message "Screenshot taken!")))
(global-set-key (kbd "s-[") 'daedreth/take-screenshot)
#+END_SRC

***** Screenshotting a region

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/take-screenshot-region ()
  "Takes a screenshot of a region selected by the user."
  (interactive)
  (when window-system
  (call-process "import" nil nil nil ".newScreen.png")
  (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
                (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
  (call-process "rm" nil nil nil ".newScreen.png")))
(global-set-key (kbd "s-]") 'daedreth/take-screenshot-region)
#+END_SRC

#+RESULTS:
: daedreth/take-screenshot-region

*** System monitor
A teeny-tiny system monitor that can be enabled or disabled at runtime, useful for checking performance with power-hungry processes in ansi-term

symon can be toggled on and off with =super+h=.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package symon
  :ensure t
  :bind
  ("s-h" . symon-mode))
#+END_SRC

#+RESULTS:
: symon-mode

*** COMMENT Default shell should be bash
I don’t know why this is a thing, but asking me what shell to launch every single time I open a terminal makes me want to slap babies, this gets rid of it. This goes without saying but you can replace bash with your shell of choice.

DGM: not needed now that I use =pop-shell= plus I don't know why it's now working 
#+BEGIN_SRC emacs-lisp :tangle no
(defvar my-term-shell "/bin/bash")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-shell)
#+END_SRC

#+RESULTS:
: ansi-term

*** Easy to remember keybinding
In loving memory of bspwm, =super+Enter= opens a new terminal, old habits die hard.

#+BEGIN_SRC emacs-lisp :tangle no
;; (global-set-key (kbd "<s-return>") 'ansi-term)
#+END_SRC

#+RESULTS:
: ansi-term

I think this will is too powerful a shortcut for this. I'd rather use it for =swipe=.

*** Ivy 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ivy
  :ensure t)
#+END_SRC

#+RESULTS:

*** scrolling and why does the screen move
I don’t know to be honest, but this little bit of code makes scrolling with emacs a lot nicer.

#+BEGIN_SRC emacs-lisp :tangle yes
;; (setq scroll-conservatively 100)
#+END_SRC

I've disabled it because it is set to 0 in =starter-kit-text.org=.

*** windows, panes and why I hate other-window
Some of us have large displays, others have tiny netbook screens, but regardless of your hardware you probably use more than 2 panes/windows at times, cycling through all of them with C-c o is annoying to say the least, it’s a lot of keystrokes and takes time, time you could spend doing something more productive.

***** =ace-window=
ace-window is a package that uses the same idea from ace-jump-mode for buffer navigation, but applies it to windows. 

Tips from https://pastebin.com/MnSsUWeZ

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-window
  :ensure t
  :config
  (ace-window-display-mode)
  (setq aw-dispatch-always t)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (defvar aw-dispatch-alist
    '((?x aw-delete-window "Delete Window")
      (?m aw-swap-window "Swap Windows")
      (?M aw-move-window "Move Window")
      (?j aw-switch-buffer-in-window "Select Buffer")
      (?n aw-flip-window)
      (?u aw-switch-buffer-other-window "Switch Buffer Other Window")
      (?c aw-split-window-fair "Split Fair Window")
      (?v aw-split-window-vert "Split Vert Window")
      (?b aw-split-window-horz "Split Horz Window")
      (?o delete-other-windows "Delete Other Windows")
      (?? aw-show-dispatch-help)))
  :bind ("M-P" . ace-window))

;; (global-set-key (kbd "M-P") 'ace-window)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23569 36355 585435 681000) :init (23569 36355 585136 639000) :config (23569 36355 585104 709000) :config-secs (0 0 1097 931000) :init-secs (0 0 1157 882000) :use-package-secs (0 0 1713 661000)))

Problema: if I am in an external app within =exwm=, then =ace-window= does not work and I'd rather use =switch-window=.

***** COMMENT switch-window
This magnificent package takes care of this issue. It’s unnoticeable if you have <3 panes open, but with 3 or more, upon pressing C-x o you will notice how your buffers turn a solid color and each buffer is asigned a letter (the list below shows the letters, you can modify them to suit your liking), upon pressing a letter asigned to a window, your will be taken to said window, easy to remember, quick to use and most importantly, it annihilates a big issue I had with emacs. An alternative is ace-window, however by default it also changes the behaviour of C-x o even if only 2 windows are open, this is bad, it also works less well with exwm for some reason.

DGM: I suspect that this package is responsible for my disappearing-cursor problem because it has always happened when moving across windows... the only other suspect I have is Dired as I think it has involved moving files across windows and directories.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package switch-window
  :ensure t
  :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
        '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
  :bind
    ([remap other-window] . switch-window))
#+END_SRC

#+RESULTS:
: switch-window

***** COMMENT Following window splits
After you split a window, your focus remains in the previous one. This annoyed me so much I wrote these two, they take care of it.
Note: I've commented this out because below I implement the same functionality. See [[split]]

#+BEGIN_SRC emacs-lisp :tangle no
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

#+RESULTS:
: split-and-follow-vertically

*** =swipe=
I like me some searching, the default search is very meh. In emacs, you mostly use search to get around your buffer, much like with avy, but sometimes it doesn’t hurt to search for entire words or mode, swiper makes sure this is more efficient.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package swiper
  :ensure t)
#+END_SRC

#+RESULTS:

*****  Further customization from Pragmatic Emacs

From: http://pragmaticemacs.com/emacs/dont-search-swipe/

#+BEGIN_SRC emacs-lisp :tangle yes
;; (global-set-key (kbd "<s-return>") 'swiper) ;; I'm gonna use this for helm-projectile
(setq ivy-display-style 'fancy)
#+END_SRC

#+RESULTS:
: fancy

The second line in the above code sets the colours of the swiper results display to be a bit more, well, fancy! Apparently this option only works well for emacs versions 24.5 and higher, so get updated.

The other tweak I have made is to get swiper to recenter the display when it exits – I found it a little unpredictable where the point was going to be after I finished swiper. This is done with a little bit of advice:

#+BEGIN_SRC emacs-lisp :tangle yes
;;advise swiper to recenter on exit
(defun bjm-swiper-recenter (&rest args)
  "recenter display after swiper"
  (recenter))
(advice-add 'swiper :after #'bjm-swiper-recenter)
#+END_SRC

#+RESULTS:

*** close-all-buffers
It’s one of those things where I genuinely have to wonder why there is no built in functionality for it. Once in a blue moon I need to kill all buffers, and having ~150 of them open would mean I’d need to spend a few too many seconds doing this than I’d like, here’s a solution.

This can be invoked using C-M-s-k. This keybinding makes sure you don’t hit it unless you really want to.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun close-all-buffers ()
  "Kill all buffers without regard for their origin."
  (interactive)
  (mapc 'kill-buffer (buffer-list)))
(global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC

#+RESULTS:
: close-all-buffers

*** line numbers and programming
Every now and then all of us feel the urge to be productive and write some code. In the event that this happens, the following bit of configuration makes sure that we have access to relative line numbering in programming-related modes. I highly recommend not enabling linum-relative-mode globally, as it messed up something like ansi-term for instance.

Note: I disable this as I find it not very useful and dizzling by way of the moving numbers

#+BEGIN_SRC emacs-lisp :tangle no
(use-package linum-relative
  :ensure t
  :config
    (setq linum-relative-current-symbol "")
    (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC

#+RESULTS:
: t

*** Text manipulation
Here I shall collect self-made functions that make editing text easier.
**** Mark-Multiple
I can barely contain my joy. This extension allows you to quickly mark the next occurence of a region and edit them all at once. Wow!

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mark-multiple
  :ensure t
  :bind ("s-q" . 'mark-next-like-this))
#+END_SRC

#+RESULTS:
: mark-next-like-this

**** Improved kill-word
Why on earth does a function called kill-word not ... kill a word. It instead deletes characters from your cursors position to the end of the word, let’s make a quick fix and bind it properly.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/kill-inner-word ()
  "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))
(global-set-key (kbd "s-k") 'daedreth/kill-inner-word)
#+END_SRC

#+RESULTS:
: daedreth/kill-inner-word

**** Improved copy-word
And again, the same as above but we make sure to not delete the source word.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/copy-whole-word ()
  (interactive)
  (save-excursion
    (forward-char 1)
    (backward-word)
    (kill-word 1)
    (yank)))
(global-set-key (kbd "s-,") 'daedreth/copy-whole-word) 
#+END_SRC

#+RESULTS:
: daedreth/copy-whole-word
**** Copy a line
Regardless of where your cursor is, this quickly copies a line.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/copy-whole-line ()
  "Copies a line without regard for cursor position."
  (interactive)
  (save-excursion
    (kill-new
     (buffer-substring
      (point-at-bol)
      (point-at-eol)))))
(global-set-key (kbd "s-.") 'daedreth/copy-whole-line)
#+END_SRC

#+RESULTS:
: daedreth/copy-whole-line

**** Kill a line
And this quickly deletes a line.

#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "M-s-k") 'kill-whole-line)
#+END_SRC

#+RESULTS:
: kill-whole-line

*** Minor conveniences
Emacs is at it’s best when it just does things for you, shows you the way, guides you so to speak. This can be best achieved using a number of small extensions. While on their own they might not be particularly impressive. Together they create a nice environment for you to work in.

**** Subwords/Camel casing
Emacs treats camelCase strings as a single word by default, this changes said behaviour.

#+BEGIN_SRC emacs-lisp :tangle yes
(global-subword-mode 1)
#+END_SRC

**** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor. Unless you know its position, you can not move it efficiently. Every time you change buffers, the current position of your cursor will be briefly highlighted now.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package beacon
  :ensure t
  :config
    (beacon-mode 1))
#+END_SRC

#+RESULTS:
: t

**** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them, especially lisp.

Note, however, that Sacha Chua doesn't automatically turn this on because she thinks it slows things down a little. So she has =(use-package rainbow-delimiters :disabled t)=. So keep an eye on it.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :ensure t
  :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

#+RESULTS:

*** COMMENT Hungry deletion
On the list of things I like doing, deleting big whitespaces is pretty close to the bottom. Backspace or Delete will get rid of all whitespace until the next non-whitespace character is encountered. You may not like it, thus disable it if you must, but it’s pretty decent.

DGM: I am commenting this out as I found it annoying when, for example, editing ledger files and wanting to delete spaces one by one I found the cursor deleting all the white space and thus indening lines in the wrong manner. La sensacion era como si el buffer estuviera tabify when it wasn't... So I wasn't understanding what was going on until I recalled I had this mode enabled.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package hungry-delete
  :ensure t
  :config
    (global-hungry-delete-mode))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23554 33611 672389 982000) :init (23554 33611 672357 93000) :config (23554 33611 672016 76000) :config-secs (0 0 2391 739000) :init-secs (0 0 3160 173000) :use-package-secs (0 0 3365 347000)))

*** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most. With a simple M-y you can now browse your kill-ring like browsing autocompletion items. C-n and C-p totally work for this.

DGM: nice, but i prefer to use helm to browse the kill ring.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package popup-kill-ring
  :ensure t
  :bind ("M-y" . popup-kill-ring))
#+END_SRC

#+RESULTS:
: popup-kill-ring

** Daniel Mai

https://github.com/danielmai/.emacs.d/blob/master/config.org

*** Page breaks

Here we make page-break characters look pretty, instead of appearing as ^L in Emacs. Here’s an informative article called “Using Page-Breaks in GNU Emacs” by Eric J. M. Ritz.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package page-break-lines
  :ensure t)
#+END_SRC

#+RESULTS:

*** Split window and move to new window <<split>>

Whenever I split windows, I usually do so and also switch to the other window as well, so might as well rebind the splitting key bindings to do just that to reduce the repetition.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun vsplit-other-window ()
  "Splits the window vertically and switches to that window."
  (interactive)
  (split-window-vertically)
  (other-window 1 nil))
(defun hsplit-other-window ()
  "Splits the window horizontally and switches to that window."
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil))

(bind-key "C-x 2" 'vsplit-other-window)
(bind-key "C-x 3" 'hsplit-other-window)
#+END_SRC

#+RESULTS:
: hsplit-other-window

*** COMMENT Transpose frame

Check it out here: https://www.emacswiki.org/emacs/TransposeFrame
Commented out because I don't work with frames and because this functionality is already implemented with =s-\=

#+BEGIN_SRC emacs-lisp :tangle no
(use-package transpose-frame
  :ensure t
  :bind ("C-c t" . transpose-frame))
#+END_SRC

#+RESULTS :
: transpose-frame

*** COMMENT Ace-jump 
A quick way to jump around text in buffers.

See Emacs Rocks Episode 10 for a screencast: http://emacsrocks.com/e10.html

Commented out as =C-o= does the same and =s-s= even better as it applies to any letter anywhere in the buffer.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package ace-jump-mode
  :ensure t
  :diminish ace-jump-mode
  :commands ace-jump-mode
  :bind ("C-s-s" . ace-jump-mode))
#+END_SRC

#+RESULTS:
: ace-jump-mode
*** Smartscan
Quickly jumps between other symbols found at point in Emacs.

Originally, I tried to bind it to =s-p= and =s-n= here, but smartscan kept using =M-p= and =M-n= so now I have changed it at =smartscan.el=. So remember to do this everytime I install .emacs.d anew. 

Now the mapping is as follows:

- =s-n= smartscan-symbol-go-forward
- =s-p= smartscan-symbol-go-backward
- =s-'= smartscan-symbol-replace

http://www.masteringemacs.org/article/smart-scan-jump-symbols-buffer

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartscan
  :ensure t
  :config (global-smartscan-mode 1))
;;  :bind (("s-n" . smartscan-symbol-go-forward)
;;         ("s-p" . smartscan-symbol-go-backward)))
#+END_SRC

#+RESULTS:
: smartscan-symbol-go-backward

*** Smoothscrolling
This makes it so =C-n-=ing and =C-p-= ing won’t make the buffer jump around so much.

#+BEGIN_SRC emacs-lisp :tangle no
;; (use-package smooth-scrolling
;;  :ensure t
;;  :config
;;  (smooth-scrolling-mode))
#+END_SRC

#+RESULTS:
: 0.01

More tips from https://www.emacswiki.org/emacs/SmoothScrolling

#+BEGIN_SRC emacs-lisp :tangle yes
;; scroll one line at a time (less "jumpy" than defaults)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
#+END_SRC

#+RESULTS:
: 1

I was driven crazy by the jumps. I had set scroll-step and scroll-conservatively as suggested here but it was still jumping half-screens at random times when scrolling. FINALLY, after many years of cursing, the suggestion of setting auto-window-vscroll to nil, below on this page, worked - even though Emacs documentation only says it applies to tall lines with large images, which I don’t use. In fact it seems to apply to any scrolling with too-slow terminal and too-fast keyboard repeat rate. So, here’s my tested recipe for civilized scrolling, which works regardless of your screen speed and keyboard speed:
(https://www.emacswiki.org/emacs/SmoothScrolling)

#+BEGIN_SRC emacs-lisp :tangle yes
(setq scroll-step 1)
; Autosave every 500 typed characters. Alternative: try turning off auto save interval altogether.
(setq auto-save-interval 500)
; Scroll just one line when hitting bottom of window // ;; scrolling to always be a line at a time
(setq scroll-conservatively 10000)
(setq auto-window-vscroll nil)
#+END_SRC

#+RESULTS:

*** Scratch

From: https://github.com/ieure/scratch-el
Convenient package to create *scratch* buffers that are based on the current buffer’s major mode. This is more convienent than manually creating a buffer to do some scratch work or reusing the initial *scratch* buffer.

Se usa con =M-x scratch= y te crea un scratch buffer of the currently used mode. But you can choose another mode by doing =C-u M-x scratch=

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package scratch
  :ensure t
  :commands scratch)
#+END_SRC

#+RESULTS:

*** Visible mode
I found out about this mode by looking through =simple.el=. 
(For the record: =simple.el=  is a grab-bag of basic Emacs commands not specifically related to some major mode or to file-handling.)
I use it to see raw org-mode files without going to a different mode like text-mode, which is what I had done in order to see invisible text (with org hyperlinks). The entire buffer contents will be visible while still being in org mode.

Make visible mode the default, please. 

#+BEGIN_SRC emacs-lisp :tangle yes
(visible-mode 1)
(global-set-key (kbd "s-h") 'visible-mode)
#+END_SRC

#+RESULTS:
: visible-mode

*** Pulseaudio 

Info in https://github.com/flexibeast/pulseaudio-control

Sets prefix to =C-x /=. Then  
=+=: Increase the volume of the currently-selected sink by pulseaudio-control-volume-step (pulseaudio-control-increase-volume).
=-=: Decrease the volume of the currently-selected sink by pulseaudio-control-volume-step (pulseaudio-control-decrease-volume).
=m=: Toggle muting of the currently-selected sink (pulseaudio-control-toggle-current-sink-mute).
=d=: Display volume of the currently-selected sink (pulseaudio-control-display-volume).

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package pulseaudio-control
  :ensure t)

(with-eval-after-load 'pulseaudio-control
  ;; REVIEW: Upstream should set path dynamically.
  ;; https://github.com/flexibeast/pulseaudio-control/issues/7
  (setq pulseaudio-control-pactl-path (executable-find "pactl")
        pulseaudio-control-volume-step "2%"))
#+END_SRC

#+RESULTS:
: 2%

#+BEGIN_SRC emacs-lisp :tangle yes
(pulseaudio-control-default-keybindings)
#+END_SRC

#+RESULTS:
: pulseaudio-control-map

*** Enabling various commands for up/down casing, etc. 

From https://github.com/danielmai/.emacs.d/blob/master/config.org and http://tobytripp.github.io/emacs.d/

#+BEGIN_SRC emacs-lisp :tangle yes
 (put 'upcase-region 'disabled nil)
 (put 'downcase-region 'disabled nil)
 (put 'narrow-to-region 'disabled nil)
 (put 'dired-find-alternate-file 'disabled nil)
 (put 'set-goal-column 'disabled nil)
#+END_SRC

** COMMENT Dashboard

I leave it out as it doesn't work with =exwm=

#+BEGIN_SRC emacs-lisp :tangle no
(use-package dashboard
  :ensure t
  :config
    (dashboard-setup-startup-hook)
;    (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
    (setq dashboard-items '((recents   . 10)
                            (bookmarks . 10)
                            (projects  . 10)))
    (setq dashboard-banner-logo-title ""))
(message "Testing 2 dashboard chunk is evaluated.")
#+END_SRC

#+RESULTS:
: Testing 2 dashboard chunk is evaluated.

** COMMENT Mark current word
From https://www.emacswiki.org/emacs/MarkCommands#toc7

Commented out as =s-/= does the same and with a better shortcut, as defined  [[select]]

#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-mark-current-word (&optional arg allow-extend)
    "Put point at beginning of current word, set mark at end."
    (interactive "p\np")
    (setq arg (if arg arg 1))
    (if (and allow-extend
             (or (and (eq last-command this-command) (mark t))
                 (region-active-p)))
        (set-mark
         (save-excursion
           (when (< (mark) (point))
             (setq arg (- arg)))
           (goto-char (mark))
           (forward-word arg)
           (point)))
      (let ((wbounds (bounds-of-thing-at-point 'word)))
        (unless (consp wbounds)
          (error "No word at point"))
        (if (>= arg 0)
            (goto-char (car wbounds))
          (goto-char (cdr wbounds)))
        (push-mark (save-excursion
                     (forward-word arg)
                     (point)))
        (activate-mark))))

(define-key global-map (kbd "C-c x") 'my-mark-current-word) 
#+END_SRC

#+RESULTS:
: my-mark-current-word

** IRC

Sometimes useful for getting help on R or Emacs.

#+source: rirc-configuration
#+begin_src emacs-lisp :tangle yes
;; connect to irc on invocation but don't autojoin any channels (require 'rcirc)
;;  (add-to-list 'rcirc-server-alist
;;                       '("irc.freenode.net")) ;; this code stopped working after my customizations following the mini emacs guide
(setq rcirc-server-alist
      '(("irc.freenode.net" :channels ("#emacs" "#python" "#sml" "#nasm" "#gcc"))))
#+end_src

#+RESULTS: rirc-configuration
| irc.freenode.net | :channels | (#emacs #python #sml #nasm #gcc) |

** Comment or uncomment region 

#+srcname: final-custom
#+begin_src emacs-lisp :tangle yes
  ;; minimize fringe
  (setq-default indicate-empty-lines nil)

  ;; Add keybindings for commenting regions of text
  (global-set-key (kbd "C-c ;") 'comment-or-uncomment-region)
#+end_src

#+RESULTS: final-custom
: comment-or-uncomment-region

** Base dir

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; Base dir
  (cd "~/")
#+END_SRC

#+RESULTS:
: /home/dgm/

** Electric pair mode

From http://ergoemacs.org/emacs/emacs_insert_brackets_by_pair.html

Emacs 24 has a new minor mode electric-pair-mode. When on, typing any left bracket automatically insert the right matching bracket. 
You can have it on always. Put this in your emacs init:

#+BEGIN_SRC emacs-lisp :tangle yes
;; auto close bracket insertion. New in emacs 24
(electric-pair-mode 1)
#+END_SRC

#+RESULTS:
: t

Brackets includes ASCII and Unicode brackets or quotation marks. Deleting one bracket doesn't delete the other. Exactly which brackets are auto-closed depends on the current major mode's syntax table. If you always want certain brackets be inserted in pairs, you can customize the variable electric-pair-pairs. Its value should be a Association List. For example, the curly bracket {} isn't auto-closed when in emacs-lisp-mode. You can make it do so, like this:

#+BEGIN_SRC emacs-lisp :tangle no
;; make electric-pair-mode work on more brackets
(setq electric-pair-pairs
      '(
        (?\" . ?\")
        (?\{ . ?\})))
#+END_SRC

** Select whole word <<select>>

From https://emacs.stackexchange.com/questions/35069/best-way-to-select-a-word

#+BEGIN_SRC emacs-lisp :tangle yes
(defun mark-whole-word (&optional arg allow-extend)
  "Like `mark-word', but selects whole words and skips over whitespace.
If you use a negative prefix arg then select words backward.
Otherwise select them forward.

If cursor starts in the middle of word then select that whole word.

If there is whitespace between the initial cursor position and the
first word (in the selection direction), it is skipped (not selected).

If the command is repeated or the mark is active, select the next NUM
words, where NUM is the numeric prefix argument.  (Negative NUM
selects backward.)"
  (interactive "P\np")
  (let ((num  (prefix-numeric-value arg)))
    (unless (eq last-command this-command)
      (if (natnump num)
          (skip-syntax-forward "\\s-")
        (skip-syntax-backward "\\s-")))
    (unless (or (eq last-command this-command)
                (if (natnump num)
                    (looking-at "\\b")
                  (looking-back "\\b")))
      (if (natnump num)
          (left-word)
        (right-word)))
    (mark-word arg allow-extend)))

(global-set-key (kbd "s-/") 'mark-whole-word) 
#+END_SRC

#+RESULTS:
: mark-whole-word

** Mastering emacs with Mickey Petersen
*** Make =C-n= insert newlines if point is at the end of the buffer

#+BEGIN_SRC emacs-lisp :tangle yes
(setq next-line-add-newlines t)
#+END_SRC

#+RESULTS:
: t

*** Visible mark

Too disruptive. I confuse point for mark and vice versa. 

#+BEGIN_SRC emacs-lisp :tangle no
(defface visible-mark-active ;; put this before (require 'visible-mark)
  '((((type tty) (class mono)))
    (t (:background "magenta"))) "")
(setq visible-mark-max 2)
(setq visible-mark-faces `(visible-mark-face1 visible-mark-face2))

(use-package visible-mark
  :ensure t
  :defer 1
  :init
  (global-visible-mark-mode nil)) ;; too disruptive
#+END_SRC

#+RESULTS:
: [nil 0 1 0 nil require (visible-mark nil t) idle 0]

*** Imenu

Can I make Imenu index the whole buffer even if using FoldingMode and all folds are folded?
From https://www.emacswiki.org/emacs/ImenuMode#toc10

#+BEGIN_SRC emacs-lisp :tangle yes
 (defadvice imenu (around unfold-it compile activate)
      (save-restriction
        (widen)
        ad-do-it))
#+END_SRC

#+RESULTS:
: imenu

Quickly force rescan. You can avoid auto rescanning big buffers just making it easy to manually rescan:

#+BEGIN_SRC emacs-lisp :tangle yes
 (defun my-imenu-rescan ()
   (interactive)
   (imenu--menubar-select imenu--rescan-item))
#+END_SRC

#+RESULTS:
: my-imenu-rescan

*** Go to symbol easily 

=.el= file for function =ido-goto-symbol= downloaded from https://www.emacswiki.org/emacs/ImenuMode#toc10

#+BEGIN_SRC emacs-lisp :tangle yes
    (defun ido-goto-symbol (&optional symbol-list)
      "Refresh imenu and jump to a place in the buffer using Ido."
      (interactive)
      (unless (featurep 'imenu)
        (require 'imenu nil t))
      (cond
       ((not symbol-list)
        (let ((ido-mode ido-mode)
              (ido-enable-flex-matching
               (if (boundp 'ido-enable-flex-matching)
                   ido-enable-flex-matching t))
              name-and-pos symbol-names position)
          (unless ido-mode
            (ido-mode 1)
            (setq ido-enable-flex-matching t))
          (while (progn
                   (imenu--cleanup)
                   (setq imenu--index-alist nil)
                   (ido-goto-symbol (imenu--make-index-alist))
                   (setq selected-symbol
                         (ido-completing-read "Symbol? " symbol-names))
                   (string= (car imenu--rescan-item) selected-symbol)))
          (unless (and (boundp 'mark-active) mark-active)
            (push-mark nil t nil))
          (setq position (cdr (assoc selected-symbol name-and-pos)))
          (cond
           ((overlayp position)
            (goto-char (overlay-start position)))
           (t
            (goto-char position)))))
       ((listp symbol-list)
        (dolist (symbol symbol-list)
          (let (name position)
            (cond
             ((and (listp symbol) (imenu--subalist-p symbol))
              (ido-goto-symbol symbol))
             ((listp symbol)
              (setq name (car symbol))
              (setq position (cdr symbol)))
             ((stringp symbol)
              (setq name symbol)
              (setq position
                    (get-text-property 1 'org-imenu-marker symbol))))
            (unless (or (null position) (null name)
                        (string= (car imenu--rescan-item) name))
              (add-to-list 'symbol-names name)
              (add-to-list 'name-and-pos (cons name position))))))))

(global-set-key (kbd "s-?") 'ido-goto-symbol)
#+END_SRC

#+RESULTS:
: ido-goto-symbol

*** TODO =etags= costumization: learn what these =etags= are

TAGS is ancient technology that uses an external tool called =ctags= or =etags= (see manpage for ctags for example) to index function signatures from source files into one big flat file. Emacs has excellent support for TAGS (but again lacks the fuzziness ido provides, unless you write some elisp) but TAGS was never meant for modern object-oriented languages as it struggles with the hierarchical nature of the code; another big problem is that TAGS is unbearably slow on large codebases, making it unusable in single-threaded Emacs.

The two bread-and-butter TAGS commands to find stuff are bound to M-, and M-. (use M-* to jump back); there is also an Emacs-style apropos command called M-x tags-apropos for wildcard search.

If you use my code below, you can use C-. to find by file in the TAGS file, like a poor man’s IDE-style project file.

I don’t remember if I wrote the code below (or if I simply snarfed it from somewhere and modified it.)

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package etags)
(defun ido-find-tag ()
  "Find a tag using ido"
  (interactive)
  (tags-completion-table)
  (let (tag-names)
    (mapc (lambda (x)
        (unless (integerp x)
          (push (prin1-to-string x t) tag-names)))
      tags-completion-table)
    (find-tag (ido-completing-read "Tag: " tag-names))))

(defun ido-find-file-in-tag-files ()
  (interactive)
  (save-excursion
    (let ((enable-recursive-minibuffers t))
      (visit-tags-table-buffer))
    (find-file
     (expand-file-name
      (ido-completing-read
       "Project file: " (tags-table-files) nil t)))))

(global-set-key [remap find-tag] 'ido-find-tag)
(global-set-key (kbd "C-`") 'ido-find-file-in-tag-files)
#+END_SRC

#+RESULTS:
: ido-find-file-in-tag-files

*** Mark functionality
**** Explicitly set the mark

From https://www.masteringemacs.org/article/fixing-mark-commands-transient-mark-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(global-set-key (kbd "C-.") 'push-mark-no-activate)
#+END_SRC

#+RESULTS:
: push-mark-no-activate

**** Jump to mark

The C-u C-SPC command jumps to mark but Petersen prefers to jump to the mark with a shortcut bound to =M-`=.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))
(global-set-key (kbd "M-`") 'jump-to-mark)
#+END_SRC

#+RESULTS:
: jump-to-mark

**** Exchange point and mark without activating the region 

The exchange-point-and-mark, bound to C-x C-x, will by default activate the region when it is invoked. You must use the prefix argument to suppress the activation, but I find that to be too cumbersome for day-to-day use so I disable it outright. The snippet below will do this, so if you don’t want that to happen don’t use the snippet below!

#+BEGIN_SRC emacs-lisp :tangle yes
(defun exchange-point-and-mark-no-activate ()
  "Identical to \\[exchange-point-and-mark] but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))
(define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)
#+END_SRC

#+RESULTS:
: exchange-point-and-mark-no-activate

** Interleave 

From Reddit: https://www.reddit.com/r/emacs/comments/4gudyw/help_me_with_my_orgmode_workflow_for_notetaking/

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package interleave
  :ensure t)
#+END_SRC

#+RESULTS:

** pdf-tools

From https://github.com/politza/pdf-tools

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package pdf-tools
  :ensure t)

;; (pdf-tools-install) ;; commented out as I think it gets activated below
#+END_SRC


Tweaking from Ambrevar's dot file. However, his original combination of colors was too aggresive for me. Researching on the web, I came across this article https://www.cs.cmu.edu/~jbigham/pubs/pdfs/2017/colors.pdf and it looks cool now.

#+BEGIN_SRC emacs-lisp :tangle yes
(when (require 'pdf-tools nil t)
   ;; (setq pdf-view-midnight-colors '("#ffffff" . "#000000")) 
   ;; (setq pdf-view-midnight-colors '("#ff9900" . "#0a0a12" )) ; Amber's original combination. Too agressive for me. 
   (setq pdf-view-midnight-colors '("black" . "#EDD1B9" )) ; peach is the answer.
   (add-hook 'pdf-view-mode-hook 'pdf-view-midnight-minor-mode)
   (pdf-tools-install t t t))
#+END_SRC

#+RESULTS:

** Markdown-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package markdown-mode
  :ensure t)
#+END_SRC

#+RESULTS:

* Tuhdo's customization of Helm's appearance

Sometimes, customization of helm's looks set in =starter-kit-helm.org= gets overriden... that's why I place it here now.
From: https://www.reddit.com/r/emacs/comments/2z7nbv/lean_helm_window/

Helm window is too big? That's why you have helm-autoresize-mode:

#+BEGIN_SRC emacs-lisp :tangle yes
(setq  helm-display-header-line nil)
#+END_SRC

The resizing is too annoying and you only want the window to be less varied or even at a different fixed size rather than the default size? It can be done with:

#+BEGIN_SRC emacs-lisp :tangle yes
(helm-autoresize-mode -1)
(setq helm-autoresize-max-height 30)
(setq helm-autoresize-min-height 30)
#+END_SRC

Now, you have a Helm window that always takes 30% of your frame height.

One of the thing that annoyed me with Ido is that it is always at the bottom in the minibuffer and raise the mode line. If you are like me, you may want to open Helm window in the current window where point is in, so you don't have to move eyes far away from the upper-half of the window to the minibuffer. This is problematic if you have large monitor (i.e. 24 inches or above).

By setting this:

#+BEGIN_SRC emacs-lisp :tangle yes
;; (setq helm-split-window-in-side-p t)
(setq helm-split-window-inside-p t)
#+END_SRC

Now, Helm always opens a small window right inside and at the lower half of current window. No more random Helm window! 

You may want to remove the header line for Helm command with only one source.  (Note: No entiendo que' es esto de one vs. multiple sources.)

For Helm command with multiple sources, the header line appears as a very thin line. This is fine, but if you want Helm to be a bit smart, that is, keep the full source header line when multiple sources and hidden when there's a single source, you can add the following function to =helm-before-initialize-hook=:
(Now, Helm appears as usual when there's multiple sources.)

#+BEGIN_SRC emacs-lisp :tangle yes
(defvar helm-source-header-default-background (face-attribute 'helm-source-header :background))
(defvar helm-source-header-default-foreground (face-attribute 'helm-source-header :foreground))
(defvar helm-source-header-default-box (face-attribute 'helm-source-header :box))

(defun helm-toggle-header-line ()
  (if (> (length helm-sources) 1)
      (set-face-attribute 'helm-source-header
                          nil
                          :foreground helm-source-header-default-foreground
                          :background helm-source-header-default-background
                          :box helm-source-header-default-box
                          :height 1.0)
    (set-face-attribute 'helm-source-header
                        nil
                        :foreground (face-attribute 'helm-selection :background)
                        :background (face-attribute 'helm-selection :background)
                        :box nil
                        :height 0.1)))
#+END_SRC

#+RESULTS:
: helm-toggle-header-line

** Further customization of helm's looks, mainly colors

If I place this in the =starter-kit-helm.org= file, for some reason, probably because some code in the way overlaps the following, it does not work.

#+BEGIN_SRC emacs-lisp :tangle no
;; comment out by dgm
;;;;; (set-face-attribute 'helm-source-header nil :inherit 'header-line :height 'unspecified :background 'unspecified :foreground 'unspecified)
;(set-face-background 'helm-selection "#4f4f4f")  
;(set-face-background 'helm-visible-mark "#2f2f2f")
;(set-face-foreground 'helm-visible-mark nil)
;(set-face-foreground 'helm-match "DarkOrange3")
;(set-face-attribute 'helm-buffer-file nil :background 'unspecified :foreground nil :weight 'normal)
;(set-face-attribute 'helm-buffer-directory nil :background 'unspecified :foreground "#1e90ff" :weight 'bold)  ;; #1e90ff
;(set-face-attribute 'helm-ff-directory nil :background 'unspecified :foreground 'unspecified :weight 'unspecified :inherit 'helm-buffer-directory)
;(set-face-attribute 'helm-ff-file nil :background 'unspecified :foreground 'unspecified :weight 'unspecified :inherit 'helm-buffer-file)
;(set-face-foreground 'helm-grep-finish "green4")
#+END_SRC

#+RESULTS:

* Smartparens Mode

   Smart autopairing of quotes and parentheses. The original config was this, but it was too intrusive with org-mode.

#+begin_src emacs-lisp :tangle no
(use-package smartparens
  :ensure t
  :diminish smartparens-mode
  :config
  (progn
    (require 'smartparens-config)
    ;; (smartparens-global-mode 1) ;; disabled by dgm on 29 dic 2019 to try and get bindings in Org mode
    (show-smartparens-global-mode +1)
    (sp-use-paredit-bindings)
    (setq sp-base-key-bindings 'paredit)
    (setq sp-autoskip-closing-pair 'always)
    (setq sp-hybrid-kill-entire-symbol nil)))
#+end_src

This is Sacha Chua's config (without her keybindings):

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smartparens
    :diminish smartparens-mode
    :config
    (progn
      (require 'smartparens-config)
      ;; http://ivanmalison.github.io/dotfiles/  
      ;; I reintroduce these two lines so that I can have =sp-local-pair='s defined for org-mode below working
      ;; Plus =M-up= and =M-down= continue working as they should
      (smartparens-global-mode 1)
      (sp-use-smartparens-bindings)
      ;; back to sacha
      (add-hook 'emacs-lisp-mode-hook 'smartparens-mode)
      (add-hook 'emacs-lisp-mode-hook 'show-smartparens-mode)
;;;;;;;;;;;;;;;;;;
      ;; pair management
      (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
      (sp-local-pair 'web-mode "<" nil :when '(my/sp-web-mode-is-code-context))

  ;;; markdown-mode
      (sp-with-modes '(markdown-mode gfm-mode rst-mode)
        (sp-local-pair "*" "*" :bind "C-*")
        (sp-local-tag "2" "**" "**")
        (sp-local-tag "s" "```scheme" "```")
        (sp-local-tag "<"  "<_>" "</_>" :transform 'sp-match-sgml-tags))

  ;;; tex-mode latex-mode
      (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
        (sp-local-tag "i" "1d5f8e69396c521f645375107197ea4dfbc7b792quot;<" "1d5f8e69396c521f645375107197ea4dfbc7b792quot;>"))

  ;;; html-mode
      (sp-with-modes '(html-mode sgml-mode web-mode)
        (sp-local-pair "<" ">"))

  ;; org-mode
      (sp-local-pair 'org-mode "~" "~")
      (sp-local-pair 'org-mode "=" "=") ; select region, hit = then region -> =region= in org-mode
      (sp-local-pair 'org-mode "*" "*") ; select region, hit * then region -> *region* in org-mode
      (sp-local-pair 'org-mode "/" "/") ; select region, hit / then region -> /region/ in org-mode
      (sp-local-pair 'org-mode "_" "_") ; select region, hit _ then region -> _region_ in org-mode
      (sp-local-pair 'org-mode "+" "+") ; select region, hit + then region -> +region+ in org-mode
      (sp-local-pair 'org-mode "$" "$") ; 
      ;; (sp-local-pair 'org-mode "`" "'") ; not working, as it waits for second `
      (sp-local-pair 'org-mode "``" "''") 
    
  ;;; lisp modes
      (sp-with-modes sp--lisp-modes
        (sp-local-pair "(" nil :bind "C-(") 
        (sp-local-pair "<" ">")) 

  ;; elisp mode
     (sp-local-pair 'elisp-mode "<" ">") 

  ;;; http://ivanmalison.github.io/dotfiles/
    (unbind-key "M-D" smartparens-mode-map)              ;; conflicts with duplicate line.
    (unbind-key "M-<up>" smartparens-mode-map)           ;; conflicts with org-mode commands for moving around rows 
    (unbind-key "M-<backspace>" smartparens-mode-map)    ;; conflicts with basic command for killing last word.
    (unbind-key "M-<down>" smartparens-mode-map)))       ;; and headings.
#+END_SRC


#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23674 39181 325289 735000) :init (23674 39181 325280 112000) :config (23674 39181 325122 105000) :config-secs (0 0 230446 267000) :init-secs (0 0 230829 136000) :use-package-secs (0 0 230890 36000)))

The =sp-= bits come from http://tuhdo.github.io/emacs-tutor3.html

#+BEGIN_SRC emacs-lisp :tangle yes
(sp-local-pair 'emacs-lisp-mode "'" nil :actions nil) 
(sp-local-pair 'emacs-lisp-mode "`" nil :actions nil) 

(sp-local-pair 'racket-mode "'" nil :actions nil) 
(sp-local-pair 'racket-mode "`" nil :actions nil)

(sp-local-pair 'fundamental-mode "'" nil :actions nil) 
(sp-local-pair 'fundamental-mode "`" nil :actions nil)

(sp-local-pair 'org-mode "'" nil :actions nil) 
(sp-local-pair 'org-mode "`" nil :actions nil)

;;(sp-local-pair 'latex-mode "=" nil :actions nil) 

;;   (smartparens-global-mode 1)
;;  (require 'smartparens-config) ;; To use the default configuration that smartparens provides for Lisp modes generally and for racket-mode specifically
#+end_src

#+RESULTS: smartparens
: t


** COMMENT Hook to avoid clash with =smartparens= keybindings

- Solution inspired here 
https://www.reddit.com/r/emacs/comments/3dn226/help_with_smartparens_and_overriding_bindings/
- Otherwise, =M-up= and =M-down= were owned by =smartparens= and could not move around in org tables.

#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'org-mode-hook (lambda () 
                           (setq sp-override-key-bindings '(("M-<up>"   . nil)
                                                            ("M-D"      . nil)
                                                            ("M-<down>" . nil)))))
#+END_SRC

Note of Dic 30, 2018: This worked but the new solution in the prior chunk works too and seems more parsimonious.

* Bookmark Plus

https://www.emacswiki.org/emacs/BookmarkPlus

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'bookmark+)
#+END_SRC

#+RESULTS:
: bookmark+

* Ledger

From 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ledger-mode
  :ensure t
  :init
  (setq ledger-clear-whole-transactions 1)
  ;;:config
  ;;(add-to-list 'ledger-report-mode) ;; Gives error Compiler-macro error for add-to-list: (wrong-number-of-arguments (3 . 5) 2)
  :mode "\\.dat\\'")
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23548 17303 871458 855000) :init (23548 17303 871411 289000) :init-secs (0 0 97 698000) :use-package-secs (0 0 314 844000)))

* Nice symbol for end of file lines

From https://www.reddit.com/r/emacs/comments/2kdztw/emacs_in_evil_mode_show_tildes_for_blank_lines/

Originally here:

#+BEGIN_SRC emacs-lisp :tangle yes
;;(setq-default indicate-empty-lines t)
;;(define-fringe-bitmap 'tilde [0 0 0 113 219 142 0 0] nil nil 'center)
;;(setcdr (assq 'empty-line fringe-indicator-alist) 'tilde)
;;(set-fringe-bitmap-face 'tilde 'font-lock-comment-face)
;;;;;;; (set-fringe-bitmap-face 'tilde 'font-lock-function-name-face) ;; for blue tilde
#+END_SRC

But then the guy turned it into a minor mode! See 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package vi-tilde-fringe)
(global-vi-tilde-fringe-mode 1)
#+END_SRC

#+RESULTS:
: t

To turn it on automatically only for programming modes:

=(add-hook 'prog-mode-hook 'vi-tilde-fringe-mode)=


Open the customization group buffer:

=M-x customize-group RET vi-tilde-fringe RET=

* Diminishing modes 

Your modeline is sacred, and if you have a lot of modes enabled, as you will if you use this config, you might end up with a lot of clutter there, the package diminish disables modes on the mode line but keeps them running, it just prevents them from showing up and taking up space.

THIS WILL BE REMOVED SOON AS USE-PACKAGE HAS THE FUNCTIONALITY BUILT IN

Edit this list as you see fit!

PS: recall that the =diminish= package is installed in =starter-kit.org=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (diminish 'which-key-mode)
  (diminish 'linum-relative-mode)
  (diminish 'hungry-delete-mode)
  (diminish 'visual-line-mode)
  (diminish 'subword-mode)
  (diminish 'beacon-mode)
  (diminish 'irony-mode)
  (diminish 'page-break-lines-mode)
  (diminish 'auto-revert-mode)
  (diminish 'rainbow-delimiters-mode)
  (diminish 'yas-minor-mode)
  (diminish 'rainbow-mode)
;;  (diminish 'undo-tree-mode)
  (diminish 'editorconfig-mode)
;;  (diminish 'smartparens-mode) ;; added in -text.org
  (diminish 'minimal-mode)
  (diminish 'org-mode)
  (diminish 'org-indent-mode)
  (diminish 'volatile-highlights-mode) 
  (diminish 'highlight-symbol-mode) 
  (diminish 'pandoc-mode) 
;;  (diminish 'projectile-mode) 
  (diminish 'browse-kill-ring-mode) 
  (diminish 'auto-fill-mode) 
  (diminish 'refill-mode) 
  (diminish 'helm-gtags-mode) 
  (diminish 'vi-tilde-fringe-mode)
#+END_SRC

#+RESULTS:
|   |

* Euro symbol 

From https://astrofloyd.wordpress.com/2014/08/11/insert-the-euro-symbol-e-in-emacs/
But it doesn't work

#+BEGIN_SRC emacs-lisp :tangle no
(fset 'euro
   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([24 56 return 35 120 50 48 65 67 return] 0 "%d")) arg)))
#+END_SRC

#+RESULTS:
| lambda | (&optional arg) | Keyboard macro. | (interactive p) | (kmacro-exec-ring-item '([24 56 return 35 120 50 48 65 67 return] 0 %d) arg) |

The euro sign can then be inserted by calling the macro:

M-x euro

* Font-locking shell prompt
Tip from 
http://www.modernemacs.com/post/shell-font-lock/

#+BEGIN_SRC emacs-lisp :tangle yes
(defmacro hy--shell-with-shell-buffer (&rest forms)
  "Execute FORMS in the shell buffer."
  (-let [shell-process
         (gensym)]
    `(-let [,shell-process
            (hy-shell-get-process)]
       (with-current-buffer (process-buffer ,shell-process)
         ,@forms))))

(defmacro hy--shell-with-font-locked-shell-buffer (&rest forms)
  "Execute FORMS in the shell buffer with font-lock turned on."
  `(hy--shell-with-shell-buffer
    (save-current-buffer
      (unless (hy--shell-buffer?)
        (setq hy-shell-buffer (hy--shell-get-or-create-buffer)))
      (set-buffer hy-shell-buffer)

      (unless (font-lock-mode) (font-lock-mode 1))
      (unless (derived-mode-p 'hy-mode) (hy-mode))

      ,@forms)))

(defun hy--shell-faces-to-font-lock-faces (text &optional start-pos)
  "Set all 'face in TEXT to 'font-lock-face optionally starting at START-POS."
  (let ((pos 0)
        (start-pos (or start-pos 0)))
    (while (and (/= pos (length text))
                (setq next (next-single-property-change pos 'face text)))
      (let* ((plist (text-properties-at pos text))
             (plist (-if-let (face (plist-get plist 'face))
                        (progn (plist-put plist 'face nil)  ; Swap face
                               (plist-put plist 'font-lock-face face))
                      plist)))
        (set-text-properties (+ start-pos pos) (+ start-pos next) plist)
        (setq pos next)))))

(defun hy--shell-fontify-prompt-post-command-hook ()
  "Fontify just the current line in `hy-shell-buffer' for `post-command-hook'.

Constantly extracts current prompt text and executes and manages applying
`hy--shell-faces-to-font-lock-faces' to the text."
  (-when-let* (((_ . prompt-end) comint-last-prompt)
               (_ (and prompt-end
                       (> (point) prompt-end)  ; new command is being entered
                       (hy--shell-current-buffer-a-process?))))  ; process alive?
      (let* ((input (buffer-substring-no-properties prompt-end (point-max)))
             (deactivate-mark nil)
             (buffer-undo-list t)
             (font-lock-buffer-pos nil)
             (text (hy--shell-with-font-locked-shell-buffer
                    (delete-region (line-beginning-position) (point-max))
                    (setq font-lock-buffer-pos (point))
                    (insert input)
                    (font-lock-ensure)
                    (buffer-substring font-lock-buffer-pos (point-max)))))
        (hy--shell-faces-to-font-lock-faces text prompt-end))))

(defun hy--shell-font-lock-turn-on ()
  "Turn on fontification of current line for hy shell."
  (hy--shell-with-shell-buffer
   (hy--shell-kill-buffer)

   (setq-local hy-shell-buffer nil)

   (add-hook 'post-command-hook
             'hy--shell-fontify-prompt-post-command-hook nil 'local)
   (add-hook 'kill-buffer-hook
             'hy--shell-kill-buffer nil 'local)))
#+END_SRC

#+RESULTS:
: hy--shell-font-lock-turn-on

* Sacha Chua
** Minibuffer editing - more space!

Sometimes you want to be able to do fancy things with the text that you're entering into the minibuffer. Sometimes you just want to be able to read it, especially when it comes to lots of text. This binds C-M-e in a minibuffer) so that you can edit the contents of the minibuffer before submitting it. 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package miniedit
  :commands minibuffer-edit
  :init (miniedit-install))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23590 41501 916823 836000) :init (23590 41501 916801 519000) :config (23590 41501 916755 365000) :config-secs (0 0 17 403000) :init-secs (0 0 114 111000) :use-package-secs (0 0 212 59000)))

** Copy filename to clipboard

http://emacsredux.com/blog/2013/03/27/copy-filename-to-the-clipboard/ https://github.com/bbatsov/prelude 

#+BEGIN_SRC emacs-lisp :tangle yes
(defun prelude-copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+END_SRC

#+RESULTS:
: prelude-copy-file-name-to-clipboard

** Edit list   

=M-x edit-list= makes it easier to edit an Emacs Lisp list. 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package edit-list :commands edit-list)
#+END_SRC

** Weather forecast

Sacha has this but it doesn't work because it doesn't interpret my latitude and longitude as numbers.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package forecast
  :config
  (setq forecast-latitude  40.4167
        forecast-longitude -3.6833
        forecast-city "Madrid"
        forecast-country "Spain"
        forecast-api-key "b580b82a056cdb3f6089f08ece4b2eb6"
  )
)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23591 52763 148197 643000) :init (23591 52763 148164 876000) :config (23591 52763 147796 825000) :config-secs (0 0 664 31000) :init-secs (0 0 1481 469000) :use-package-secs (0 0 1618 638000)))

*** Pragmatic Emacs alternative

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package wttrin
  :ensure t
  :commands (wttrin)
  :init
  (setq wttrin-default-cities '("Madrid"
                                "Fuengirola"
                                "Malaga")))

(setq wttrin-default-accept-language '("Accept-Language" . "en-US"))
#+END_SRC

#+RESULTS:
: (Accept-Language . en-US)

The only problem is that if the Emacs frame is not wide enough and the lines in the wttrin buffer wrap, it becomes unreadable. 

My solution is to save the window and frame configuration, then resize the frame to be big enough for the wttrin buffer. The previous configuration is then restored when exiting wttrin. These functions take care of that for us: 

Disabled by DGM as it makes wttrin not working.

#+BEGIN_SRC emacs-lisp :tangle no
;;advise wttrin to save frame arrangement
;;requires frame-cmds package
(defun bjm/wttrin-save-frame ()
  "Save frame and window configuration and then expand frame for wttrin."
  ;;save window arrangement to a register
  (window-configuration-to-register :pre-wttrin)
  (delete-other-windows)
  ;;save frame setup and resize
  (save-frame-config)
  (set-frame-width (selected-frame) 130)
  (set-frame-height (selected-frame) 48)
  )
(advice-add 'wttrin :before #'bjm/wttrin-save-frame)

(defun bjm/wttrin-restore-frame ()
  "Restore frame and window configuration saved prior to launching wttrin."
  (interactive)
  (jump-to-frame-config-register)
  (jump-to-register :pre-wttrin)
  )
(advice-add 'wttrin-exit :after #'bjm/wttrin-restore-frame)
#+END_SRC

#+RESULTS:

**** Update: open wttrin with default city

By default wttrin prompts you to chose the city from your list when it starts. This function starts wttrin with the first city on your list. You can always change this by hitting =g=. 

#+BEGIN_SRC emacs-lisp :tangle yes
;; function to open wttrin with first city on list
(defun bjm/wttrin ()
    "Open `wttrin' without prompting, using first city in `wttrin-default-cities'"
    (interactive)
    ;; save window arrangement to register 
    (window-configuration-to-register :pre-wttrin)
    (delete-other-windows)
    ;; save frame setup
    (save-frame-config)
    (set-frame-width (selected-frame) 130)
    (set-frame-height (selected-frame) 48)
    ;; call wttrin
    (wttrin-query (car wttrin-default-cities))
    )
#+END_SRC

#+RESULTS:
: bjm/wttrin

** Typing of Emacs

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package typing 
  :init
  (autoload 'typing-of-emacs "typing" nil t)
  :config
  (progn
    (setq toe-starting-length 6)
    (setq toe-starting-time-per-word 2)
    (setq toe-max-length 20)))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23592 62164 535459 40000) :init (23592 62164 535445 976000) :config (23592 62164 535242 82000) :config-secs (0 0 354 294000) :init-secs (0 0 5340 661000) :use-package-secs (0 9 443861 775000)))

** Sentences end with a single space

In my world, sentences end with a single space. This makes
sentence navigation commands work for me.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq sentence-end-double-space nil)
#+END_SRC

** Killing text

From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el

#+BEGIN_SRC emacs-lisp :tangle yes
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
    (if mark-active (list (region-beginning) (region-end))
      (list (line-beginning-position)
        (line-beginning-position 2)))))
#+END_SRC

** Help - guide-key

It's hard to remember keyboard shortcuts. The =guide-key= package pops up help after a short delay.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package guide-key
  :defer t
  :diminish guide-key-mode
  :config
  (progn
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
  (guide-key-mode 1)))  ; Enable guide-key-mode
#+END_SRC

** Reading

https://github.com/xahlee/xah_emacs_init/blob/master/xah_emacs_font.el
From Xah Lee:

#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-toggle-margin-right ()
  "Toggle the right margin between `fill-column' or window width.
This command is convenient when reading novel, documentation."
  (interactive)
  (if (eq (cdr (window-margins)) nil)
      (set-window-margins nil 0 (- (window-body-width) fill-column))
    (set-window-margins nil 0 0)))
#+END_SRC

#+RESULTS:
: xah-toggle-margin-right

** Shuffling lines

Don't really know what this does.

#+begin_src emacs-lisp :tangle yes
(defun my/shuffle-lines-in-region (beg end)
  (interactive "r")
  (let ((list (split-string (buffer-substring beg end) "[\r\n]+")))
    (delete-region beg end)
    (insert (mapconcat 'identity (shuffle-list list) "\n"))))
#+end_src

#+RESULTS:
: my/shuffle-lines-in-region

** Pop to mark

Handy way of getting back to previous places.

#+BEGIN_SRC emacs-lisp :tangle yes
(bind-key "s-:" 'pop-to-mark-command)
(setq set-mark-command-repeat-pop t)
#+END_SRC

#+RESULTS:
: t

** Jumping to code

#+begin_src emacs-lisp :tangle yes
(define-key emacs-lisp-mode-map (kbd "C-c .") 'find-function-at-point)
(bind-key "C-c f" 'find-function)
#+end_src

** Sorting

#+begin_src emacs-lisp :tangle yes
  (defun my/sort-sexps-in-region (beg end)
    "Can be handy for sorting out duplicates.
Sorts the sexps from BEG to END. Leaves the point at where it
couldn't figure things out (ex: syntax errors)."
    (interactive "r")
    (let ((input (buffer-substring beg end))
          list last-point form result)
      (save-restriction
        (save-excursion
          (narrow-to-region beg end)
          (goto-char (point-min))
          (setq last-point (point-min))
          (setq form t)
          (while (and form (not (eobp)))
            (setq form (ignore-errors (read (current-buffer))))
            (when form
              (add-to-list
               'list
               (cons
                (prin1-to-string form)
                (buffer-substring last-point (point))))
              (setq last-point (point))))
          (setq list (sort list (lambda (a b) (string< (car a) (car b)))))
          (delete-region (point-min) (point))
          (insert (mapconcat 'cdr list "\n"))))))
#+end_src

**** Evaluation

Borrowed from Steve Purcell's config. This pretty-prints the results.

#+begin_src emacs-lisp :tangle yes
(bind-key "M-:" 'pp-eval-expression)

(defun sanityinc/eval-last-sexp-or-region (prefix)
  "Eval region from BEG to END if active, otherwise the last sexp."
  (interactive "P")
  (if (and (mark) (use-region-p))
      (eval-region (min (point) (mark)) (max (point) (mark)))
    (pp-eval-last-sexp prefix)))

(bind-key "C-x C-e" 'sanityinc/eval-last-sexp-or-region emacs-lisp-mode-map)
#+end_src

*** Enable minibuffer completion

It can be difficult to remember the full names of Emacs commands, so I
use =icomplete-mode= for minibuffer completion. This also makes it
easier to discover commands.

#+begin_src emacs-lisp :tangle no
(icomplete-mode 1)
#+end_src

#+RESULTS:
: t

* Skeleton

- Recall to =eval-and-replace= =(org-skeleton)= with =C-c e=. 
- Nota que por alguna razon hace falta las dos declaraciones de Spanish.
- Nota que ="#+LATEX_HEADER: \\immediate\\write18{sh ./vc}\n"= is gone because now I compile =vc= in the makefile.

#+BEGIN_SRC emacs-lisp :tangle yes
(define-skeleton org-skeleton
  "Inserts a Latex letter skeleton into current buffer.
This only makes sense for empty buffers."
  "# -*- coding: utf-8 -*-\n"
  "# -*- find-file-hook: org-babel-execute-buffer -*-\n"
  "#+TITLE:\n"
  "#+SUBTITLE:\n" 
  "#+AUTHOR:\n" 
  "#+DATE:\n" 
  "#+OPTIONS: toc:4\n" 
  "#+OPTIONS: H:2 num:nil toc:nil \\n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t\n"
  "#+PROPERTY: header-args :tangle yes\n"
  "#+LANGUAGE: "str | "spanish""\n"
  "#+LATEX_HEADER: \\usepackage["str | "spanish""]{babel}\n"
  "#+LATEX_HEADER: \\usepackage{sectsty}\n"
  "#+LATEX_HEADER: \\sectionfont{\\normalfont\\scshape}\n"
  "#+LATEX_HEADER: \\subsectionfont{\\normalfont\\bfseries}\n"
  "#+LATEX_HEADER: \\subsubsectionfont{\\normalfont\\itshape}\n"
  "#+LATEX_HEADER: \\pdfoptionpdfminorversion=6\n"
  "#+LATEX_HEADER: \\usepackage{prelim2e}\n"
  "#+LATEX_HEADER: \\immediate\\write18{sh ./vc}\n"
  "#+LATEX_HEADER: \\input{vc}\n"
  "#LATEX_HEADER: \\renewcommand*{\\PrelimText}{\\textnormal{\\small\\textcolor{black!40}{author: \\VCAuthor\\ -- date: \\VCDateISO\\ -- time: \\VCTime\\ -- commit: \\texttt{\\VCRevision}}}}\n\n"
   "" _ "\n\n"
  "\\printbibliography")
#+END_SRC

#+RESULTS:
: org-skeleton

* Pragmatic Emacs
** dired-narrow

Narrow dired to match filter.  From: http://pragmaticemacs.com/emacs/dynamically-filter-directory-listing-with-dired-narrow/

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dired-narrow
  :ensure t
  :bind (:map dired-mode-map
              ("/" . dired-narrow)))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23623 36409 259307 947000) :init (23623 36409 259186 945000) :init-secs (0 0 37 660000) :use-package-secs (0 0 224 478000)))

* Input method

I'd rather have Spanish prefix as the default. Tips from: https://emacs.stackexchange.com/questions/418/setting-and-activating-the-default-input-method

#+BEGIN_SRC emacs-lisp :tangle no
(set-input-method 'spanish-prefix) 
(setq default-input-method "spanish-prefix")

(defvar use-default-input-method t)
(make-variable-buffer-local 'use-default-input-method)
(defun activate-default-input-method ()
  (interactive)
  (if use-default-input-method
      (activate-input-method default-input-method)
    (inactivate-input-method)))
(add-hook 'after-change-major-mode-hook 'activate-default-input-method)
;; (add-hook 'minibuffer-setup-hook 'activate-default-input-method)
(add-hook 'org-mode-hook 'activate-default-input-method)
(add-hook 'org-load-hook 'activate-default-input-method)
(add-hook 'LaTeX-mode-hook 'activate-default-input-method)
(add-hook 'latex-mode-hook 'activate-default-input-method)
(add-hook 'mu4e-compose-mode-hook 'activate-default-input-method)
;(defun inactivate-default-input-method ()
;  (setq use-default-input-method nil))
;(add-hook 'c-mode-hook 'inactivate-default-input-method)
#+END_SRC

The variable =use-default-input-method= and the function =inactivate-default-input-method= provide a way to turn off the input method (it may be annoying e.g. in programming modes). If you want to turn off the default method in some modes, you register the function =inactivate-default-input-method= in that mode's startup hook, as in the example above for C mode and derived modes (C++, Java, etc.).

The code above systematically turns on the default input method in the minibuffer (comment out that line to have it off by default). Smarter code might use the same input method or lack thereof as the buffer that was previously active, or might choose an input method depending on what the minibuffer is prompted for (e.g. used for search strings but not for file names), but I declare this beyond the scope of this answer.

If you prefer to whitelist modes where the input method is automatically activated, add the function =activate-default-input-method= below to these modes' startup hook, as in the example below for Text mode and derived modes.

#+BEGIN_EXAMPLE
(defun activate-default-input-method ()
  (interactive)
  (activate-input-method default-input-method))
(add-hook 'text-mode-hook 'activate-default-input-method)
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle no
(set-input-method "spanish-prefix")
;(set-input-method 'spanish-prefix) 
(setq default-input-method "spanish-prefix")
;(setq-default default-input-method 'spanish-prefix)

(defun activate-default-input-method ()
  (interactive)
  (activate-input-method default-input-method))
(add-hook 'org-mode-hook 'activate-default-input-method)
(add-hook 'org-load-hook 'activate-default-input-method)
(add-hook 'LaTeX-mode-hook 'activate-default-input-method)
(add-hook 'latex-mode-hook 'activate-default-input-method)
(add-hook 'mu4e-compose-mode-hook 'activate-default-input-method)
(add-hook 'mu4e-compose-pre-hook 'activate-default-input-method) 
(add-hook 'mu4e-compose-parent-message 'activate-default-input-method) 

; (add-hook 'mu4e-mode-hook #'activate-default-input-method)

(defun inactivate-default-input-method ()
  (setq use-default-input-method nil))
(add-hook 'c-mode-hook 'inactivate-default-input-method)
(add-hook 'fundamental-mode 'inactivate-default-input-method)
#+END_SRC

#+RESULTS:
| inactivate-default-input-method |


** Input method shortcut

=defun= defined in Marcel van der Boom's configuration files.
After I change to Spanish with =s-z=, I toggle the input method with =C-\=

DGM on march, 3rd: I've made spanish-prefix the default so this is not needed
March 6: well, it's not working exactly. It works after I set up the new input method. But before it does not. So I need my shortcut back
But now that I've changed some lines in the bit on input method in =dgm.org= this =mrb= stuff does not work at all...

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun mrb/set-input-method()
    (interactive)
    (setq default-input-method "spanish-prefix")
    ;; Toggle only if it not active yet
    (if (not current-input-method)
        (toggle-input-method)))

 ;;(exwm-input-set-key (kbd "s-x") #'exwm-input-toggle-keyboard)
  (exwm-input-set-key (kbd "s-s") #'mrb/set-input-method)
#+END_SRC

#+RESULTS:



* undo-propose

To use undo-propose, call "M-x undo-propose" in the buffer you are editing.
This will send you to a new temporary buffer, which is read-only except
for allowing `undo' commands.  Cycle through the list of undo's as normal.
When you are finished, type "C-c C-c" to add the chain of undo's as a
single edit to the undo history.  To cancel, type "C-c C-k".  You can also
ediff the proposed chain of undo's by typing "C-c C-d".

Read: 

- https://www.reddit.com/r/emacs/comments/awj96h/undopropose_published_in_melpa/
- https://github.com/jackkamm/undo-propose-el
- https://www.reddit.com/r/emacs/comments/atykf9/undopropose_simple_and_safe_undo_in_emacs/

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-propose)
#+END_SRC

* Provide

Trying this on 28 dic 2018. I don't really know why it is needed or not.

#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'dgm)
#+END_SRC

#+RESULTS:
: dgm

* Final message
#+source: message-line
#+begin_src emacs-lisp :tangle yes
(message "Starter Kit User (DGM) File loaded.")
#+end_src

#+RESULTS: message-line
: Starter Kit User File loaded.


