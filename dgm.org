#+TITLE: Local User Customizations
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args :tangle yes


* Starter Kit kjhealy
This file contains local customizations---ones that in some cases
you will not be able to just drop in and use because, e.g., they
involve references to particular files on my own machine. It's
included here for completeness, and as and example of the kind of
things you might put in your own user-specific file.

Some of the settings here depend on additional software that you may
not have installed by default. E.g., the "Use GNU ls" section below
depends on you having GNU coreutils installed. To ignore these
sections, add `:tangle no` to any code block you don't want to use.

To use the customizations here yourself, /you must change the name of
 this file to match your own user name or system name/. Those are the
 values of the Emacs variables =user-login-name= or =system-name=, so
 that it will be picked up by =init.el= when Emacs starts up, and get
 loaded properly. To find the current value of these variables on your
 system, launch emacs and do =C-h-v system-name [RET]= or =C-h-v
 user-login-name [RET]=. For example, on my system =user-login-name=
 is 'kjhealy', so this file is named =kjhealy.org=, and when Emacs
 starts up with the starter kit it creates the file =kjhealy.el=.

You will also need to change the values for the location of bibtex
 databases, pandoc and orgmode-mobile specified below, and some other
 settings. *Search for 'kjhealy' in this file* to find the paths that
 need to be updated. Change them as needed or delete them if you don't
 need these features.

Finally, the [Local Org-mode XeLaTeX Export Settings] section below has
 references to fonts that you may not have available on your
 system. Change the references as appropriate, or comment out or
 delete the lines.

** Local Miscellaneous Settings
*** Use GNU ls
OS X ships with BSD's ls command which doesn't have all the features of GNU ls (used internally by dired). Install `coreutils` with homebrew (`brew install coreutils`) and use `gls` instead.

#+source: gnu-ls
#+begin_src emacs-lisp :tangle yes
  (setq insert-directory-program (executable-find "ls"))
#+end_src

#+RESULTS: gnu-ls
: /bin/ls

*** One space after period

Use `M-e` for sentence-level navigation, but without having to put two spaces after a period like an animal.

#+source: periods
#+begin_src emacs-lisp :tangle yes
  (setq sentence-end-double-space nil)
#+end_src

#+RESULTS: periods

*** Color Theme Tweaks
The theme package is loaded in =starter-kit-misc.org=. The settings
here adjust the height of some headings in Org and LaTeX mode, as well
as turning off the sans-serif heading style that AucTeX defaults to.

#+srcname: local-settings
#+begin_src emacs-lisp :tangle yes
  (add-hook 'latex-mode-hook
            (lambda ()
              (set-face-attribute 'font-latex-sectioning-5-face nil :inherit nil :foreground "#b58900")
              (set-face-attribute 'font-latex-sectioning-0-face nil :height 3)
              (set-face-attribute 'font-latex-sectioning-1-face nil :height 2)
              (set-face-attribute 'font-latex-sectioning-2-face nil :height 1.5)
              (set-face-attribute 'font-latex-sectioning-3-face nil :height 1.2)
              (set-face-attribute 'font-latex-sectioning-4-face nil :height 1.0)))

   (add-hook 'org-mode-hook
             (lambda ()
               (set-face-attribute 'org-level-1 nil :height 1.5)
               (set-face-attribute 'org-level-2 nil :height 1.2)
               (set-face-attribute 'org-level-3 nil :height 1.1)
               (set-face-attribute 'org-level-4 nil :height 1.1)
               (set-face-attribute 'org-level-5 nil :height 1.1)))
#+end_src

#+RESULTS: local-settings
| org-ref-org-menu | (lambda nil (highlight-symbol-mode)) | org-table-stripes-enable | (lambda nil (set-face-attribute 'org-level-1 nil :height 1.5) (set-face-attribute 'org-level-2 nil :height 1.2) (set-face-attribute 'org-level-3 nil :height 1.1) (set-face-attribute 'org-level-4 nil :height 1.1) (set-face-attribute 'org-level-5 nil :height 1.1)) | org-mode-reftex-setup | (lambda nil (local-set-key \216 'outline-next-visible-heading) (local-set-key \220 'outline-previous-visible-heading) (local-set-key \225 'outline-up-heading) (local-set-key \227 'org-table-copy-region) (local-set-key \231 'org-table-paste-rectangle) (local-set-key \214 'org-table-sort-lines) (local-set-key \311 'org-toggle-iimage-in-org)) | (lambda nil (add-to-list 'org-tab-first-hook 'yas-org-very-safe-expand)) | er/add-org-mode-expansions | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-block-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | org-eldoc-load |

*** Run Emacs in Full Screen
  I find it very useful to run Emacs in full-screen mode. There is no
    completely satisfactory way to accomplish this on Mac OS X. What
    works depends on the flavor of emacs you are using,
    unfortunately. Choose as appropriate from the following options. Enable one of them by changing the value of =:tangle= to =yes=.

Bind full screen to `C-c f`.

#+source: fullscreen-4
#+begin_src emacs-lisp :tangle yes
    (defun fullscreen (&optional f)
      (interactive)
      (set-frame-parameter f 'fullscreen
                           (if (frame-parameter f 'fullscreen) nil 'fullboth)))
    (global-set-key (kbd "C-c f") 'fullscreen)
    (add-hook 'after-make-frame-functions 'fullscreen)
#+end_src

#+RESULTS: fullscreen-4
| fullscreen | x-dnd-init-frame |

*** COMMENT Mac Key mode
    Used with Mitsuharu Yamamoto's carbon-patched Emacs, which turns
    off support for default mac bindings. Turned off by default.
#+srcname: mac-keys
#+begin_src emacs-lisp :tangle yes
   (require 'mac-key-mode)
   (mac-key-mode 1)
   (add-hook 'mac-key-mode-hook
       (lambda()
         (interactive)
         (if mac-key-mode
             (setq mac-option-modifier 'meta)
             (setq mac-option-modifier nil)
             )))
#+end_src

*** Dired-x
Dired extensions
#+source: Dired-x
#+begin_src emacs-lisp :tangle yes
  (load "dired-x")
#+end_src

#+RESULTS: Dired-x
: t

*** Dired open multiple files
In dired mode, visit all marked files using. Bound to the "F" key.
#+source: dired-F
#+begin_src emacs-lisp :tangle yes
  (eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "F" 'my-dired-find-file)
     (defun my-dired-find-file (&optional arg)
       "Open each of the marked files, or the file under the point, or when prefix arg, the next N files "
       (interactive "P")
       (let* ((fn-list (dired-get-marked-files nil arg)))
         (mapc 'find-file fn-list)))))
#+end_src

#+RESULTS: dired-F
: my-dired-find-file

*** Stripe Dired buffers
#+name: stripe-dired
#+begin_src emacs-lisp :tangle yes
(require 'stripe-buffer)
(add-hook 'org-mode-hook 'org-table-stripes-enable)
(add-hook 'dired-mode-hook 'stripe-listify-buffer)
#+end_src

*** Avy Mode
From: http://oremacs.com/2016/01/23/avy-0.4.0/

For example, suppose you have:

=(global-set-key (kbd "M-t") 'avy-goto-word-1)=

Here's what you can do now to a word that starts with a "w" and is select-able with "a":

    To jump there: =M-t w a=.
    To copy the word instead of jumping to it: =M-t w na=
    To mark the word after jumping to it: =M-t w ma=.
    To kill the word after jumping to it: =M-t w xa=.

Note I have binded to =C-o= instead of =M-t=:

#+name: avy-mode
#+begin_src emacs-lisp :tangle yes
(use-package avy
  :ensure t
  :bind
    ("s-s" . avy-goto-char))  ;; goes literally to any char

(define-key global-map (kbd "C-o") 'avy-goto-word-1) ;; goes to word that starts with a given char
#+end_src

#+RESULTS: avy-mode
: avy-goto-word-1

Further tweak from Uncle Dave at https://github.com/daedreth/UncleDavesEmacs

In his words: 

Many times have I pondered how I can move around buffers even quicker. I’m glad to say, that avy is precisely what I needed, and it’s precisely what you need as well. In short, as you invoke one of avy’s functions, you will be prompted for a character that you’d like to jump to in the visible portion of the current buffer. Afterwards you will notice how all instances of said character have additional letter on top of them. Pressing those letters, that are next to your desired character will move your cursor over there. Admittedly, this sounds overly complicated and complex, but in reality takes a split second and improves your life tremendously.

I like M-s for it, same as C-s is for moving by searching string, now M-s is moving by searching characters.

#+BEGIN_SRC emacs-lisp :tangle yes
#+END_SRC


** Local LaTeX settings
*** In-text Smart Quotes (XeLaTeX only)
    Redefine TeX-open-quote and TeX-close-quote to be smart quotes by default. Below, in the local org-mode settings, we'll also map the relevant function to a key we can use in org-mode, too. If you don't use XeLaTeX for processing all your =.tex= files, you should disable this option.

#+source: smart-quotes
#+begin_src emacs-lisp :tangle yes
  (setq TeX-open-quote "“")
  (setq TeX-close-quote "”")
#+end_src

*** SyncTeX, PDF mode, Evince
Set up AUCTeX to work with the Evince PDF viewer.

#+srcname: sync
#+begin_src emacs-lisp :tangle yes
    ;; Synctex with Evince
    (add-hook 'TeX-mode-hook
    (lambda ()
    (add-to-list 'TeX-output-view-style
    '("^pdf$" "."
     "/usr/bin/evince  %n %o %b")))
     )

  (setq TeX-view-program-selection '((output-pdf "PDF Viewer")))
  (setq TeX-view-program-list
       '(("PDF Viewer" "/usr/bin/evince -b -g %n %o %b")))

    ;; Make emacs aware of multi-file projects
    ;; (setq-default TeX-master nil)

    ;; Auto-raise Emacs on activation (from Skim, usually)
;;    (defun raise-emacs-on-aqua()
;;    (shell-command "osascript -e 'tell application \"Emacs\" to activate' &"))
;;    (add-hook 'server-switch-hook 'raise-emacs-on-aqua)
#+end_src

*** XeLaTeX and pdfLaTeX Export Settings
    Configure org-mode to export directly to PDF using xelatex, compiling the bibliography as it goes, with my preferred setup in each case. There is a good deal of local stuff in this section. The required style files used below are available at https://github.com/kjhealy/latex-custom-kjh. You may need to adjust or remove some of these settings depending on your preferences and local configuration.

    #+source: orgmode-latex-export
    #+BEGIN_SRC emacs-lisp :tangle yes
    (require 'ox-latex)
;; From https://github.com/kjhealy/emacs-starter-kit/blob/master/kjhealy.org

  ;; Choose either listings or minted for exporting source code blocks.
  ;; Using minted (as here) requires pygments be installed. To use the
  ;; default listings package instead, use
  ;; (setq org-latex-listings t)
  ;; and change references to "minted" below to "listings"
  (setq org-latex-listings 'minted)
  
  ;; default settings for minted code blocks.
  ;; bg will need to be defined in the preamble of your document. It's defined in  org-preamble-xelatex.sty below.
  (setq org-latex-minted-options
        '(;("frame" "single")
          ("bgcolor" "bg") 
          ("fontsize" "\\small")
          ))
  
;; turn off the default toc behavior; deal with it properly in headers to files.
(defun org-latex-no-toc (depth)  
  (when depth
      (format "%% Org-mode is exporting headings to %s levels.\n"
              depth)))
(setq org-latex-format-toc-function 'org-latex-no-toc)

;; note the insertion of the \input statement for the vc information 
(add-to-list 'org-latex-classes
               '("memarticle"
                 "\\documentclass[11pt,oneside,article]{memoir}\n\%\input{vc} % vc package"
                  ("\\section{%s}" . "\\section*{%s}")
                  ("\\subsection{%s}" . "\\subsection*{%s}")
                  ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                  ("\\paragraph{%s}" . "\\paragraph*{%s}")
                  ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-latex-classes
               '("membook"
                 "\\documentclass[11pt,oneside]{memoir}\n\%\input{vc} % vc package"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
 
;; LaTeX compilation command. For orgmode docs we just always use xelatex for convenience.
;; You can change it to pdflatex if you like, just remember to make the adjustments to the packages-alist below.
;; dgm: moved to init.el or else it wouldn't work
;; (setq org-latex-pdf-process '("latexmk -pdflatex='xelatex -synctex=1 --shell-escape' -pdf %f"))

;; Default packages included in the tex file. As before, org-preamble-xelatex is part of latex-custom-kjh.
;; There's org-preamble-pdflatex as well, if you wish to use that instead.
(setq org-latex-default-packages-alist nil)     
(setq org-latex-packages-alist
        '(("minted" "org-preamble-xelatex" t)
          ("" "graphicx" t)
          ("" "longtable" nil)
          ("" "float" ))) 
   #+END_SRC

#+RESULTS: orgmode-latex-export
| minted | org-preamble-xelatex | t   |
|        | graphicx             | t   |
|        | longtable            | nil |
|        | float                |     |

*** ebib and citation settings
    ebib is a bibtex database manager that works inside emacs. It can
    talk to org-mode. See [[http://orgmode.org/worg/org-tutorials/org-latex-export.html#sec-17_2][this Worg tutorial]] for details.
#+source: ebib-setup
#+begin_src emacs-lisp :tangle yes
    (org-add-link-type "ebib" 'ebib)

   (org-add-link-type
     "cite" 'ebib
     (lambda (path desc format)
       (cond
        ((eq format 'latex)
         (if (or (not desc) (equal 0 (search "cite:" desc)))
               (format "\\cite{%s}" path)
               (format "\\cite[%s]{%s}" desc path)
               )))))

   (org-add-link-type
     "parencite" 'ebib
     (lambda (path desc format)
       (cond
        ((eq format 'latex)
         (if (or (not desc) (equal 0 (search "parencite:" desc)))
               (format "\\parencite{%s}" path)
               (format "\\parencite[%s]{%s}" desc path)
  )))))

  (org-add-link-type
     "textcite" 'ebib
     (lambda (path desc format)
       (cond
        ((eq format 'latex)
         (if (or (not desc) (equal 0 (search "textcite:" desc)))
               (format "\\textcite{%s}" path)
               (format "\\textcite[%s]{%s}" desc path)
  )))))

  (org-add-link-type
     "autocite" 'ebib
     (lambda (path desc format)
       (cond
        ((eq format 'latex)
         (if (or (not desc) (equal 0 (search "autocite:" desc)))
               (format "\\autocite{%s}" path)
           (format "\\autocite[%s]{%s}" desc path)
  )))))

  (org-add-link-type
   "footcite" 'ebib
   (lambda (path desc format)
     (cond
      ((eq format 'latex)
       (if (or (not desc) (equal 0 (search "footcite:" desc)))
           (format "\\footcite{%s}" path)
         (format "\\footcite[%s]{%s}" desc path)
         )))))

  (org-add-link-type
   "fullcite" 'ebib
   (lambda (path desc format)
     (cond
      ((eq format 'latex)
       (if (or (not desc) (equal 0 (search "fullcite:" desc)))
           (format "\\fullcite{%s}" path)
         (format "\\fullcite[%s]{%s}" desc path)
         )))))

  (org-add-link-type
   "citetitle" 'ebib
   (lambda (path desc format)
     (cond
      ((eq format 'latex)
       (if (or (not desc) (equal 0 (search "citetitle:" desc)))
           (format "\\citetitle{%s}" path)
         (format "\\citetitle[%s]{%s}" desc path)
         )))))

  (org-add-link-type
   "citetitles" 'ebib
   (lambda (path desc format)
     (cond
      ((eq format 'latex)
       (if (or (not desc) (equal 0 (search "citetitles:" desc)))
           (format "\\citetitles{%s}" path)
         (format "\\citetitles[%s]{%s}" desc path)
         )))))

  (org-add-link-type
     "headlessfullcite" 'ebib
     (lambda (path desc format)
       (cond
        ((eq format 'latex)
         (if (or (not desc) (equal 0 (search "headlessfullcite:" desc)))
               (format "\\headlessfullcite{%s}" path)
               (format "\\headlessfullcite[%s]{%s}" desc path)
  )))))
#+end_src

*** HTML export Settings
Create =html= files form the =org= sources, to help with documentation. To set up org-mode for publishing projects to HTML you will need to change these settings, as they apply only to the Starter Kit.

#+source: html-export-settings
#+begin_src emacs-lisp :tangle yes
  (setq org-publish-project-alist
         '(("org"
            :base-directory "~/.emacs.d/"
            :publishing-directory "/media/dgm/blue/documents/websites/esk/"
            :publishing-function org-html-publish-to-html
            :auto-sitemap t
            :sitemap-filename "index.org"
            :sitemap-title "Emacs Starter Kit for the Social Sciences: Documentation"
            :section-numbers t
            :table-of-contents t
            :html-head "<link rel=\"stylesheet\"
                   href=\"http://kieranhealy.org/css/org.css\"
                   type=\"text/css\"/>"            )))

  (setq org-html-postamble nil)

#+end_src

*** Babel Settings
    Configure org-mode so that when you edit source code in an indirect buffer (with C-c '), the buffer is opened in the current window. That way, your window organization isn't broken when switching.

Disabled as it is in =starter-kit-org.org=

    #+source: orgmode-indirect-buffer-settings
    #+begin_src emacs-lisp :tangle no
;;      (setq org-src-window-setup 'current-window)
    #+end_src

** DGM customization

*** COMMENT Customizations from Ista Zahn: 
Check "Note taking and outlining (Org-mode)"  https://github.com/izahn/dotemacs

#+begin_src emacs-lisp
  (with-eval-after-load "org"
    (setq org-replace-disputed-keys t)
    (setq org-support-shift-select t)
    (setq org-export-babel-evaluate nil)

    ;; (setq org-startup-indented t)
    ;; increase imenu depth to include third level headings

    (setq org-imenu-depth 4)

    ;; Update images from babel code blocks automatically
    (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)

    ;; configure org-mode when opening first org-mode file
    ;; Load additional export formats
    (require 'ox-odt)
  ;;  (require 'ox-freemind)
    (require 'ox-bibtex)
  )
#+end_src



*** Local RefTeX Settings
Tell RefTeX where the bibliography files are.

#+srcname: local-reftex
#+begin_src emacs-lisp :tangle yes
    ;; Make RefTex able to find my local bib files
     (setq reftex-bibpath-environment-variables
;;     '("/media/dgm/blue/documents/bibs"))
     '("/home/dgm/texmf/bibtex/bib"))

    ;; Default bibliography
     (setq reftex-default-bibliography
     '("/media/dgm/blue/documents/bibs/socbib.bib"))
#+end_src

#+RESULTS: local-reftex
| /media/dgm/blue/documents/bibs/socbib.bib |

*** Local vc commands
    Run the vc shellscript before running xelatex with C-c c (instead
    of C-c C-c for regular compile). This assumes you're using the VC
    LaTeX package, have vc in your path, and have vc-awk in the
    directory you're working in.

    DGM: I comment it out as C-c c is used elsewhere for capture in org.

#+srcname: vc-command
#+begin_src emacs-lisp :tangle yes
;;    (fset 'run-vc-then-xelatex
;;    [?\M-! ?v ?c return ?\C-c ?\C-c return])
;;    (global-set-key (kbd "C-c c") 'run-vc-then-xelatex);; Run the VC command before running xelatex
;;    (fset 'run-vc-then-xelatex
;;    [?\M-! ?v ?c return ?\C-c ?\C-c return])
;;    (global-set-key (kbd "\C-c c") 'run-vc-then-xelatex)
#+end_src

    Or just run vc alone --- this is useful when writing LaTeX files
    using org-mode. (See the org-mode customizations below).

    dgm: I comment this out. I don't know how to make =vc= work as a command... I think you need to first make a =makefile=.  Plus I think =vc= is run automatically when =latexmk= is run thanks to the =\immediate\write18{sh ./vc}= line

#+source: vc-alone
#+begin_src emacs-lisp :tangle yes
;;  (global-set-key (kbd "\C-c v")
;;                      (lambda ()
;;                        (interactive)
;;                        (shell-command "vc")))
#+end_src

** Local Pandoc Support
A pandoc menu for markdown and tex files.
#+src-name: pandoc_mode
#+begin_src emacs-lisp :tangle yes
  (load "pandoc-mode")
  (add-hook 'markdown-mode-hook 'pandoc-mode)
  (add-hook 'TeX-mode-hook 'pandoc-mode)
  (add-hook 'pandoc-mode-hook 'pandoc-load-default-settings)
  (global-set-key (kbd "C-c C-p") 'pandoc-main-hydra/body)
#+end_src

#+RESULTS:
: pandoc-main-hydra/body

** Local Polymode Support
Polymode is a new package that supports multiple modes inside a single buffer. It is aimed particularly at literate programming approaches and supports, e.g., R and markdown in a single =.Rmd= file. So it is very useful with knitr in R, given that ESS does not yet fully support =.Rmd= files.

#+source: Polymode
#+begin_src emacs-lisp :tangle yes
  (require 'poly-R)
  (require 'poly-markdown)
  ;;; polymode + markdown
  (add-to-list 'auto-mode-alist '("\\.md" . poly-markdown-mode))

  ;;; polymode + R
  (add-to-list 'auto-mode-alist '("\\.Snw" . poly-noweb+r-mode))
  (add-to-list 'auto-mode-alist '("\\.Rnw" . poly-noweb+r-mode))
  (add-to-list 'auto-mode-alist '("\\.Rmd" . poly-markdown+r-mode))

#+end_src

** Local iBuffer Settings
   Manage a lot of buffers easily with C-x C-b. Already set up
   elsewhere in the starter kit. Add local configuration here, e.g.,
   display categories.
#+srcname: iBuffer-custom
#+begin_src emacs-lisp :tangle yes
  (setq ibuffer-saved-filter-groups
      '(("home"
	 ("emacs-config" (or (filename . ".emacs.d")
			     (filename . "emacs-config")))
	 ("Org" (or (mode . org-mode)
		    (filename . "OrgMode")))
	 ("Web Dev" (or (mode . html-mode)
			(mode . css-mode)))
	 ("Magit" (name . "\*magit"))
	 ("ESS" (mode . ess-mode))
         ("LaTeX" (mode . latex-mode))
	 ("Help" (or (name . "\*Help\*")
		     (name . "\*Apropos\*")
		     (name . "\*info\*"))))))

        (add-hook 'ibuffer-mode-hook
	             '(lambda ()
	             (ibuffer-switch-to-saved-filter-groups "home")))
       (setq ibuffer-show-empty-filter-groups nil)
       (setq ibuffer-expert t)
       (add-hook 'ibuffer-mode-hook
       '(lambda ()
       (ibuffer-auto-mode 1)
       (ibuffer-switch-to-saved-filter-groups "home")))
#+end_src


** IRC
Sometimes useful for getting help on R or Emacs.
#+source: rirc-configuration
#+begin_src emacs-lisp :tangle yes
  ;; connect to irc on invocation but don't autojoin any channels (require 'rcirc)
;;  (add-to-list 'rcirc-server-alist
;;                       '("irc.freenode.net")) ;; this code stopped working after my customizations following the mini emacs guide
(setq rcirc-server-alist
      '(("irc.freenode.net" :channels ("#emacs" "#python" "#sml" "#nasm" "#gcc"))))
#+end_src
** Final Custom elements
Some last tweaks.

#+srcname: final-custom
#+begin_src emacs-lisp :tangle yes
  ;; minimize fringe
  (setq-default indicate-empty-lines nil)

  ;; Add keybindings for commenting regions of text
  (global-set-key (kbd "C-c ;") 'comment-or-uncomment-region)
  (global-set-key (kbd "M-'") 'comment-or-uncomment-region)

  ;; Base dir
  (cd "~/")

  ;; custom variables kludge. Why can't I get these to work via setq?
  (custom-set-variables
  ;; custom-set-variables was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
  '(LaTeX-XeTeX-command "xelatex -synctex=1")
  '(TeX-engine (quote xetex))
  ;; '(TeX-view-program-list (quote (("Skim" "/Applications/Skim.app/Contents/SharedSupport/displayline %n %o %b"))))
  ;; '(TeX-view-program-selection (quote (((output-dvi style-pstricks) "dvips and gv") (output-dvi "xdvi") (output-pdf "Skim") (output-html "xdg-open"))))
  '(blink-cursor-mode nil)
  '(text-mode-hook (quote (text-mode-hook-identify)))
  )
#+end_src

#+RESULTS: final-custom

* dgm's own customizations of emacs appearance
** GROUP: Convenience -> Linum

Next tip from http://tuhdo.github.io/emacs-tutor3.html
It enables linum only in programming modpes

#+srcname: line-numbering
#+begin_src emacs-lisp :tangle yes
 (add-hook 'prog-mode-hook 'linum-mode)
#+end_src

#+RESULTS: line-numbering
| linum-mode | (lambda nil (highlight-symbol-mode)) | highlight-numbers-mode | clean-aindent-mode |

** GROUP: Convenience -> Whitespace

Whenever you create useless whitespace, the whitespace is highlighted

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))

;; activate whitespace-mode to view all whitespace characters
(global-set-key (kbd "C-c w") 'whitespace-mode)
#+END_SRC    

#+RESULTS:
: whitespace-mode


*** iedit mode
Check this post: https://www.masteringemacs.org/article/iedit-interactive-multi-occurrence-editing-in-your-buffer

#+begin_src emacs-lisp :tangle yes
(require 'iedit)

;; activate this function by Mickey Petersen if you wish to use iedit only in current function and not all across the buffer.
;; (defun iedit-dwim (arg)
;;   "Starts iedit but uses \\[narrow-to-defun] to limit its scope."
;;   (interactive "P")
;;   (if arg
;;       (iedit-mode)
;;     (save-excursion
;;       (save-restriction
;;         (widen)
;;         ;; this function determines the scope of `iedit-start'.
;;         (if iedit-mode
;;             (iedit-done)
;;           ;; `current-word' can of course be replaced by other
;;           ;; functions.
;;           (narrow-to-defun)
;;           (iedit-start (current-word) (point-min) (point-max)))))))

(global-set-key (kbd "C-;") 'iedit-dwim)
#+end_src

#+RESULTS:
: iedit-dwim




#+srcname: python-customization
#+begin_src emacs-lisp :tangle yes
;; dgm's customizations of python
(elpy-enable)
(require 'live-py-mode)
(add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
;; (elpy-use-ipython)
;; (elpy-use-ipython "ipython3") ;; error "elpy-use-ipython is deprecated; see https://elpy.readthedocs.io/en/latest/ide.html#interpreter-setup")


;; tip from https://github.com/jorgenschaefer/elpy/issues/992
;; to correct IPython 5's new prompt behavior that spitted out lots of nonsense and unreadeable characters as if it was a binary file
(setenv "IPY_TEST_SIMPLE_PROMPT" "1")
(setq python-shell-interpreter "ipython"
      python-shell-interpreter-args "-i")


;; tips from: "Emacs - the Best Python Editor?" at https://realpython.com/blog/python/emacs-the-best-python-editor/
;; Elpy comes with =flymake= by default to support syntax checking. However =flycheck= gives realtime syntax checking.
;; But =flycheck= slows emacs to death, so I disable it!
;; (when (require 'flycheck nil t)
;;  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
;;  (add-hook 'elpy-mode-hook 'flycheck-mode))

;; Now if we make pep8 errors when we save the file the errors will be corrected automatically
(require 'py-autopep8)
(add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)


;; https://github.com/jorgenschaefer/elpy/issues/979
   ;; For elpy
;; (setq elpy-rpc-python-command "python3")
;; For interactive shell
   ;; (setq python-shell-interpreter "python3")

(add-to-list 'exec-path (expand-file-name "~/.local/bin"))

;; Yuksel says there is a bug in =elpy= mode so that it conflicts with yasnippet expansion. He proposes this (see: https://www.youtube.com/watch?v=0kuCeS-mfyc)
(define-key yas-minor-mode-map (kbd "C-c k") 'yas-expand)
;; (define-key global-map (kbd "C-;") 'iedit-mode)

;; not sure where this goes, but I guess I need it somewhere
;; (require 'jedi)

#+end_src

#+RESULTS: python-customization
: yas-expand

** =ggtags= customization from tuhdo

#+srcname: ggtags-customization
#+begin_src emacs-lisp :tangle yes
(add-hook 'c-mode-common-hook
    (lambda ()
      (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
  (ggtags-mode 1))))
#+end_src

#+RESULTS: ggtags-customization
| lambda | nil | (when (derived-mode-p (quote c-mode) (quote c++-mode) (quote java-mode) (quote asm-mode)) (ggtags-mode 1)) |

#+RESULTS:
| lambda | nil | (when (derived-mode-p (quote c-mode) (quote c++-mode) (quote java-mode) (quote asm-mode)) (ggtags-mode 1)) |


*** mu4e-conversation
- Found this stuff here: http://cestlaz.github.io/posts/using-emacs-49-mu4e-conversation/#.W4xUEK0yreQ

#+BEGIN_SRC emacs-lisp :tangle yes
;;(use-package mu4e-conversation
;; :ensure t
;;)

;;(with-eval-after-load 'mu4e (require 'mu4e-conversation))
;;(global-mu4e-conversation-mode)
#+END_SRC

#+RESULTS:

** GROUP: Editing -> Editing Basics from http://tuhdo.github.io/emacs-tutor3.html

#+srcname: ring-max
#+BEGIN_SRC emacs-lisp :tangle yes
(setq global-mark-ring-max 5000     ; increase mark ring to contain 5000 entries
      mark-ring-max 5000            ; increase kill ring to contain 5000 entries
      mode-require-final-newline t) ; add a newline to end of file
#+END_SRC

#+RESULTS: ring-max
: t

#+RESULTS:
: 5000

#+srcname: killing
#+BEGIN_SRC emacs-lisp :tangle yes
(setq
 kill-ring-max 5000 ; increase kill-ring capacity
;; kill-whole-line t  ; if NIL, killwhole line and move the next line up / commented out by dgm as it might interere with kill-whole-line-or-region mode
)
#+END_SRC

#+RESULTS: killing
: t

#+RESULTS:
: t

#+srcname: tab-width
#+BEGIN_SRC emacs-lisp :tangle yes
;; default to 4 visible spaces to display a tab
(setq-default tab-width 4)
#+END_SRC

#+RESULTS: tab-width
: 4

#+RESULTS:
: newline-and-indent

From https://github.com/pashinin/workgroups2 and http://tuhdo.github.io/emacs-tutor3.html

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (require 'workgroups2)

  ;; Change workgroups session file
  ;; (setq wg-session-file "~/.emacs.d/.emacs_workgroups")
  ;; (wg-find-session-file "~/.emacs.d/.emacs_workgroups") ;; for emacs to load this file on startup... but it doesn't work... don't know why...

  ;; Set your own keyboard shortcuts to reload/save/switch WGs:
  ;; "s" == "Super" or "Win"-key, "S" == Shift, "C" == Control
  ;; (global-set-key (kbd "<pause>")     'wg-reload-session)
  ;; (global-set-key (kbd "C-S-<pause>") 'wg-save-session)
  ;; (global-set-key (kbd "s-z")         'wg-switch-to-workgroup)
  ;; (global-set-key (kbd "s-/")         'wg-switch-to-previous-workgroup)

  ;; What to do on Emacs exit / workgroups-mode exit?
  ;; (setq wg-emacs-exit-save-behavior           'save)      ; Options: 'save 'ask nil
  ;; (setq wg-workgroups-mode-exit-save-behavior 'save)      ; Options: 'save 'ask nil

  ;; (workgroups-mode 1)   ; put this one at the bottom of .emacs
#+END_SRC

#+RESULTS:

#+srcname: whitespace
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'diff-mode-hook (lambda ()
                              (setq-local whitespace-style
                                          '(face
                                            tabs
                                            tab-mark
                                            spaces
                                            space-mark
                                            trailing
                                            indentation::space
                                            indentation::tab
                                            newline
                                            newline-mark))
                              (whitespace-mode 1)))
#+END_SRC

#+RESULTS: whitespace
| lambda | nil | (setq-local whitespace-style (quote (face tabs tab-mark spaces space-mark trailing indentation::space indentation::tab newline newline-mark)))                        | (whitespace-mode 1) |
| lambda | nil | (set (make-local-variable (quote whitespace-style)) (quote (face tabs tab-mark spaces space-mark trailing indentation::space indentation::tab newline newline-mark))) | (whitespace-mode 1) |

#+RESULTS:
| lambda | nil | (setq-local whitespace-style (quote (face tabs tab-mark spaces space-mark trailing indentation::space indentation::tab newline newline-mark))) | (whitespace-mode 1) |


Attach multiple files to mu4e email message. (Tip from http://www.djcbsoftware.nl/code/mu/mu4e/Attaching-files-with-dired.html).


#+BEGIN_SRC emacs-lisp :tangle yes
(require 'gnus-dired)
;; make the `gnus-dired-mail-buffers' function also work on
;; message-mode derived modes, such as mu4e-compose-mode
(defun gnus-dired-mail-buffers ()
  "Return a list of active message buffers."
  (let (buffers)
    (save-current-buffer
      (dolist (buffer (buffer-list t))
        (set-buffer buffer)
        (when (and (derived-mode-p 'message-mode)
                (null message-sent-message-via))
          (push (buffer-name buffer) buffers))))
    (nreverse buffers)))

(setq gnus-dired-mail-mode 'mu4e-user-agent)
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
#+END_SRC

#+RESULTS:
| turn-on-gnus-dired-mode |



=volatile= makes so that when you yank (paste) something, the yanked (pasted) region will be highlighted.
See http://tuhdo.github.io/emacs-tutor3.html

#+srcname: volatile
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'volatile-highlights)
(volatile-highlights-mode t)
#+END_SRC

#+RESULTS: volatile
: t

#+RESULTS:
: t



#+srcname: clean-indent
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'clean-aindent-mode)
(add-hook 'prog-mode-hook 'clean-aindent-mode)

 (defun my-pkg-init()
   (electric-indent-mode -1)  ; no electric indent, auto-indent is sufficient
   (clean-aindent-mode t)
   (setq clean-aindent-is-simple-indent t)
   (define-key global-map (kbd "RET") 'newline-and-indent))
 (add-hook 'after-init-hook 'my-pkg-init)
#+END_SRC

#+RESULTS: clean-indent
| my-pkg-init | global-flycheck-mode | global-company-mode | package--save-selected-packages | x-wm-set-size-hint | table--make-cell-map |

undo-tree set up from http://pragmaticemacs.com/emacs/advanced-undoredo-with-undo-tree/
More info here: https://www.emacswiki.org/emacs/UndoTree

#+srcname: undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'undo-tree)
;;turn on everywhere
(global-undo-tree-mode 1)
;; make ctrl-z undo
(global-set-key (kbd "C-z") 'undo)
;; make ctrl-Z redo
(defalias 'redo 'undo-tree-redo)
(global-set-key (kbd "C-S-z") 'redo)
#+END_SRC

#+RESULTS: undo-tree
: redo

#+srcname: file-revert
#+BEGIN_SRC emacs-lisp :tangle yes
;; update any change made on file to the current buffer
(global-auto-revert-mode)
#+END_SRC

#+RESULTS:
: t


#+srcname: fill-column
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default fill-column 72)
#+END_SRC

#+RESULTS: fill-column
: 72

#+RESULTS:
: 39051

#+srcname: ibuffer
#+BEGIN_SRC emacs-lisp :tangle yes
;; always display ibuffer in another window
(setq ibuffer-use-other-window t)
#+END_SRC

#+RESULTS: ibuffer
: t

#+RESULTS:
: t

#+srcname: company
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'after-init-hook 'global-company-mode)
#+END_SRC


#+RESULTS:
| global-flycheck-mode | global-company-mode | package--save-selected-packages | x-wm-set-size-hint |


#+srcname: duplicate
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'duplicate-thing)
(global-set-key (kbd "M-D") 'duplicate-thing)
#+END_SRC

#+RESULTS: duplicate
: duplicate-thing

#+RESULTS:
: duplicate-thing

#+srcname: ibuffer-vc
#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'ibuffer-hook
          (lambda ()
            (ibuffer-vc-set-filter-groups-by-vc-root)
            (unless (eq ibuffer-sorting-mode 'alphabetic)
              (ibuffer-do-sort-by-alphabetic))))

(setq ibuffer-formats
      '((mark modified read-only vc-status-mini " "
              (name 18 18 :left :elide)
              " "
              (size 9 -1 :right)
              " "
              (mode 16 16 :left :elide)
              " "
              (vc-status 16 16 :left)
              " "
              filename-and-process)))
#+END_SRC

#+RESULTS: ibuffer-vc
| mark | modified | read-only | vc-status-mini |   | (name 18 18 :left :elide) |   | (size 9 -1 :right) |   | (mode 16 16 :left :elide) |   | (vc-status 16 16 :left) |   | filename-and-process |

#+srcname: dired+
#+BEGIN_SRC emacs-lisp :tangle yes
;; (require 'dired+)

;; copied  by dgm from: http://emacs-leuven.readthedocs.io/en/latest/?badge=latest

    ;; Don't hide details in Dired.
;;    (setq diredp-hide-details-initially-flag nil)

    ;; Don't display the next Dired buffer the same way as the last.
;;    (setq diredp-hide-details-propagate-flag nil)

    ;; Don't wrap "next" command around to buffer beginning.
    ;; (setq diredp-wrap-around-flag nil)

    ;; Dired `find-file' commands reuse directories.
    ;; (diredp-toggle-find-file-reuse-dir 1)

    ;; Up, reusing Dired buffers.
    ;; (define-key dired-mode-map (kbd "C-x C-j")
    ;;  #'diredp-up-directory-reuse-dir-buffer)

;; tips from Ista Zahn. Not sure if they require dired+
;; https://github.com/izahn/dotemacs

;;; Dired and Dired+ configuration
(add-hook 'dired-mode-hook
          (lambda()
            (diff-hl-dired-mode)
            (diff-hl-margin-mode)))

;; set dired listing options
(if (eq system-type 'gnu/linux)
    (setq dired-listing-switches "-alDhp"))

;; make sure dired buffers end in a slash so we can identify them easily
(defun ensure-buffer-name-ends-in-slash ()
  "change buffer name to end with slash"
  (let ((name (buffer-name)))
    (if (not (string-match "/$" name))
        (rename-buffer (concat name "/") t))))
(add-hook 'dired-mode-hook 'ensure-buffer-name-ends-in-slash)
(add-hook 'dired-mode-hook
          (lambda()
             (setq truncate-lines 1)))

;; open files in external programs
;; (from http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html
;; consider replacing with https://github.com/thamer/runner
(defun xah-open-in-external-app (&optional file)
  "Open the current file or dired marked files in external app.

The app is chosen from your OS's preference."
  (interactive)
  (let (doIt
        (myFileList
         (cond
          ((string-equal major-mode "dired-mode")
           (dired-get-marked-files))
          ((not file) (list (buffer-file-name)))
          (file (list file)))))
    (setq doIt (if (<= (length myFileList) 5)
                   t
                 (y-or-n-p "Open more than 5 files? ")))
    (when doIt
      (cond
       ((string-equal system-type "windows-nt")
        (mapc
         (lambda (fPath)
           (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)))
         myFileList))
       ((string-equal system-type "darwin")
        (mapc
         (lambda (fPath)
           (shell-command (format "open \"%s\"" fPath)))
         myFileList))
       ((string-equal system-type "gnu/linux")
        (mapc
         (lambda (fPath)
           (let ((process-connection-type nil))
             (start-process "" nil "xdg-open" fPath))) myFileList))))))
;; use zip/unzip to compress/uncompress zip archives
(with-eval-after-load "dired-aux"
  (add-to-list 'dired-compress-file-suffixes
               '("\\.zip\\'" "" "unzip"))
  ;; open files from dired with "E"
  (define-key dired-mode-map (kbd "E") 'xah-open-in-external-app))
#+END_SRC

#+RESULTS: dired+
: xah-open-in-external-app


Set emacs to open Bookmark+ on start. From Xah Emacs. Disabled now that I use =Dashboard=

#+srcname: bookmarks
#+BEGIN_SRC emacs-lisp :tangle no
  ;; included by dgm
;;   (setq inhibit-splash-screen t)
  ;; (require 'bookmark+) ;; no longer available in MELPA
;;  (bookmark-bmenu-list)
;;  (switch-to-buffer "*Bookmark List*")
  ;; '(initial-buffer-choice "*Bookmark List*")
  ;; (setq initial-buffer-choice "*Bookmark List*")
#+END_SRC


#+RESULTS: bookmarks


#+srcname: custom-setup
#+BEGIN_SRC emacs-lisp :tangle no
;;    Load the files in CustomDir using mapc:
;; (mapc 'load (directory-files "~/.emacs.d/customDir" t ".*\.el"))
;; (add-to-list 'load-path "~/.emacs.d/customDir/")
;; (require 'setup-programming)
#+END_SRC



#+srcname: diff-hl
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-diff-hl-mode)
  (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
#+END_SRC

#+RESULTS: diff-hl
| diff-hl-dired-mode |


I disable this as flycheck makes emacs too slow.
#+srcname: flycheck-tip
#+BEGIN_SRC emacs-lisp :tangle yes
;;  (require 'flycheck-tip)
;;  (define-key global-map (kbd "\C-c \C-n") 'flycheck-tip-cycle)
;;  (setq flycheck-display-errors-function 'ignore)
#+END_SRC

#+RESULTS: flycheck-tip
: ignore

#+RESULTS:
: ignore


For now, I deactivate the golden-ratio mode because it distract me too much.

#+srcname: golden-ratio
#+BEGIN_SRC emacs-lisp :tangle no
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: golden-ratio                         ;;
  ;;                                               ;;
  ;; GROUP: Environment -> Windows -> Golden Ratio ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;; activate for helm when helm is installed
  ;; (require 'golden-ratio)

  ;; (add-to-list 'golden-ratio-exclude-modes "ediff-mode")
  ;; (add-to-list 'golden-ratio-exclude-modes "helm-mode")
  ;; (add-to-list 'golden-ratio-exclude-modes "dired-mode")
  ;; (add-to-list 'golden-ratio-exclude-modes "ess-mode")

  ;; I dont want the golden ratio with the Helm window
  ;;  (defun pl/helm-alive-p ()
  ;;   (if (boundp 'helm-alive-p)
  ;;       (symbol-value 'helm-alive-p)))

  ;;  (add-to-list 'golden-ratio-inhibit-functions 'pl/helm-alive-p)

  ;; do not enable golden-ratio in theses modes
;;   (setq golden-ratio-exclude-modes '("ediff-mode"
;;                                      "gud-mode"
;;                                      "gdb-locals-mode"
;;                                      "gdb-registers-mode"
;;                                      "gdb-breakpoints-mode"
;;                                      "gdb-threads-mode"
;;                                      "gdb-frames-mode"
;;                                      "gdb-inferior-io-mode"
;;                                      "gud-mode"
;;                                      "gdb-inferior-io-mode"
;;                                      "gdb-disassembly-mode"
;;                                      "gdb-memory-mode"
;;   ;;                                   "magit-log-mode"
;;   ;;                                   "magit-reflog-mode"
;;   ;;                                   "magit-status-mode"
;;                                      "IELM"
;;                                      "eshell-mode"
;;                                      "dired-mode"
;;                                      "helm-mode"
;;                                      "ess-mode"))
  ;; delete "dired-mode"  from the above list if you want golden-ratio to apply to helm

;;   (golden-ratio-mode)
#+END_SRC

#+RESULTS: golden-ratio :tangle no


I disable this as it is dealt with in -misc.org
#+srcname: frame-title
#+BEGIN_SRC emacs-lisp :tangle no
;; more useful frame title, that show either a file or a
;; buffer name (if the buffer isn't visiting a file)
;; taken from prelude-ui.el
;; (setq frame-title-format
;;      '("" invocation-name " - " (:eval (if (buffer-file-name)
;;                                                    (abbreviate-file-name (buffer-file-name))
;;                                                  "%b"))))
#+END_SRC

#+RESULTS: frame-title
|   | invocation-name | - | (:eval (if (buffer-file-name) (abbreviate-file-name (buffer-file-name)) %b)) |

#+RESULTS:
|   | invocation-name | - | (:eval (if (buffer-file-name) (abbreviate-file-name (buffer-file-name)) %b)) |


#+srcname: highlight-numbers-and-symbols
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'highlight-numbers-mode)

(require 'highlight-symbol)

(highlight-symbol-nav-mode)

(add-hook 'prog-mode-hook (lambda () (highlight-symbol-mode)))
(add-hook 'org-mode-hook (lambda () (highlight-symbol-mode)))

(setq highlight-symbol-idle-delay 0.2
      highlight-symbol-on-navigation-p t)

(global-set-key [(control shift mouse-1)]
                (lambda (event)
                  (interactive "e")
                  (goto-char (posn-point (event-start event)))
                  (highlight-symbol-at-point)))

(global-set-key (kbd "M-n") 'highlight-symbol-next)
(global-set-key (kbd "M-p") 'highlight-symbol-prev)
#+END_SRC

#+RESULTS: highlight-numbers-and-symbols
: highlight-symbol-prev


#+srcname: info+
#+BEGIN_SRC emacs-lisp :tangle yes
;; (require 'info+) no longer available in MELPA
#+END_SRC

#+RESULTS: info+

#+srcname: discover-my-major
#+BEGIN_SRC emacs-lisp :tangle yes
;; A quick major mode help with discover-my-major
(global-unset-key (kbd "C-h h"))        ; original "\C-h h" displays "hello world" in different languages
(define-key 'help-command (kbd "h m") 'discover-my-major)
#+END_SRC

#+RESULTS: discover-my-major
: discover-my-major

#+srcname: rainbow-mode
#+BEGIN_SRC emacs-lisp :tangle yes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PACKAGE: rainbow-mode              ;;
;;                                    ;;
;; GROUP: Help -> Rainbow             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(add-hook 'html-mode-hook 'rainbow-mode)
(add-hook 'css-mode-hook 'rainbow-mode)

;;R-mode-hook runs when you open a new source buffer, so anything you put in that will only effect your source buffers.inferior-ess-mode-hook runs when you start an R console, so anything in there should only apply to the console buffer and not the source.
(add-hook 'R-mode-hook 'rainbow-mode)
(add-hook 'inferior-ess-mode-hook 'rainbow-mode)

#+END_SRC

#+RESULTS:
| rainbow-mode | turn-on-auto-fill | (lambda nil (local-set-key [C-up] (quote comint-previous-input)) (local-set-key [C-down] (quote comint-next-input))) | ess-S-mouse-me-menu-commands | turn-on-font-lock |




#+srcname: nyan-mode
#+BEGIN_SRC emacs-lisp :tangle no
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PACKAGE: nyan-mode                    ;;
;;                                       ;;
;; GROUP: Environment -> Frames -> Nyan  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; only turn on if a window system is available
;; this prevents error under terminal that does not support X
(case window-system
  ((x w32) (nyan-mode)))
#+END_SRC

** =projectile=

#+srcname: projectile
#+BEGIN_SRC emacs-lisp :tangle yes
    ;; Projectile
    (require 'projectile)

    ;; https://github.com/bbatsov/projectile/issues/1183
    ;; trying to fix slow behaviour of emacs
    (setq projectile-mode-line
         '(:eval (format " Projectile[%s]"
                        (projectile-project-name))))

    (projectile-global-mode)

    ;; from https://github.com/bbatsov/projectile#usage
    ;; (projectile-mode +1) ;; don't know what this does.
    ;; (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

    ;; nota que todo funciona menos la que usa la =p=, no se por que
    (define-key projectile-mode-map [?\s-d] 'projectile-find-dir)
    ;; (define-key projectile-mode-map [?\s-p] 'projectile-switch-project)
    ;; (define-key projectile-mode-map [?\s-f] 'projectile-find-file) ;; used now with helm-find-files and exwm
    ;; (define-key projectile-mode-map [?\s-g] 'projectile-grep)      ;; used now with helm-find-files and exwm

    ;; (setq projectile-enable-caching t)
    (setq projectile-enable-caching nil) ; see https://emacs.stackexchange.com/questions/2164/projectile-does-not-show-all-files-in-project

    (use-package helm-projectile
      :ensure t
      :after helm-mode
      :commands helm-projectile
    ;;   :bind ("C-c p h" . helm-projectile)
    )

    (setq projectile-completion-system 'helm)
    (helm-projectile-on)   ;;; creo que no hace falta tras decir =ensure t= in use-package.
    (setq projectile-switch-project-action 'helm-projectile)

  ;; from https://projectile.readthedocs.io/en/latest/usage/
  ;; You can go one step further and set a list of folders which Projectile is automatically going to check for projects:

  (setq projectile-project-search-path '("~/.emacs.d/"
;;                                         "~/.oh-my-zsh/"
                                         "~/texmf/"
                                         "~/Dropbox/gtd/"))
;;                                         "/media/dgm/blue/documents/proyectos/mtj/"
;;                                         "/media/dgm/blue/documents/dropbox/"
;;                                         "/media/dgm/blue/documents/templates"))

#+END_SRC

#+RESULTS: projectile
| ~/.emacs.d/ | ~/texmf/ | ~/Dropbox/gtd/ |

#+RESULTS: helm
| ~/.emacs.d/ | ~/texmf/ | ~/Dropbox/gtd/ |

#+RESULTS:
: t


#+srcname: spaceline
#+BEGIN_SRC emacs-lisp :tangle yes
;; (require 'spaceline-config)
;; (spaceline-emacs-theme)
;; (spaceline-helm-mode)
#+END_SRC

#+RESULTS: spaceline
: t


#+srcname: powerline
#+begin_src emacs-lisp :tangle no
;;  (require 'powerline)
;;  (powerline-default-theme)
#+end_src

#+srcname: modeline
#+begin_src emacs-lisp :tangle yes
;; (require 'smart-mode-line)
;;       (require 'smart-mode-line-powerline-theme)
;;       (sml/apply-theme 'powerline)


;; (setq powerline-arrow-shape 'curve)
;; (setq powerline-default-separator-dir '(right . left))
;; (setq sml/theme 'powerline)
;; (setq sml/mode-width 0)
;; (setq sml/name-width 20)
;; (rich-minority-mode 1)
;; (setf rm-blacklist "")
;; (sml/setup)


;; (if (require 'smart-mode-line nil 'noerror)
;;     (progn
;;       (setq sml/name-width 20)
;;       (setq sml/mode-width 'full)
;;       (setq sml/shorten-directory t)
;;       (setq sml/shorten-modes t)
;;
;;       (rich-minority-mode 1)
;; ;;      (setq rm-blacklist '(" GitGutter" " MRev" " company" " mate" " Projectile"))
;;
;;       (if after-init-time
;;         (sml/setup)
;;         (add-hook 'after-init-hook 'sml/setup))))
;;
      ;; Alternatives:
      ;; (sml/apply-theme 'powerline)
      ;; (sml/apply-theme 'dark)
      ;; (sml/apply-theme 'light)
      ;; (sml/apply-theme 'respectful)
      ;; (sml/apply-theme 'automatic)

;;      (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/" ":DB:"))
;;      (add-to-list 'sml/replacer-regexp-list '("^~/Code/" ":CODE:"))
;;      (add-to-list 'sml/replacer-regexp-list '("^:CODE:investor-bridge" ":IB:"))
;;      (add-to-list 'sml/replacer-regexp-list '("^~/.*/lib/ruby/gems" ":GEMS" ))))
#+end_src

#+RESULTS: modeline
: dark

#+RESULTS: emacs-lisp
: dark


#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'load-path "/home/dgm/.emacs.d/src/ado-mode-1.15.1.4/lisp")
(require 'ado-mode)
#+END_SRC

#+RESULTS:
: ado-mode


#+BEGIN_SRC emacs-lisp :tangle yes
;;   (setq org-default-notes-file (concat org-directory "/notes.org")) ;; i disable this to see if I can choose between notes and tasks.
;;    this is not working for some reason: (define-key global-map "\C-c c" 'org-capture)
  (define-key global-map (kbd "C-c c") 'org-capture)

;; other bindings from http://orgmode.org/manual/Activation.html
;;     (global-set-key "\C-c l" 'org-store-link)  este binding ya estaba listo
;;     (global-set-key "\C-c a" 'org-agenda) ;; este binding puesto así no funcionaba
;;    (global-set-key "\C-c b" 'org-iswitchb);; este binding puesto así no funcionaba

  (define-key global-map (kbd "C-c a") 'org-agenda)
  (define-key global-map (kbd "C-c b") 'org-iswitchb)


  ;; code by sacha chua: http://sachachua.com/blog/2015/02/learn-take-notes-efficiently-org-mode/

;; commented out on 30 sept 2017 because i'm changing from sacha's organization to https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html
;;  (set-register ?o (cons 'file "/media/dgm/blue/documents/dropbox/org/notes.org"))
;;  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))

  ;; (setq org-completion-use-ido t)  ;; i think I don't need this because somehow helm is doing the job
#+END_SRC

#+RESULTS:
: ((org-agenda-files :maxlevel . 6))



Shortcuts that should work in Org but do not. Besides, they used to be bound to windmove but no more because I'd rather use =ace-window=

#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key global-map (kbd "S-<left>") 'org-timestamp-down-day)
  (define-key global-map (kbd "S-<right>") 'org-timestamp-up-day)
  (define-key global-map (kbd "S-<up>") 'org-timestamp-up)
  (define-key global-map (kbd "S-<down>") 'org-timestamp-down)
#+END_SRC

#+RESULTS:


Make calendar start on Monday instead of Sunday

#+BEGIN_SRC emacs-lisp :tangle yes
(setq calendar-week-start-day 1)
#+END_SRC


#+RESULTS:
: 1

Try and make =ox-twbs= work

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'ox-twbs)
#+END_SRC


*** Which-key
This mode shows a keymap when an incomplete command is entered. It is especially useful for families of commands with a prefix, e.g., =C-c C-o= for outline-mode commands, or ==C-c C-v= for org-babel commands. Just start typing your command and pause if you want a hint.

tip from: https://github.com/izahn/dotemacs

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'which-key)
(which-key-mode)
#+END_SRC


*** General REPL (comint) config
tip from: https://github.com/izahn/dotemacs

Many programs using REPLs are derived from comint-mode, so we can affect all of them by changing comint-mode settings. Here we disable line wrapping and ask programs to echo the input.

Load eval-in-repl for bash, elisp, and python interaction.

#+BEGIN_SRC emacs-lisp :tangle yes
;; require the main file containing common functions
(require 'eval-in-repl)
(setq comint-process-echoes t)

;; truncate lines in comint buffers
(add-hook 'comint-mode-hook
          (lambda()
            (setq truncate-lines 1)))

;; Scroll down for input and output
(setq comint-scroll-to-bottom-on-input t)
(setq comint-scroll-to-bottom-on-output t)
(setq comint-move-point-for-output t)
#+END_SRC


*** Run R in emacs (ESS)
tip from: https://github.com/izahn/dotemacs

Support for R in Emacs is good, thanks to http://ess.r-project.org/. As with other programming languages this configuration enables completion via the tab key and code evaluation with C-ret. Many more features are provided by ESS, refer to http://ess.r-project.org/ for details.

#+begin_src emacs-lisp :tangle yes
  ;;;  ESS (Emacs Speaks Statistics)

;; ;; Start R in the working directory by default
;; (setq ess-ask-for-ess-directory nil)
;;
;; ;; Make sure ESS is loaded before we configure it
;; (autoload 'julia "ess-julia" "Start a Julia REPL." t)
;; (with-eval-after-load "ess-site"
;;   ;; disable ehoing input
;;   (setq ess-eval-visibly nil)
;;   ;; Start R in the working directory by default
;;   (setq ess-ask-for-ess-directory nil)
;;   ;; Use tab completion
;;   (setq ess-tab-complete-in-script t)
;;   ;; extra ESS stuff inspired by https://github.com/gaborcsardi/dot-emacs/blob/master/.emacs
;;   (ess-toggle-underscore nil)
;;   (defun my-ess-execute-screen-options (foo)
;;     "cycle through windows whose major mode is inferior-ess-mode and fix width"
;;     (interactive)
;;     (setq my-windows-list (window-list))
;;     (while my-windows-list
;;       (when (with-selected-window (car my-windows-list) (string= "inferior-ess-mode" ;; major-mode))
;;         (with-selected-window (car my-windows-list) (ess-execute-screen-options t)))
;;       (setq my-windows-list (cdr my-windows-list))))
;;   (add-to-list 'window-size-change-functions 'my-ess-execute-screen-options)
;;   (define-key ess-mode-map (kbd "<C-return>") ;; 'ess-eval-region-or-function-or-paragraph-and-step)
;;   ;; truncate long lines in R source files
;;   (add-hook 'ess-mode-hook
;;             (lambda()
;;               ;; don't wrap long lines
;;               (toggle-truncate-lines t)
;;               (outline-minor-mode t))))
#+end_src

Note: for me "C-return" does not work... Comento todo esto porque me temo que entra en conflicto con la costumization del gran Kieran Healy en =starter-kit-stats.org= donde veo que la evaluación está bound a =shift-return= and that works indeed for me.

*** emacs lisp REPL (ielm)
Tip from: https://github.com/izahn/dotemacs

If you want to get the most out of Emacs, you’ll eventually need to learn a little Emacs-lisp. This configuration helps by providing a standard C-ret evaluation key binding, and by providing completion with the tab key.

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load "elisp-mode"
  (require 'company-elisp)
  ;; ielm
  (require 'eval-in-repl-ielm)
  ;; For .el files
  (define-key emacs-lisp-mode-map "C-c C-c" 'eir-eval-in-ielm)
  (define-key emacs-lisp-mode-map (kbd "<C-return>") 'eir-eval-in-ielm)
  ;; For *scratch*
  (define-key lisp-interaction-mode-map "C-c C-c" 'eir-eval-in-ielm)
  (define-key emacs-lisp-mode-map (kbd "<C-return>") 'eir-eval-in-ielm)
  ;; For M-x info
  (define-key Info-mode-map "C-c C-c" 'eir-eval-in-ielm)
  ;; Set up completions
  (add-hook 'emacs-lisp-mode-hook
            (lambda()
              ;; make sure completion calls company-elisp first
              (require 'company-elisp)
              (setq-local company-backends
                          (delete-dups (cons 'company-elisp (cons 'company-files company-backends)))))))
#+end_src

#+RESULTS:
| (lambda nil (require (quote company-elisp)) (setq-local company-backends (delete-dups (cons (quote company-elisp) (cons (quote company-files) company-backends))))) | esk-remove-elc-on-save | run-starter-kit-coding-hook | turn-on-eldoc-mode |


*** Helm-bibtex

Helm-bibtex and ivy-bibtex allow you to search and manage your BibTeX bibliography. They both share the same generic backend, bibtex-completion, but one uses the Helm completion framework and the other Ivy as a front-end.

check titus: https://github.com/tmalsburg/helm-bibtex

A minimal configuration involves telling bibtex-completion where your bibliographies can be found:

#+begin_src emacs-lisp :tangle yes
(setq bibtex-completion-bibliography
      '("/media/dgm/blue/documents/bibs/socbib.bib"))

;; Bibtex-completion supports two methods for storing notes. It can either store all notes in one file or store notes in multiple files, one file per publication. In the first case, the customization variable bibtex-completion-notes-path has to be set to the full path of the notes file:

(setq bibtex-completion-notes-path "/media/dgm/blue/documents/dropbox/org/notes.org")

;; Symbols used for indicating the availability of notes and PDF files
(setq bibtex-completion-pdf-symbol "⌘")
(setq bibtex-completion-notes-symbol "✎")
#+end_src

And now the bit by Ista Zahn in tip from: https://github.com/izahn/dotemacs but modified to use helm instead of ivy.
This allows you to search your BibTeX files for references to insert into the current document. For it to work you will need to set `bibtex-completion-bibliography` to the location of your BibTeX files.
Initiate a citation search with ivy-bibtex, bound to C-c r.

#+begin_src emacs-lisp :tangle yes
(setq ivy-bibtex-default-action 'bibtex-completion-insert-citation)
(global-set-key (kbd "C-c r") 'helm-bibtex)
#+end_src

tip from titus for Helm-bibtex: I use the menu key as the prefix key for all helm commands and bind helm-bibtex to b. Helm-bibtex can then be started using <menu> b. It is also useful to bind helm-resume to <menu> in helm-command-map. With this binding, <menu> <menu> can be used to reopen the last helm search.


*** Demonstration tools (command-log-mode)
    tip from: https://github.com/izahn/dotemacs

=command-log-mode= is useful for giving emacs demonstrations/tutorials. It shows the keys you’ve pressed and the commands they called.

#+begin_src emacs-lisp :tangle yes
;;(setq command-log-mode-auto-show t)
;;(global-set-key (kbd "\C-x c l") 'global-command-log-mode)
#+end_src

#+RESULTS:
: global-command-log-mode

Good idea but it seems that I don't have the =command-log-mode=... ah, it's a package. i will install in future.

*** auto-complete
Following Drew advice on setting up emacs as a Python IDE (https://www.youtube.com/watch?v=6BlTGPsjGJk).

Gives basic auto completion for most programming modes. But doesn't know syntax. However, it has a nice interface for other packages providing completions like =jedi=.

For now I comment it out because following Drew's advice has meant that I've lost auto completion in elpy mode.

#+begin_src emacs-lisp :tangle yes
;; (require 'auto-complete-config)
;; (ac-config-default)

;; if you really like the menu
;;(setq ac-show-menu-immediately-on-auto-complete t)
#+end_src

#+RESULTS:
: t

*** Jedi configuration from Drew
Check Drew online: https://www.youtube.com/watch?v=6BlTGPsjGJk
This is basically his https://github.com/wernerandrew/jedi-starter/blob/master/jedi-starter.el

#+begin_src emacs-lisp :tangle yes

;; (load-file "/home/dgm/.emacs.d/src/jedi-starter.el")

;; ;; Global Jedi config vars
;;
;; (defvar jedi-config:use-system-python nil
;;   "Will use system python and active environment for Jedi server.
;; May be necessary for some GUI environments (e.g., Mac OS X)")
;;
;; (defvar jedi-config:with-virtualenv nil
;;   "Set to non-nil to point to a particular virtualenv.")
;;
;; (defvar jedi-config:vcs-root-sentinel ".git")
;;
;; (defvar jedi-config:python-module-sentinel "__init__.py")
;;
;; ;; Helper functions
;;
;; ;; Small helper to scrape text from shell output
;; (defun get-shell-output (cmd)
;;   (replace-regexp-in-string "[ \t\n]*$" "" (shell-command-to-string cmd)))
;;
;; ;; Ensure that PATH is taken from shell
;; ;; Necessary on some environments without virtualenv
;; ;; Taken from: http://stackoverflow.com/questions/8606954/path-and-exec-path-set-but-emacs-does-not-find-executable
;;
;; (defun set-exec-path-from-shell-PATH ()
;;   "Set up Emacs' `exec-path' and PATH environment variable to match that used by the user's shell."
;;   (interactive)
;;   (let ((path-from-shell (get-shell-output "$SHELL --login -i -c 'echo $PATH'")))
;;     (setenv "PATH" path-from-shell)
;;     (setq exec-path (split-string path-from-shell path-separator)))
;;
;;
;;   (require 'jedi)
;;
;; ;;  Costumization copied from https://www.youtube.com/watch?v=6BlTGPsjGJk
;; ;;  I think what follows is more robust
;; ;;  ;; Hook up to auto-complete
;; ;;  (add-to-list 'ac-sources 'ac-source-jedi-direct)
;; ;;  ;; Enable for python-mode
;; ;;  (add-hook 'python-mode-hook 'jedi:setup)
;;
;; ;;  (defvar jedi-config:with-virtualenv nil
;; ;;     "set to non-nil to point to a particular virtualenv.")
;;
;;
;; ;;  ;; Variables to help find the project root
;; ;;  (defvar jedi-config:vcs-root-sentinel ".git")
;; ;;  (defvar jedi-config:python-module-sentinel "__init__.py")
;; ;;
;; ;;  ;; Function to find project root given a buffer
;; ;;  (defun get-project-root (buf repo-type init-file)
;; ;;    (vc-find-root (expand-file-name (buffer-file-name buf)) repo-type))
;; ;;
;; ;;  (defvar jedi-config:find-root-function 'get-project-root)
;; ;;
;; ;;  ;; And call this on initialization
;; ;;  (defun current-buffer-project-root ()
;; ;;      (funcall jedi-config:find-root-function
;; ;;               (current-buffer)
;; ;;               jedi-config:vcs-root-sentinel
;; ;;               jedi-config:python-module-sentinel))
;;
;;
;; ;; costumization copied straight from https://github.com/wernerandrew/jedi-starter/blob/master/jedi-starter.el
;; ;; Alternative methods of finding the current project root
;;     ;; Method 1: basic
;;     (defun get-project-root (buf repo-file &optional init-file)
;;       "Just uses the vc-find-root function to figure out the project root.
;;        Won't always work for some directory layouts."
;;       (let* ((buf-dir (expand-file-name (file-name-directory (buffer-file-name buf))))
;; 	     (project-root (vc-find-root buf-dir repo-file)))
;; 	(if project-root
;; 	    (expand-file-name project-root)
;; 	  nil)))
;;
;;     ;; Method 2: slightly more robust
;;     (defun get-project-root-with-file (buf repo-file &optional init-file)
;;       "Guesses that the python root is the less 'deep' of either:
;;          -- the root directory of the repository, or
;;          -- the directory before the first directory after the root
;;             having the init-file file (e.g., '__init__.py'."
;;
;;       ;; make list of directories from root, removing empty
;;       (defun make-dir-list (path)
;;         (delq nil (mapcar (lambda (x) (and (not (string= x "")) x))
;;                           (split-string path "/"))))
;;       ;; convert a list of directories to a path starting at "/"
;;       (defun dir-list-to-path (dirs)
;;         (mapconcat 'identity (cons "" dirs) "/"))
;;       ;; a little something to try to find the "best" root directory
;;       (defun try-find-best-root (base-dir buffer-dir current)
;;         (cond
;;          (base-dir ;; traverse until we reach the base
;;           (try-find-best-root (cdr base-dir) (cdr buffer-dir)
;;                               (append current (list (car buffer-dir)))))
;;
;;          (buffer-dir ;; try until we hit the current directory
;;           (let* ((next-dir (append current (list (car buffer-dir))))
;;                  (file-file (concat (dir-list-to-path next-dir) "/" init-file)))
;;             (if (file-exists-p file-file)
;;                 (dir-list-to-path current)
;;               (try-find-best-root nil (cdr buffer-dir) next-dir))))
;;
;;          (t nil)))
;;
;;       (let* ((buffer-dir (expand-file-name (file-name-directory (buffer-file-name buf))))
;;              (vc-root-dir (vc-find-root buffer-dir repo-file)))
;;         (if (and init-file vc-root-dir)
;;             (try-find-best-root
;;              (make-dir-list (expand-file-name vc-root-dir))
;;              (make-dir-list buffer-dir)
;;              '())
;;           vc-root-dir))) ;; default to vc root if init file not given
;;
;;     ;; Set this variable to find project root
;;     (defvar jedi-config:find-root-function 'get-project-root-with-file)
;;
;;     (defun current-buffer-project-root ()
;;       (funcall jedi-config:find-root-function
;;                (current-buffer)
;;                jedi-config:vcs-root-sentinel
;;                jedi-config:python-module-sentinel))
;;
;;     (defun jedi-config:setup-server-args ()
;;       ;; little helper macro for building the arglist
;;       (defmacro add-args (arg-list arg-name arg-value)
;;         `(setq ,arg-list (append ,arg-list (list ,arg-name ,arg-value))))
;;       ;; and now define the args
;;       (let ((project-root (current-buffer-project-root)))
;;
;;         (make-local-variable 'jedi:server-args)
;;
;;         (when project-root
;;           (message (format "Adding system path: %s" project-root))
;;           (add-args jedi:server-args "--sys-path" project-root))
;;
;;         (when jedi-config:with-virtualenv
;;           (message (format "Adding virtualenv: %s" jedi-config:with-virtualenv))
;;           (add-args jedi:server-args "--virtual-env" jedi-config:with-virtualenv))))
;;
;;     ;; Use system python
;;     (defun jedi-config:set-python-executable ()
;;       (set-exec-path-from-shell-PATH)
;;       (make-local-variable 'jedi:server-command)
;;       (set 'jedi:server-command
;;            (list (executable-find "python") ;; may need help if running from GUI
;;                  (cadr default-jedi-server-command))))
;;
;;     ;; Now hook everything up
;;     ;; Hook up to autocomplete
;;     (add-to-list 'ac-sources 'ac-source-jedi-direct)
;;
;;     ;; Enable Jedi setup on mode start
;;     (add-hook 'python-mode-hook 'jedi:setup)
;;
;;     ;; Buffer-specific server options
;;     (add-hook 'python-mode-hook
;;               'jedi-config:setup-server-args)
;;     (when jedi-config:use-system-python
;;       (add-hook 'python-mode-hook
;;                 'jedi-config:set-python-executable))
;;
;;     ;; And custom keybindings
;;     (defun jedi-config:setup-keys ()
;;       (local-set-key (kbd "M-.") 'jedi:goto-definition)
;;       (local-set-key (kbd "M-,") 'jedi:goto-definition-pop-marker)
;;       (local-set-key (kbd "M-?") 'jedi:show-doc)
;;       (local-set-key (kbd "M-/") 'jedi:get-in-function-call))
;;
;;     ;; Don't let tooltip show up automatically
;;     (setq jedi:get-in-function-call-delay 10000000)
;;     ;; Start completion at method dot
;;     (setq jedi:complete-on-dot t)
;;     ;; Use custom keybinds
;;     (add-hook 'python-mode-hook 'jedi-config:setup-keys)
;; )
#+end_src

#+RESULTS:
: jedi

** Helm and gtags

Further customization of =gtags= with =helm=, from http://tuhdo.github.io/c-ide.html.

Check out: http://tuhdo.github.io/c-ide.html

#+begin_src emacs-lisp :tangle yes
    ;; Tuhdo says to put this but if I do emacs spits error mesage on start up.
    ;;(require 'setup-helm)
    ;;(require 'setup-helm-gtags)

    (setq
     helm-gtags-ignore-case t
     helm-gtags-auto-update t
     helm-gtags-use-input-at-cursor t
     helm-gtags-pulse-at-cursor t
     helm-gtags-prefix-key "C-c g"
     helm-gtags-suggested-key-mapping t
     )

    (require 'helm-gtags)
    ;; Enable helm-gtags-mode
    (add-hook 'dired-mode-hook 'helm-gtags-mode)
    (add-hook 'eshell-mode-hook 'helm-gtags-mode)
    (add-hook 'c-mode-hook 'helm-gtags-mode)
    (add-hook 'c++-mode-hook 'helm-gtags-mode)
    (add-hook 'asm-mode-hook 'helm-gtags-mode)

    (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
    (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
    (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
    (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
    (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
    (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
#+end_src

#+RESULTS:
: helm-gtags-next-history

** Other stuff from Tuhdo
- Stuff from http://tuhdo.github.io/emacs-tutor3.html

*** New beginning of line
Sometimes, we want to adjust or improve the behaviours of some commands in certain contexts. Consider this situation: C-a, which runs move-beginning-of-line, always move to the beginning of line. However, sometimes we don't always to move to the beginning of line, but move to the first non-whitespace character of that line.

See http://tuhdo.github.io/emacs-tutor3.html

#+BEGIN_SRC emacs-lisp :tangle yes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Customized functions                ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun prelude-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first. If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key (kbd "\C-a") 'prelude-move-beginning-of-line)
#+END_SRC

#+RESULTS:
: prelude-move-beginning-of-line

*** Recent files.

Info from  https://www.emacswiki.org/emacs/RecentFiles

Recentf is a minor mode that builds a list of recently opened files. This list is is automatically saved across sessions on exiting Emacs - you can then access this list through a command or the menu.

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'recentf)
(recentf-mode 1)
(setq recentf-max-menu-items 25)
(global-set-key "\C-x\ \C-r" 'recentf-open-files)
#+END_SRC

#+RESULTS:
: recentf-open-files

By default, Recentf saves the list of recent files on exiting Emacs (specifically, `recentf-save-list` is called on `kill-emacs-hook`). If Emacs exits abruptly for some reason the recent file list will be lost - therefore you may wish to call `recentf-save-list` periodically, e.g. every 5 minutes:

#+BEGIN_SRC emacs-lisp :tangle yes
    (run-at-time nil (* 5 60) 'recentf-save-list)
#+END_SRC

#+RESULTS:
: [nil 22715 15921 795970 300 recentf-save-list nil nil 872000]


Also, we increse the number of items in the menu and saved.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (recentf-mode)
  (setq
   recentf-max-menu-items 30
   xrecentf-max-saved-items 50
   )

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: recentf-ext    ;;
  ;;                         ;;
  ;; GROUP: Files -> Recentf ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (require 'recentf-ext)



  ;;;;;;;;;;;;;;;;;;;;;
  ;; PACKAGE: ztree  ;;
  ;;                 ;;
  ;; GROUP: No group ;;
  ;;;;;;;;;;;;;;;;;;;;;
  ;; since ztree works with files and directories, let's consider it in
  ;; group Files

  (require 'ztree-diff)
  (require 'ztree-dir)


  ;;,-----------------
  ;;| PACKAGE: rebox2
  ;;|
  ;;| GROUP: No group
  ;;`-----------------

;; Ojo: solo funciona si se llama M-x rebox-mode
  (require 'rebox2)
  (global-set-key [(meta q)] 'rebox-dwin-fill)
  (global-set-key [(shift meta q)] 'rebox-dwin-no-fill)


  ;; PACKAGE: helpful
  ;; GROUP: No group

  ;  https://github.com/Wilfred/helpful

  (require 'helpful)

  ;; Note that the built-in `describe-function' includes both functions
  ;; and macros. `helpful-function' is functions only, so we provide
  ;; `helpful-callable' as a drop-in replacement.
  (global-set-key (kbd "\C-h f") #'helpful-callable)
  (global-set-key (kbd "\C-h v") #'helpful-variable)
  (global-set-key (kbd "\C-h k") #'helpful-key)

  ;; Lookup the current symbol at point. C-c C-d is a common keybinding
  ;; for this in lisp modes.
  ;; (global-set-key (kbd "\C-s d") #'helpful-at-point)

  ;; Look up *F*unctions (excludes macros).
  ;;
  ;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
  ;; already links to the manual, if a function is referenced there.
  ;;  (global-set-key (kbd "\C-s-f") #'helpful-function)

  ;; Look up *C*ommands.
  ;;
  ;; By default, C-h C is bound to describe `describe-coding-system'. I
  ;; don't find this very useful, but it's frequently useful to only
  ;; look at interactive functions.
  ;; (global-set-key (kbd "\C-s-c") #'helpful-command)
#+END_SRC
#+RESULTS:
: helpful-key

*** Peek definition with Emacs frame
- Stuff from http://tuhdo.github.io/emacs-frame-peek.html
- So far I have not made it work in this =dgm.org= file but maybe it works with other programming languages.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun rtags-peek-definition ()
  "Peek at definition at point using rtags."
  (interactive)
  (let ((func (lambda ()
                (rtags-find-symbol-at-point)
                (rtags-location-stack-forward))))
    (rtags-start-process-unless-running)
    (make-peek-frame func)))

(defun make-peek-frame (find-definition-function &rest args)
  "Make a new frame for peeking definition"
  (when (or (not (rtags-called-interactively-p)) (rtags-sandbox-id-matches))
    (let (summary
          doc-frame
          x y
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ;; 1. Find the absolute position of the current beginning of the symbol at point, ;;
          ;; in pixels.                                                                     ;;
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          (abs-pixel-pos (save-excursion
                           (beginning-of-thing 'symbol)
                           (window-absolute-pixel-position))))
      (setq x (car abs-pixel-pos))
      ;; (setq y (cdr abs-pixel-pos))
      (setq y (+ (cdr abs-pixel-pos) (frame-char-height)))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 2. Create a new invisible frame, with the current buffer in it. ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (setq doc-frame (make-frame '((minibuffer . nil)
                                    (name . "*RTags Peek*")
                                    (width . 80)
                                    (visibility . nil)
                                    (height . 15))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 3. Position the new frame right under the beginning of the symbol at point. ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (set-frame-position doc-frame x y)

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 4. Jump to the symbol at point. ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (with-selected-frame doc-frame
        (apply find-definition-function args)
        (read-only-mode)
        (when semantic-stickyfunc-mode (semantic-stickyfunc-mode -1))
        (recenter-top-bottom 0))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 5. Make frame visible again ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (make-frame-visible doc-frame))))

(global-set-key (kbd "M-s-p") 'rtags-peek-definition)
#+END_SRC

#+RESULTS:
: rtags-peek-definition

*** COMMENT eyebrowse configuration

Idea from http://pragmaticemacs.com/emacs/easily-manage-emacs-workspaces-with-eyebrowse/ but for some reason when I activate this bit of code, my configuration file does not work and everything fails.

I have commented this out because with =exwm= I think I don't need =eyebrowse= anymore.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package eyebrowse
  :ensure t
  :defer 1
  :init
  (setq eyebrowse-keymap-prefix (kbd "C-c z"))
  (global-unset-key (kbd "C-c C-w"))
  :diminish eyebrowse-mode
  :config (progn
            (define-key eyebrowse-mode-map (kbd "s-1") 'eyebrowse-switch-to-window-config-1)
            (define-key eyebrowse-mode-map (kbd "s-2") 'eyebrowse-switch-to-window-config-2)
            (define-key eyebrowse-mode-map (kbd "s-3") 'eyebrowse-switch-to-window-config-3)
            (define-key eyebrowse-mode-map (kbd "s-4") 'eyebrowse-switch-to-window-config-4)
            (define-key eyebrowse-mode-map (kbd "s-5") 'eyebrowse-switch-to-window-config-5)
            (define-key eyebrowse-mode-map (kbd "s-6") 'eyebrowse-switch-to-window-config-6)
            (define-key eyebrowse-mode-map (kbd "s-7") 'eyebrowse-switch-to-window-config-7)
            (define-key eyebrowse-mode-map (kbd "s-8") 'eyebrowse-switch-to-window-config-8)
            (define-key eyebrowse-mode-map (kbd "s-9") 'eyebrowse-switch-to-window-config-9)
            (define-key eyebrowse-mode-map (kbd "s-<") 'eyebrowse-prev-window-config)
            (define-key eyebrowse-mode-map (kbd "s->") 'eyebrowse-next-window-config)
            (eyebrowse-mode t)
            (setq eyebrowse-new-workspace t)))
#+END_SRC

#+RESULTS:
: t


So I'll try with this new code:

#+BEGIN_SRC emacs-lisp :tangle no
;;            (eyebrowse-mode t)
;;            (global-set-key (kbd "s-1") 'eyebrowse-switch-to-window-config-1)
;;            (global-set-key (kbd "s-2") 'eyebrowse-switch-to-window-config-2)
;;            (global-set-key (kbd "s-3") 'eyebrowse-switch-to-window-config-3)
;;            (global-set-key (kbd "s-4") 'eyebrowse-switch-to-window-config-4)
;;            (global-set-key (kbd "s-5") 'eyebrowse-switch-to-window-config-5)
;;            (global-set-key (kbd "s-6") 'eyebrowse-switch-to-window-config-6)
;;            (global-set-key (kbd "s-7") 'eyebrowse-switch-to-window-config-7)
;;            (global-set-key (kbd "s-8") 'eyebrowse-switch-to-window-config-8)
;;            (global-set-key (kbd "s-9") 'eyebrowse-switch-to-window-config-9)
;;            (setq eyebrowse-new-workspace t)
#+END_SRC

#+RESULTS:

But again, if I activate this bit of code, when I open emacs most of this file is not processed and I don't have my goodies running (helm, etc). However, if after I open emacs I run this code, then the code and all the rest works... why?

MISTERIO RESUELTO: cuando use' yasnippet para crear el snippet con elisp, me lo dio con begin_src y end_src en minusculas y esto es lo que causaba el caos (tambien pone lo del tangle yes o no pero creo que eso no es problema.)
** Magit

https://magit.vc/manual/magit.html#Installation

Key binding to get the Magit menu

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
#+END_SRC

#+RESULTS:
: magit-dispatch-popup


*** Make sure time stamps are in English

Tip from: https://stackoverflow.com/questions/28913294/emacs-org-mode-language-of-time-stamps

#+BEGIN_SRC emacs-lisp :tangle yes
;; System locale to use for formatting time values.
(setq system-time-locale "C")         ; Make sure that the weekdays in the
                                      ; time stamps of your Org mode files and
                                      ; in the agenda appear in English.
#+END_SRC

#+RESULTS:
: C

** Key bindings

#+BEGIN_SRC emacs-lisp :tangle yes
;;    (define-key global-map [?\s-u] 'undo)
;;    (define-key global-map [?\s-j] 'save-buffer)
;;    (define-key global-map [?\s-q] 'move-beginning-of-line)
;;    (define-key global-map [?\s-e] 'move-end-of-line)
;;    (define-key global-map [?\s-k] 'kill-buffer)
#+END_SRC

#+RESULTS:
: kill-buffer
**  Harry R. Schwartz  stuff
- Taken from https://github.com/hrs/dotfiles/blob/master/emacs/.emacs.d/configuration.org

*** Rename file

#+begin_src emacs-lisp :tangle yes
(defun hrs/rename-file (new-name)
  (interactive "FNew name: ")
  (let ((filename (buffer-file-name)))
    (if filename
        (progn
          (when (buffer-modified-p)
             (save-buffer))
          (rename-file filename new-name t)
          (kill-buffer (current-buffer))
          (find-file new-name)
          (message "Renamed '%s' -> '%s'" filename new-name))
      (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))
#+end_src

#+RESULTS:
: hrs/rename-file

*** Generate scratch buffer

#+begin_src emacs-lisp :tangle yes
(defun hrs/generate-scratch-buffer ()
  "Create and switch to a temporary scratch buffer with a random
     name."
  (interactive)
  (switch-to-buffer (make-temp-name "scratch-")))
#+end_src

#+RESULTS:
: hrs/generate-scratch-buffer

*** Visit last dired buffer

#+begin_src emacs-lisp :tangle yes
(defun hrs/visit-last-dired-file ()
  "Open the last file in an open dired buffer."
  (interactive)
  (end-of-buffer)
  (previous-line)
  (dired-find-file))
#+end_src

#+RESULTS:
: hrs/visit-last-dired-file

*** Geiser
#+begin_src emacs-lisp :tangle yes
(setq geiser-active-implementations '(chicken guile racket scheme))
#+end_src

#+RESULTS:
| chicken | guile | racket | scheme |

*** COMMENT Change window configuration

Tip from https://stackoverflow.com/questions/14881020/emacs-shortcut-to-switch-from-a-horizontal-split-to-a-vertical-split-in-one-move

Commented out because I am using =exwm= now.

#+BEGIN_SRC emacs-lisp :tangle no
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
         (next-win-buffer (window-buffer (next-window)))
         (this-win-edges (window-edges (selected-window)))
         (next-win-edges (window-edges (next-window)))
         (this-win-2nd (not (and (<= (car this-win-edges)
                     (car next-win-edges))
                     (<= (cadr this-win-edges)
                     (cadr next-win-edges)))))
         (splitter
          (if (= (car this-win-edges)
             (car (window-edges (next-window))))
          'split-window-horizontally
        'split-window-vertically)))
    (delete-other-windows)
    (let ((first-win (selected-window)))
      (funcall splitter)
      (if this-win-2nd (other-window 1))
      (set-window-buffer (selected-window) this-win-buffer)
      (set-window-buffer (next-window) next-win-buffer)
      (select-window first-win)
      (if this-win-2nd (other-window 1))))))

(global-set-key (kbd "s-c") 'toggle-window-split)
#+END_SRC

#+RESULTS:
: toggle-window-split

*** Yasnippet for R
See https://github.com/mattfidler/r-autoyas.el

#+begin_src emacs-lisp :tangle yes
;; (require 'r-autoyas)
;; (add-hook 'ess-mode-hook 'r-autoyas-ess-activate)
#+end_src

#+RESULTS:

*** Org customization
How do I change my dotfile so that when I call org-agenda it takes up the entire screen?
https://stackoverflow.com/questions/36873727/make-org-agenda-full-screen

#+BEGIN_SRC emacs-lisp :tangle yes
;; (setq org-agenda-window-setup 'only-window)
;; (setq org-export-dispatch 'only-window)
#+END_SRC

#+RESULTS:
: only-window

*** How to control in which window a buffer is displayed?

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-window-displaying-agenda-p (window)
    (equal (with-current-buffer (window-buffer window) major-mode)
        'org-agenda-mode)) 

(defun my-position-calendar-buffer (buffer alist)
  (let ((agenda-window (car (remove-if-not #'my-window-displaying-agenda-p (window-list)))))
    (when agenda-window
      (let ((desired-window (split-window agenda-window nil 'below)))
        (set-window-buffer desired-window  buffer)
        desired-window))))

(add-to-list 'display-buffer-alist (cons "\\*Calendar\\*" (cons #'my-position-calendar-buffer nil)))
#+END_SRC

#+RESULTS:
| \*Calendar\* | my-position-calendar-buffer |

From my question in https://emacs.stackexchange.com/questions/45650/in-org-mode-what-variable-controls-the-placement-of-the-calendar-view-when-call/45653#45653

The following will make the Calendar to use a window below the selected window

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'display-buffer-alist
             `(,(rx string-start "*Calendar*" string-end)
               (display-buffer-below-selected)))
#+END_SRC

** Ambrevar's stuff

From his =main.el=

#+BEGIN_SRC emacs-lisp :tangle yes
;;; Save M-: history.
(savehist-mode)

;;; Enforce horizontal splitting. 140 means that the window is large enough to
;;; hold 2 other windows of 70 columns.
(setq split-height-threshold nil
      split-width-threshold 140)

;;; Show matching parenthesis
(show-paren-mode 1)
;;; By default, there’s a small delay before showing a matching parenthesis. Set
;;; it to 0 to deactivate.
(setq show-paren-delay 0)
(setq show-paren-when-point-inside-paren t)

;;; Replace `kill-buffer' binding by `kill-this-buffer'.
(global-set-key (kbd "C-x k") 'kill-this-buffer)

;;; Initial scratch buffer message.
;; commented out as it was too distracting
;;(require 'functions) ; For `ambrevar/fortune-scratch-message'.
;;(let ((fortune (ambrevar/fortune-scratch-message)))
;;  (when fortune
;;    (setq initial-scratch-message fortune)))

;;; Save all visited URLs.
(setq url-history-track t
      url-history-file (expand-file-name "url/history" user-emacs-directory))
#+END_SRC

#+RESULTS:
: /home/dgm/.emacs.d/url/history

** EXWM: emacs as desktop manager!

Tip from Uncle Dave's emacs 

#+source: exwm-starting
#+begin_src emacs-lisp :tangle yes
   ;; emacs as a daemon, use "emacsclient <filename>" to seamlessly edit files from the terminal directly
   ;; plus in https://github.com/ch11ng/exwm/wiki/Configuration-Example the developer puts this line before <(require 'exwm)>. 
   ;; so that is why I've taken it out of the bit on exwm

;; from https://caolan.org/dotfiles/emacs.html#orgd96aeb0
;; run server if using emacsclient as default EDITOR also useful for
;; org-protocol capture https://www.emacswiki.org/emacs/EmacsClient

(server-start)

  (use-package exwm 
    :ensure t
    :config 
  
    ;; necessary to configure exwm manually
    (require 'exwm-config)

    ;; fringe size, most people prefer 1 (uncle dave's setup)
    (fringe-mode 3)

;; dgm comments this as it appears to not be working!! reverts to old (server-star)
;;    (require 'server)
;;      (unless (server-running-p)
;;        (server-start))

    (exwm-config-default))

    ;; this just enables exwm, it started automatically once everything is ready
;; commented out now that I have the Ferguson setup    (exwm-enable))  
      #+end_src

#+RESULTS: exwm-starting
: t
*** pulseaudio-control

Info in https://github.com/flexibeast/pulseaudio-control

Sets prefix to =C-x /=. Then 
=+=: Increase the volume of the currently-selected sink by pulseaudio-control-volume-step (pulseaudio-control-increase-volume).
=-=: Decrease the volume of the currently-selected sink by pulseaudio-control-volume-step (pulseaudio-control-decrease-volume).
=m=: Toggle muting of the currently-selected sink (pulseaudio-control-toggle-current-sink-mute).
=d=: Display volume of the currently-selected sink (pulseaudio-control-display-volume).

#+BEGIN_SRC emacs-lisp :tangle yes
  (pulseaudio-control-default-keybindings)
#+END_SRC

#+RESULTS:
: pulseaudio-control-map

*** =dired= do what I mean
- Tip from
https://emacs.stackexchange.com/questions/5603/how-to-quickly-copy-move-file-in-emacs-dired

#+BEGIN_SRC emacs-lisp :tangle yes
 (setq dired-dwim-target t)
#+END_SRC

#+RESULTS:
: t

*** gpastel

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package gpastel
    :ensure t
    :config 
   (gpastel-start-listening))
#+END_SRC

#+RESULTS:
: t

** Customize =emacsclient=

#+BEGIN_SRC emacs-lisp :tangle yes
(setq default-frame-alist '((font . "Pragmata Pro Mono-16")))
(add-to-list 'default-frame-alist '(line-spacing . 0.06))
#+END_SRC

#+RESULTS:
: ((line-spacing . 0.06) (font . Pragmata Pro Mono-16))
 
** =qutebrowser=
Originally from https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org with qutebrowser, but too unstable. Changed to chromium

#+BEGIN_SRC emacs-lisp :tangle yes
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "chromium")
;      browse-url-generic-program "qutebrowser")
#+END_SRC

#+RESULTS:
: qutebrowser

** Customize the startup screen

No sé por qué pero este código con el setup Ferguson, i.e., EXWM-gnome-flashback-does not work anymore. 

#+BEGIN_SRC emacs-lisp :tangle no
(use-package dashboard
  :ensure t
  :config
    (dashboard-setup-startup-hook)
;    (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
    (setq dashboard-items '((recents   . 10)
                            (bookmarks . 10)
                            (projects  . 10)))
    (setq dashboard-banner-logo-title ""))
(message "Testing 2 dashboard chunk is evaluated.")
#+END_SRC

#+RESULTS:
: Testing 2 dashboard chunk is evaluated.

** Tell emacs where =fortune= is
From 

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'fortune)
(setq fortune-dir "/usr/share/games/fortunes"
      fortune-file "/usr/share/games/fortunes/fortunes")
#+END_SRC

** Better defaults
By the great Technomancy

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)

(autoload 'zap-up-to-char "misc"
    "Kill up to, but not including ARGth occurrence of CHAR." t)
(global-set-key (kbd "M-z") 'zap-up-to-char)

(setq apropos-do-all t
      mouse-yank-at-point t)
#+END_SRC

#+RESULTS:
: t

** Caolan's stuff
From https://caolan.org/dotfiles/emacs.html#orgd96aeb0

*** Ediff
Some tips taken from the post Setting up Ediff.

Don't use the weird setup with a control panel in a separate frame, use a normal Emacs window instead.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

Split the windows horizontally instead of vertically as I find it easier to follow.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq ediff-split-window-function 'split-window-horizontally)
#+END_SRC

Restore the windows after Ediff quits. By default, when you quit the Ediff session with q, it just leaves the two diff windows around, instead of restoring the window configuration from when Ediff was started.

#+BEGIN_SRC emacs-lisp :tangle yes
;;(winner-mode)
;;(add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC

(Above code in =starter-kit-binding.org=)

Don't wait 3 seconds then ask about closing the merge buffer, just close it!

#+BEGIN_SRC emacs-lisp
;; write merge buffer.  If the optional argument save-and-continue is non-nil,
;; then don't kill the merge buffer
(defun caolan/ediff-write-merge-buffer-and-maybe-kill (buf file
                                                           &optional
                                                           show-file save-and-continue)
  (if (not (eq (find-buffer-visiting file) buf))
      (let ((warn-message
             (format "Another buffer is visiting file %s. Too dangerous to save the merge buffer"
                     file)))
        (beep)
        (message "%s" warn-message)
        (with-output-to-temp-buffer ediff-msg-buffer
          (princ "\n\n")
          (princ warn-message)
          (princ "\n\n")
          )
        (sit-for 2))
    (ediff-with-current-buffer buf
      (if (or (not (file-exists-p file))
              (y-or-n-p (format "File %s exists, overwrite? " file)))
          (progn
            ;;(write-region nil nil file)
            (ediff-with-current-buffer buf
              (set-visited-file-name file)
              (save-buffer))
            (if show-file
                (progn
                  (message "Merge buffer saved in: %s" file)
                  (set-buffer-modified-p nil)))
            (if (and (not save-and-continue))
                (ediff-kill-buffer-carefully buf)))))
    ))

(defun caolan/ediff-maybe-save-and-delete-merge (&optional save-and-continue)
  "Default hook to run on quitting a merge job.
This can also be used to save merge buffer in the middle of an Ediff session.

If the optional SAVE-AND-CONTINUE argument is non-nil, save merge buffer and
continue.  Otherwise:
If `ediff-autostore-merges' is nil, this does nothing.
If it is t, it saves the merge buffer in the file `ediff-merge-store-file'
or asks the user, if the latter is nil.  It then asks the user whether to
delete the merge buffer.
If `ediff-autostore-merges' is neither nil nor t, the merge buffer is saved
only if this merge job is part of a group, i.e., was invoked from within
`ediff-merge-directories', `ediff-merge-directory-revisions', and such."
  (let ((merge-store-file ediff-merge-store-file)
        (ediff-autostore-merges ; fake ediff-autostore-merges, if necessary
         (if save-and-continue t ediff-autostore-merges)))
    (if ediff-autostore-merges
        (cond ((stringp merge-store-file)
               ;; store, ask to delete
               (caolan/ediff-write-merge-buffer-and-maybe-kill
                ediff-buffer-C merge-store-file 'show-file save-and-continue))
              ((eq ediff-autostore-merges t)
               ;; ask for file name
               (setq merge-store-file
                     (read-file-name "Save the result of the merge in file: "))
               (caolan/ediff-write-merge-buffer-and-maybe-kill
                ediff-buffer-C merge-store-file nil save-and-continue))
              ((and (ediff-buffer-live-p ediff-meta-buffer)
                    (ediff-with-current-buffer ediff-meta-buffer
                                               (ediff-merge-metajob)))
               ;; The parent metajob passed nil as the autostore file.
               nil)))
    ))

(add-hook 'ediff-quit-merge-hook #'caolan/ediff-maybe-save-and-delete-merge)
#+END_SRC

Fully expand Org files in Ediff (otherwise it's hard to see the changes between files). This tip taken from the Emacs Stackexchange, which also has an interesting solution to unfold/fold Org elements as Ediff selects/deselects changes, but I found just showing everything to work more reliably.

Note, show-all is marked obsolete in Emacs 25.1 in favor of outline-show-all. But the latter symbol is not bound in 24.5, and since I use Debian stable (Jessie) on my desktop which provides Emacs 24.4, I need to use the older show-all for now.

#+BEGIN_SRC emacs-lisp
(add-hook 'ediff-prepare-buffer-hook #'outline-show-all)
#+END_SRC

#+RESULTS:
| outline-show-all |



*** Cut/copy/comment current line if no region selected
In many programs, like SlickEdit, TextMate and VisualStudio, "cut" and "copy" act on the current line if no text is visually selected. For this, I originally used code from Tim Krones Emacs config, but now I'm using the whole-line-or-region package, which can be customised to use the same line-or-region style for comments too. See comments in whole-line-or-region.el for details.

However, I disable it or else the copy/paste emacs bindings won't work in external apps PLUS uncle dave has defined handy functions to do the copying and killing on current words and lines.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package whole-line-or-region
  :ensure t)

(add-to-list 'whole-line-or-region-extensions-alist
             '(comment-dwim whole-line-or-region-comment-dwim nil))

(whole-line-or-region-global-mode 1)
#+END_SRC

#+RESULTS:
: t

*** Place cursor at beginning of search matches
From: http://www.emacswiki.org/emacs/IncrementalSearch#toc4. With this hook, both ‘C-g’ and ‘RET’ exit the search at the begining of the search string rather than the end. To get back to where you started the search, just use ‘C-x C-x’. This works because isearch sets the mark at the search start.

I (dgm) don't find a use case for it, so I disable it. 

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'isearch-mode-end-hook 'my-goto-match-beginning)

(defun my-goto-match-beginning ()
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end)))

(defadvice isearch-exit (after my-goto-match-beginning activate)
  "Go to beginning of match."
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end)))
#+END_SRC

#+RESULTS:
: isearch-exit

*** Environment variables
Set environment variable so running CHICKEN Scheme suites via the 'test' egg will display colour output.
#+BEGIN_SRC emacs-lisp :tangle yes
(setenv "TEST_USE_ANSI" "1")
#+END_SRC

#+RESULTS:
: 1

Add my home bin directory to PATH (when I have it)

#+BEGIN_SRC emacs-lisp :tangle no
(setenv "PATH" (concat "/home/dgm/bin:" (getenv "PATH")))
#+END_SRC

*** Trying to get =M-x stata= working

Originally this got stata working when I called it interactively with =M-x stata=
#+BEGIN_SRC emacs-lisp :tangle no
;; (setenv "PATH" (concat "/usr/local/stata14:/usr/local/stata:" (getenv "PATH")))
(setenv "PATH" (concat (getenv "PATH") ":/usr/local/stata"))
(setq exec-path (append exec-path '("/usr/local/stata")))
#+END_SRC

#+RESULTS:
| /usr/local/bin/ | /usr/bin/ | /bin/ | /usr/local/games/ | /usr/games/ | /usr/local/sbin/ | /usr/sbin/ | /sbin/ | /usr/bin/ | /bin/ | /usr/local/bin/ | /usr/local/stata14/ | /usr/local/stata/ | /usr/local/libexec/emacs/27.0.50/x86_64-pc-linux-gnu/ | /usr/local/bin/stata | /usr/local/stata |


However, once I used the script sent from Stata Corp. to make stata work after updating it, this does not work. So I have changed it to:

#+BEGIN_SRC emacs-lisp :tangle no
(setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin/stata"))
(setq exec-path (append exec-path '("/usr/local/bin/stata")))
#+END_SRC

#+RESULTS:
| /usr/local/bin/ | /usr/bin/ | /bin/ | /usr/local/games/ | /usr/games/ | /usr/local/sbin/ | /usr/sbin/ | /sbin/ | /usr/bin/ | /bin/ | /usr/local/bin/ | /usr/local/stata14/ | /usr/local/stata/ | /usr/local/libexec/emacs/27.0.50/x86_64-pc-linux-gnu/ | /usr/local/bin/stata |

However, I've tangled it up to "no" because I think this is not needed now that I use Purcell's package =exec-path-from-shell=.

*** Pop-up terminal
From http://pragmaticemacs.com/emacs/pop-up-a-quick-shell-with-shell-pop/. Opens a quick ANSI terminal in the directory of the currently open file.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package shell-pop
  :ensure t
  :bind (("s--" . shell-pop))
  :config
  (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
  (setq shell-pop-term-shell "/bin/bash")
  (setq shell-pop-universal-key "C-t")
  ;; need to do this manually or not picked up by `shell-pop'
  (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC

#+RESULTS:
: shell-pop

Try to open it at bottom of current window

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'display-buffer-alist
             `(,(rx string-start "*shell*" string-end)
               (display-buffer-below-selected)))
#+END_SRC

#+RESULTS:
| \`\*shell\*\'    | (display-buffer-below-selected) |
| \`\*Calendar\*\' | (display-buffer-below-selected) |
| \*Calendar\*     | my-position-calendar-buffer     |

*** Using dumb-jump to jump to definitions
The dumb-jump package provides 'jump to definition' support for multiple languages by simply searching for possible definitions using The Silver Searcher ag, ripgrep rg, or grep. It does not require building stored indexes (TAGS) or background processes etc.

Enable dumb-jump-mode globally:

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dumb-jump
  :ensure t
  :init (lambda ()
          (dumb-jump-mode)))
#+END_SRC

#+RESULTS:

If The Silver Searcher is installed it will use it, otherwise it will revert back to =grep=.

*** EditorConfig plugin
Reads EditorConfig files to set coding style options according to current project.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+END_SRC

#+RESULTS:
: t

*** Thesaurus
Many of the thesaurus packages use an online service, synosaurus gives you the option of using a local Wordnet install. It also has a nice 'replace word' interface.

NOTE: this requires you to install wordnet

#+BEGIN_EXAMPLE
 sudo apt install wordnet
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package synosaurus
  :ensure t
  :config (progn
            (setq synosaurus-backend 'synosaurus-backend-wordnet)
            (setq synosaurus-choose-method 'default)))
#+END_SRC 

#+RESULTS:
: t

*** Dictionary
Since I already use a local Wordnet as a thesaurus, I'm using it for a dictionary as well via the wordnut package.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package wordnut
  :ensure t)
#+END_SRC

#+RESULTS:

*** Olivetti minor mode
A minor mode for a nice writing environment.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package olivetti
  :ensure t
  :config (setq olivetti-body-width 90))
#+END_SRC

#+RESULTS:
: t

** Uncle Dave
https://github.com/daedreth/UncleDavesEmacs

*** Async
Lets us use asynchronous processes wherever possible, pretty useful.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package async
  :ensure t
  :init (dired-async-mode 1))
#+END_SRC

#+RESULTS:

*** Launchers
Since I do not use a GUI launcher and do not have an external one like dmenu or rofi, I figured the best way to launch my most used applications would be direct emacsy keybindings.

**** Functions to start processes
I guess this goes without saying but you absolutely have to change the arguments to suit the software that you are using. What good is a launcher for discord if you don’t use it at all.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun exwm-async-run (name)
  (interactive)
  (start-process name nil name))

(defun daedreth/launch-browser ()
  (interactive)
  (exwm-async-run "chromium"))

(defun daedreth/lock-screen ()
  (interactive)
  (exwm-async-run "slock"))
#+END_SRC

#+RESULTS:
: daedreth/lock-screen

***** Keybindings to start processes
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "<s-escape>") 'daedreth/launch-browser)
(global-set-key (kbd "<s-@>") 'daedreth/lock-screen)
#+END_SRC

#+RESULTS:
: daedreth/launch-browser

**** Screenshots
I don’t need scrot to take screenshots, or shutter or whatever tools you might have. This is enough. These won’t work in the terminal version or the virtual console, obvious reasons.

***** Screenshotting the entire screen

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/take-screenshot ()
  "Takes a fullscreen screenshot of the current workspace"
  (interactive)
  (when window-system
  (loop for i downfrom 3 to 1 do
        (progn
          (message (concat (number-to-string i) "..."))
          (sit-for 1)))
  (message "Cheese!")
  (sit-for 1)
  (start-process "screenshot" nil "import" "-window" "root" 
             (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
  (message "Screenshot taken!")))
(global-set-key (kbd "s-[") 'daedreth/take-screenshot)
#+END_SRC

***** Screenshotting a region

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/take-screenshot-region ()
  "Takes a screenshot of a region selected by the user."
  (interactive)
  (when window-system
  (call-process "import" nil nil nil ".newScreen.png")
  (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
                (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
  (call-process "rm" nil nil nil ".newScreen.png")))
(global-set-key (kbd "s-]") 'daedreth/take-screenshot-region)
#+END_SRC

#+RESULTS:
: daedreth/take-screenshot-region

**** System monitor
A teeny-tiny system monitor that can be enabled or disabled at runtime, useful for checking performance with power-hungry processes in ansi-term

symon can be toggled on and off with =super+h=.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package symon
  :ensure t
  :bind
  ("s-h" . symon-mode))
#+END_SRC

#+RESULTS:
: symon-mode

**** Default shell should be bash
I don’t know why this is a thing, but asking me what shell to launch every single time I open a terminal makes me want to slap babies, this gets rid of it. This goes without saying but you can replace bash with your shell of choice.

#+BEGIN_SRC emacs-lisp :tangle yes
(defvar my-term-shell "/bin/bash")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)
#+END_SRC

#+RESULTS:
: ansi-term

**** Easy to remember keybinding
In loving memory of bspwm, =super+Enter= opens a new terminal, old habits die hard.

#+BEGIN_SRC emacs-lisp :tangle yes
;; (global-set-key (kbd "<s-return>") 'ansi-term)
#+END_SRC

#+RESULTS:
: ansi-term

I think this will is too powerful a shortcut for this. I'd rather use it for =swipe=.

**** Ivy 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ivy
  :ensure t)
#+END_SRC

#+RESULTS:

**** scrolling and why does the screen move
I don’t know to be honest, but this little bit of code makes scrolling with emacs a lot nicer.

#+BEGIN_SRC emacs-lisp :tangle yes
;; (setq scroll-conservatively 100)
#+END_SRC

I've disabled it because it is set to 0 in =starter-kit-text.org=.

**** windows, panes and why I hate other-window
Some of us have large displays, others have tiny netbook screens, but regardless of your hardware you probably use more than 2 panes/windows at times, cycling through all of them with C-c o is annoying to say the least, it’s a lot of keystrokes and takes time, time you could spend doing something more productive.

***** =ace-window=
ace-window is a package that uses the same idea from ace-jump-mode for buffer navigation, but applies it to windows. 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-window
  :ensure t
  :config
  (ace-window-display-mode)
  :bind ("M-P" . ace-window))

;; (global-set-key (kbd "M-P") 'ace-window)
#+END_SRC

#+RESULTS:
: ace-window

Problema: if I am in an external app within =exwm=, then =ace-window= does not work and I'd rather use =switch-window=.

***** switch-window
This magnificent package takes care of this issue. It’s unnoticeable if you have <3 panes open, but with 3 or more, upon pressing C-x o you will notice how your buffers turn a solid color and each buffer is asigned a letter (the list below shows the letters, you can modify them to suit your liking), upon pressing a letter asigned to a window, your will be taken to said window, easy to remember, quick to use and most importantly, it annihilates a big issue I had with emacs. An alternative is ace-window, however by default it also changes the behaviour of C-x o even if only 2 windows are open, this is bad, it also works less well with exwm for some reason.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package switch-window
  :ensure t
  :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
        '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
  :bind
    ([remap other-window] . switch-window))
#+END_SRC

#+RESULTS:
: switch-window

***** Following window splits
After you split a window, your focus remains in the previous one. This annoyed me so much I wrote these two, they take care of it.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

#+RESULTS:
: split-and-follow-vertically

**** =swipe=
I like me some searching, the default search is very meh. In emacs, you mostly use search to get around your buffer, much like with avy, but sometimes it doesn’t hurt to search for entire words or mode, swiper makes sure this is more efficient.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package swiper
  :ensure t)
#+END_SRC

#+RESULTS:

*****  Further customization from Pragmatic Emacs

From: http://pragmaticemacs.com/emacs/dont-search-swipe/

#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "<s-return>") 'swiper)
(setq ivy-display-style 'fancy)
#+END_SRC

#+RESULTS:
: fancy

The second line in the above code sets the colours of the swiper results display to be a bit more, well, fancy! Apparently this option only works well for emacs versions 24.5 and higher, so get updated.

The other tweak I have made is to get swiper to recenter the display when it exits – I found it a little unpredictable where the point was going to be after I finished swiper. This is done with a little bit of advice:

#+BEGIN_SRC emacs-lisp :tangle yes
;;advise swiper to recenter on exit
(defun bjm-swiper-recenter (&rest args)
  "recenter display after swiper"
  (recenter))
(advice-add 'swiper :after #'bjm-swiper-recenter)
#+END_SRC

#+RESULTS:

**** close-all-buffers
It’s one of those things where I genuinely have to wonder why there is no built in functionality for it. Once in a blue moon I need to kill all buffers, and having ~150 of them open would mean I’d need to spend a few too many seconds doing this than I’d like, here’s a solution.

This can be invoked using C-M-s-k. This keybinding makes sure you don’t hit it unless you really want to.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun close-all-buffers ()
  "Kill all buffers without regard for their origin."
  (interactive)
  (mapc 'kill-buffer (buffer-list)))
(global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC

#+RESULTS:
: close-all-buffers

*** line numbers and programming
Every now and then all of us feel the urge to be productive and write some code. In the event that this happens, the following bit of configuration makes sure that we have access to relative line numbering in programming-related modes. I highly recommend not enabling linum-relative-mode globally, as it messed up something like ansi-term for instance.

Note: I disable this as I find it not very useful and dizzling by way of the moving numbers

#+BEGIN_SRC emacs-lisp :tangle no
(use-package linum-relative
  :ensure t
  :config
    (setq linum-relative-current-symbol "")
    (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC

#+RESULTS:
: t

*** avy and why it’s the best thing in existence
Many times have I pondered how I can move around buffers even quicker. I’m glad to say, that avy is precisely what I needed, and it’s precisely what you need as well. In short, as you invoke one of avy’s functions, you will be prompted for a character that you’d like to jump to in the visible portion of the current buffer. Afterwards you will notice how all instances of said character have additional letter on top of them. Pressing those letters, that are next to your desired character will move your cursor over there. Admittedly, this sounds overly complicated and complex, but in reality takes a split second and improves your life tremendously.

I like M-s for it, same as C-s is for moving by searching string, now M-s is moving by searching characters.


#+BEGIN_SRC emacs-lisp :tangle yes
(use-package avy
  :ensure t
  :bind
    ("s-s" . avy-goto-char))
#+END_SRC

*** Text manipulation
Here I shall collect self-made functions that make editing text easier.

**** Mark-Multiple
I can barely contain my joy. This extension allows you to quickly mark the next occurence of a region and edit them all at once. Wow!

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mark-multiple
  :ensure t
  :bind ("s-q" . 'mark-next-like-this))
#+END_SRC

#+RESULTS:
: mark-next-like-this

**** Improved kill-word
Why on earth does a function called kill-word not ... kill a word. It instead deletes characters from your cursors position to the end of the word, let’s make a quick fix and bind it properly.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/kill-inner-word ()
  "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))
(global-set-key (kbd "s-k") 'daedreth/kill-inner-word)
#+END_SRC

#+RESULTS:
: daedreth/kill-inner-word

**** Improved copy-word
And again, the same as above but we make sure to not delete the source word.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/copy-whole-word ()
  (interactive)
  (save-excursion
    (forward-char 1)
    (backward-word)
    (kill-word 1)
    (yank)))
(global-set-key (kbd "M-s-w") 'daedreth/copy-whole-word)
#+END_SRC

#+RESULTS:
: daedreth/copy-whole-word


**** Copy a line
Regardless of where your cursor is, this quickly copies a line.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/copy-whole-line ()
  "Copies a line without regard for cursor position."
  (interactive)
  (save-excursion
    (kill-new
     (buffer-substring
      (point-at-bol)
      (point-at-eol)))))
(global-set-key (kbd "M-s-l") 'daedreth/copy-whole-line)
#+END_SRC

#+RESULTS:
: daedreth/copy-whole-line

**** Kill a line
And this quickly deletes a line.

#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "M-s-k") 'kill-whole-line)
#+END_SRC

#+RESULTS:
: kill-whole-line

*** Minor conveniences
Emacs is at it’s best when it just does things for you, shows you the way, guides you so to speak. This can be best achieved using a number of small extensions. While on their own they might not be particularly impressive. Together they create a nice environment for you to work in.

**** Subwords/Camel casing
Emacs treats camelCase strings as a single word by default, this changes said behaviour.

#+BEGIN_SRC emacs-lisp :tangle yes
(global-subword-mode 1)
#+END_SRC

**** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor. Unless you know its position, you can not move it efficiently. Every time you change buffers, the current position of your cursor will be briefly highlighted now.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package beacon
  :ensure t
  :config
    (beacon-mode 1))
#+END_SRC

#+RESULTS:
: t

**** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them, especially lisp.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :ensure t
  :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

#+RESULTS:

*** Hungry deletion
On the list of things I like doing, deleting big whitespaces is pretty close to the bottom. Backspace or Delete will get rid of all whitespace until the next non-whitespace character is encountered. You may not like it, thus disable it if you must, but it’s pretty decent.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hungry-delete
  :ensure t
  :config
    (global-hungry-delete-mode))
#+END_SRC

#+RESULTS:
: t

*** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most. With a simple M-y you can now browse your kill-ring like browsing autocompletion items. C-n and C-p totally work for this.

DGM: nice, but i prefer to use helm to browse the kill ring.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package popup-kill-ring
  :ensure t
  :bind ("M-y" . popup-kill-ring))
#+END_SRC

#+RESULTS:
: popup-kill-ring

*** Remote editing
***  Editing
I have no need to directly edit files over SSH, but what I do need is a way to edit files as root. Opening up nano in a terminal as root to play around with grubs default settings is a no-no, this solves that.
*** Editing with sudo
Pretty self-explanatory, useful as hell if you use exwm.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package sudo-edit
  :ensure t
  :bind
    ("s-e" . sudo-edit))
#+END_SRC

#+RESULTS:
: sudo-edit

*** Diminishing modes 

Your modeline is sacred, and if you have a lot of modes enabled, as you will if you use this config, you might end up with a lot of clutter there, the package diminish disables modes on the mode line but keeps them running, it just prevents them from showing up and taking up space.

THIS WILL BE REMOVED SOON AS USE-PACKAGE HAS THE FUNCTIONALITY BUILT IN

Edit this list as you see fit!

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package diminish
  :ensure t
  :init
  (diminish 'which-key-mode)
  (diminish 'linum-relative-mode)
  (diminish 'hungry-delete-mode)
  (diminish 'visual-line-mode)
  (diminish 'subword-mode)
  (diminish 'beacon-mode)
  (diminish 'irony-mode)
  (diminish 'page-break-lines-mode)
  (diminish 'auto-revert-mode)
  (diminish 'rainbow-delimiters-mode)
  (diminish 'yas-minor-mode)
  (diminish 'rainbow-mode))
#+END_SRC

** Daniel Mai

https://github.com/danielmai/.emacs.d/blob/master/config.org

*** Page breaks

Here we make page-break characters look pretty, instead of appearing as ^L in Emacs. Here’s an informative article called “Using Page-Breaks in GNU Emacs” by Eric J. M. Ritz.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package page-break-lines
  :ensure t)
#+END_SRC

#+RESULTS:

*** Tramp 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package tramp)
#+END_SRC

#+RESULTS:

*** Split window and move to new window

Whenever I split windows, I usually do so and also switch to the other window as well, so might as well rebind the splitting key bindings to do just that to reduce the repetition.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun vsplit-other-window ()
  "Splits the window vertically and switches to that window."
  (interactive)
  (split-window-vertically)
  (other-window 1 nil))
(defun hsplit-other-window ()
  "Splits the window horizontally and switches to that window."
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil))

(bind-key "C-x 2" 'vsplit-other-window)
(bind-key "C-x 3" 'hsplit-other-window)
#+END_SRC

#+RESULTS:
: hsplit-other-window

*** Transpose frame

Check it out here: https://www.emacswiki.org/emacs/TransposeFrame

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package transpose-frame
  :ensure t
  :bind ("C-c t" . transpose-frame))
#+END_SRC

#+RESULTS :
: transpose-frame

*** Ace-jump 
A quick way to jump around text in buffers.

See Emacs Rocks Episode 10 for a screencast: http://emacsrocks.com/e10.html

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-jump-mode
  :ensure t
  :diminish ace-jump-mode
  :commands ace-jump-mode
  :bind ("C-s-s" . ace-jump-mode))
#+END_SRC

#+RESULTS:
: ace-jump-mode



* Final message
#+source: message-line
#+begin_src emacs-lisp :tangle yes
(message "Starter Kit User (DGM) File loaded.")
#+end_src

#+RESULTS: message-line
: Starter Kit User File loaded.
