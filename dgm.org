# -*- coding: utf-8 -*-
# -*- find-file-hook: org-babel-execute-buffer -*-

#+TITLE: Local User Customizations
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args :tangle yes

Adding this line to test magit.

* Starter Kit kjhealy
This file contains local customizations---ones that in some cases
you will not be able to just drop in and use because, e.g., they
involve references to particular files on my own machine. It's
included here for completeness, and as and example of the kind of
things you might put in your own user-specific file.

Some of the settings here depend on additional software that you may
not have installed by default. E.g., the "Use GNU ls" section below
depends on you having GNU coreutils installed. To ignore these
sections, add `:tangle no` to any code block you don't want to use.

To use the customizations here yourself, /you must change the name of
this file to match your own user name or system name/. Those are the
values of the Emacs variables =user-login-name= or =system-name=, so
that it will be picked up by =init.el= when Emacs starts up, and get
loaded properly. To find the current value of these variables on your
system, launch emacs and do =C-h-v system-name [RET]= or =C-h-v
user-login-name [RET]=. For example, on my system =user-login-name=
is 'kjhealy', so this file is named =kjhealy.org=, and when Emacs
starts up with the starter kit it creates the file =kjhealy.el=.

You will also need to change the values for the location of bibtex
databases, pandoc and orgmode-mobile specified below, and some other
settings. *Search for 'kjhealy' in this file* to find the paths that
need to be updated. Change them as needed or delete them if you don't
need these features.

** Local Miscellaneous Settings
*** Use GNU ls
OS X ships with BSD's ls command which doesn't have all the features of GNU ls (used internally by dired). Install `coreutils` with homebrew (`brew install coreutils`) and use `gls` instead.

#+source: gnu-ls
#+begin_src emacs-lisp :tangle yes
(setq insert-directory-program (executable-find "ls"))
#+end_src

#+RESULTS: gnu-ls
: /bin/ls

*** One space after period

Use =M-e= for sentence-level navigation, but without having to put two spaces after a period like an animal.

#+source: periods
#+begin_src emacs-lisp :tangle yes
(setq sentence-end-double-space nil)
#+end_src

#+RESULTS: periods

*** Run Emacs in Full Screen
I find it very useful to run Emacs in full-screen mode. There is no
completely satisfactory way to accomplish this on Mac OS X. What
works depends on the flavor of emacs you are using,
unfortunately. Choose as appropriate from the following options. Enable one of them by changing the value of =:tangle= to =yes=.

Bind full screen to `C-c f`.

#+source: fullscreen-4
#+begin_src emacs-lisp :tangle yes
(defun fullscreen (&optional f)
  (interactive)
  (set-frame-parameter f 'fullscreen
                       (if (frame-parameter f 'fullscreen) nil 'fullboth)))
(global-set-key (kbd "C-c f") 'fullscreen)        
(add-hook 'after-make-frame-functions 'fullscreen)
#+end_src

#+RESULTS: fullscreen-4
| fullscreen | x-dnd-init-frame |

*** COMMENT Mac Key mode
Used with Mitsuharu Yamamoto's carbon-patched Emacs, which turns
off support for default mac bindings. Turned off by default.
#+srcname: mac-keys
#+begin_src emacs-lisp :tangle yes
(require 'mac-key-mode)
(mac-key-mode 1)
(add-hook 'mac-key-mode-hook
          (lambda()
            (interactive)
            (if mac-key-mode
                (setq mac-option-modifier 'meta)
              (setq mac-option-modifier nil)
              )))
#+end_src

** Dired
*** Date format

From: https://stackoverflow.com/questions/11269897/emacs-dired-how-to-set-date-time-format

Pero parece que esto no ha afectado al formato de Dired. En cambio, el secreto lo ha dado la definición aquí: [[dired-date]]

#+BEGIN_SRC emacs-lisp :tangle no
(setq ls-lisp-format-time-list  '("%d.%m.%Y %H:%M" "%d.%m.%Y %H:%M")
      ls-lisp-use-localized-time-format t)

(defun ls-lisp-format-time (file-attr time-index now)
  "%d.%m.%Y %H:%M" "%d.%m.%Y %H:%M")
#+END_SRC

#+RESULTS:
: ls-lisp-format-time

*** Dired-x

Dired extensions. Dired-x (Dired Extra) is not like Dired-plus. The former is part of the standard distribution of emacs. 

Modified following the advice in the *info* node on installation of =dired-x=.

#+source: Dired-x
#+begin_src emacs-lisp :tangle yes
;;  (load "dired-x")
(add-hook 'dired-load-hook
          (lambda ()
            (load "dired-x")
            ;; Set dired-x global variables here.  For example:
            ;; (setq dired-guess-shell-gnutar "gtar")
            ;; (setq dired-x-hands-off-my-keys nil)
            ))
(add-hook 'dired-mode-hook
          (lambda ()
            ;; Set dired-x buffer-local variables here.  For example:
            ;; (dired-omit-mode 1)
            ))
#+end_src

#+RESULTS: Dired-x
| (lambda nil) | (lambda nil (let ((now (lookup-key dired-mode-map J))) (if (and now (not (eq now 'undefined))) nil (define-key dired-mode-map J 'bmkp-dired-jump)) (setq now (lookup-key dired-mode-map |


Further customization that I originally had within the block on dired plus that I actually do not use!

First I set dired listing options. Originally, among the options there was a =p= in =-alDhp= but in https://www.reddit.com/r/emacs/comments/9flask/dired_mode_move_directory/ they explain that this causes failure when moving directories. The =p= flag to =ls= appends a slash (=/=) indicator to directories.

Then I added to option to list directories first that I found in https://www.emacswiki.org/emacs/DiredSorting

Also, from https://emacs.stackexchange.com/questions/2722/dired-listing-switches-time-style-format-with-a-space I have added =--time-style \"+%m-%d-%Y %H:%M:%S\""=. Esta ha sido la clave para que Dired me dé la fecha completa. <<dired-date>>

DGM 16 july 2019: Ojo: when Dired buffer sorted alphabetically, my powermode bar includes =-alDh --group-directories-first --time-style "+-Dired -alDh --group-directories-first= for some reason. This is meaningless there and leaves no room for time information, etc. It does not occur if I sort by date. Why?

#+BEGIN_SRC emacs-lisp :tangle yes
(if (eq system-type 'gnu/linux)
    (setq dired-listing-switches "-alDh --group-directories-first --time-style \"+%d-%m-%Y %H:%M:%S\"")) 

(defun ensure-buffer-name-ends-in-slash ()
  "change buffer name to end with slash"
  (let ((name (buffer-name)))
    (if (not (string-match "/$" name))
        (rename-buffer (concat name "/") t))))

(add-hook 'dired-mode-hook 'ensure-buffer-name-ends-in-slash)

(add-hook 'dired-mode-hook
          (lambda()
            (setq truncate-lines 1)))
#+END_SRC

#+RESULTS:
| (lambda nil (setq truncate-lines 1)) | ensure-buffer-name-ends-in-slash | (lambda nil (let ((now (lookup-key dired-mode-map J))) (if (and now (not (eq now 'undefined))) nil (define-key dired-mode-map J 'bmkp-dired-jump)) (setq now (lookup-key dired-mode-map |

Open files in external programs (from http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html
Consider replacing with https://github.com/thamer/runner.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-open-in-external-app (&optional file)
  "Open the current file or dired marked files in external app.
The app is chosen from your OS's preference."
  (interactive)
  (let (doIt
        (myFileList
         (cond
          ((string-equal major-mode "dired-mode")
           (dired-get-marked-files))
          ((not file) (list (buffer-file-name)))
          (file (list file)))))
    (setq doIt (if (<= (length myFileList) 5)
                   t
                 (y-or-n-p "Open more than 5 files? ")))
    (when doIt
      (cond
       ((string-equal system-type "windows-nt")
        (mapc
         (lambda (fPath)
           (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)))
         myFileList))
       ((string-equal system-type "darwin")
        (mapc
         (lambda (fPath)
           (shell-command (format "open \"%s\"" fPath)))
         myFileList))
       ((string-equal system-type "gnu/linux")
        (mapc
         (lambda (fPath)
           (let ((process-connection-type nil))
             (start-process "" nil "xdg-open" fPath))) myFileList))))))
;; use zip/unzip to compress/uncompress zip archives
(with-eval-after-load "dired-aux"
  (add-to-list 'dired-compress-file-suffixes
               '("\\.zip\\'" "" "unzip"))
  ;; open files from dired with "E"
  (define-key dired-mode-map (kbd "E") 'xah-open-in-external-app))
#+END_SRC

*** Dired open multiple files
In dired mode, visit all marked files using. Bound to the "F" key.

#+source: dired-F
#+begin_src emacs-lisp :tangle yes
(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "F" 'my-dired-find-file)
     (defun my-dired-find-file (&optional arg)
       "Open each of the marked files, or the file under the point, or when prefix arg, the next N files "
       (interactive "P")
       (let* ((fn-list (dired-get-marked-files nil arg)))
         (mapc 'find-file fn-list)))))
#+end_src

#+RESULTS: dired-F
: my-dired-find-file

*** Stripe Dired buffers

Use different background colors for even and odd lines. Info here https://github.com/sabof/stripe-buffer

With the help of library hl-line-mode yet another color can be used for the current line.

**** highlight line

#+BEGIN_SRC emacs-lisp  :tangle yes
(use-package hl-line)
;; (global-hl-line-mode t)
;;(set-face-background 'hl-line "#bebebe")
#+END_SRC

#+RESULTS:

Use different background colors for even and odd lines. With =(add-hook 'dired-mode-hook 'stripe-listify-buffer)= I could get a horizontal line instead of a cursor. It uses the stripe-hl-line face, which you might wish to customize.

#+name: stripe-dired
#+begin_src emacs-lisp :tangle yes
(use-package stripe-buffer
  :config (progn
            (add-hook 'dired-mode-hook #'turn-on-stripe-buffer-mode)))

(add-hook 'org-mode-hook 'org-table-stripes-enable)
;; (add-hook 'dired-mode-hook 'stripe-listify-buffer)  
#+END_SRC

*** diff-hl 
Emacs package for highlighting uncommitted changes. See https://github.com/dgutov/diff-hl

diff-hl-mode highlights uncommitted changes on the left side of the window, allows you to jump between and revert them selectively.

For the usage instructions and the list of commands, see the Commentary section inside the file.

Tested with Git, Mercurial, Bazaar and SVN. May work with other VC backends, too.

The package also contains auxiliary modes:

diff-hl-dired-mode provides similar functionality in Dired.
diff-hl-margin-mode changes the highlighting function to use the margin instead of the fringe.
diff-hl-amend-mode shifts the reference revision back by one.
diff-hl-flydiff-mode implements highlighting changes on the fly. It requires Emacs 24.4 or newer.

Check out the Commentary section in each respective file for the usage instructions.

#+begin_src emacs-lisp :tangle no
(use-package diff-hl)
(global-diff-hl-mode)
;; (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
(remove-hook 'dired-mode-hook 'diff-hl-dired-mode)
(remove-hook 'dired-mode-hook 'hl-line-mode)
#+END_SRC

#+RESULTS:
| (lambda nil (let ((now (lookup-key dired-mode-map J))) (if (and now (not (eq now 'undefined))) nil (define-key dired-mode-map J 'bmkp-dired-jump)) (setq now (lookup-key dired-mode-map |

** Avy Mode
From: http://oremacs.com/2016/01/23/avy-0.4.0/

For example, suppose you have:

=(global-set-key (kbd "M-t") 'avy-goto-word-1)=

Here's what you can do now to a word that starts with a "w" and is select-able with "a":

To jump there: =M-t w a=.
To copy the word instead of jumping to it: =M-t w na=
To mark the word after jumping to it: =M-t w ma=.
To kill the word after jumping to it: =M-t w xa=.

Note I have binded to =C-o= instead of =M-t=:

Further words from Uncle Dave at https://github.com/daedreth/UncleDavesEmacs:

-  avy and why it’s the best thing in existence
Many times have I pondered how I can move around buffers even quicker. I’m glad to say, that avy is precisely what I needed, and it’s precisely what you need as well. In short, as you invoke one of avy’s functions, you will be prompted for a character that you’d like to jump to in the visible portion of the current buffer. Afterwards you will notice how all instances of said character have additional letter on top of them. Pressing those letters, that are next to your desired character will move your cursor over there. Admittedly, this sounds overly complicated and complex, but in reality takes a split second and improves your life tremendously.

I like M-s for it, same as C-s is for moving by searching string, now M-s is moving by searching characters.

#+name: avy-mode
#+begin_src emacs-lisp :tangle yes
(use-package avy
  :ensure t
  :bind
  ("s-z" . avy-goto-char))  ;; goes literally to any char

(define-key global-map (kbd "C-o") 'avy-goto-word-1) ;; goes to word that starts with a given char
#+end_src

#+RESULTS: avy-mode
: avy-goto-word-1

* dgm's own customizations of emacs appearance
** GROUP: Convenience -> Linum

Next tip from http://tuhdo.github.io/emacs-tutor3.html
It enables linum only in programming modes

#+srcname: line-numbering
#+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'linum-mode)
#+end_src

#+RESULTS: line-numbering
| linum-mode | (lambda nil (highlight-symbol-mode)) | highlight-numbers-mode | clean-aindent-mode |

Tip from https://www.emacswiki.org/emacs/SmoothScrolling

#+BEGIN_SRC emacs-lisp :tangle yes
;; Delay updates to give Emacs a chance for other changes
(setq linum-delay t)
#+END_SRC

** GROUP: Convenience -> Whitespace

Whenever you create useless whitespace, the whitespace is highlighted

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))

;; activate whitespace-mode to view all whitespace characters
(global-set-key (kbd "C-c w") 'whitespace-mode)
#+END_SRC    

#+RESULTS:
: whitespace-mode

*** speed-type

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package speed-type)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23592 62602 668192 845000) :init (23592 62602 668160 862000) :config (23592 62602 667754 576000) :config-secs (0 0 16 248000) :init-secs (0 0 713 570000) :use-package-secs (0 0 795 338000)))

*** iedit mode
Edit multiple regions in the same way simultaneously

Check this post: https://www.masteringemacs.org/article/iedit-interactive-multi-occurrence-editing-in-your-buffer

#+begin_src emacs-lisp :tangle yes
(use-package iedit
  :bind (("C-;" . iedit-mode))
  :init
  (setq iedit-toggle-key-default nil))

;; (use-package iedit)

;; activate this function by Mickey Petersen if you wish to use iedit only in current function and not all across the buffer.
;; (defun iedit-dwim (arg)
;;   "Starts iedit but uses \\[narrow-to-defun] to limit its scope."
;;   (interactive "P")
;;   (if arg
;;       (iedit-mode)
;;     (save-excursion
;;       (save-restriction
;;         (widen)
;;         ;; this function determines the scope of `iedit-start'.
;;         (if iedit-mode
;;             (iedit-done)
;;           ;; `current-word' can of course be replaced by other
;;           ;; functions.
;;           (narrow-to-defun)
;;           (iedit-start (current-word) (point-min) (point-max)))))))

;; (global-set-key (kbd "C-;") 'iedit-dwim)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23923 33588 648715 416000) :init (23923 33588 648494 532000) :config (23923 33588 648444 279000) :config-secs (0 0 14 458000) :init-secs (0 0 138 844000) :use-package-secs (0 0 561 588000)))

** =ggtags= customization from tuhdo

#+srcname: ggtags-customization
#+begin_src emacs-lisp :tangle yes
(add-hook 'c-mode-common-hook
          (lambda ()
            (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
              (ggtags-mode 1))))
#+end_src

#+RESULTS: ggtags-customization
| lambda | nil | (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode) (ggtags-mode 1))       |
| lambda | nil | (if (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode) (progn (ggtags-mode 1))) |

#+RESULTS:
| lambda | nil | (when (derived-mode-p (quote c-mode) (quote c++-mode) (quote java-mode) (quote asm-mode)) (ggtags-mode 1)) |

** GROUP: Editing -> Editing Basics from http://tuhdo.github.io/emacs-tutor3.html

*** ring-max

#+srcname: ring-max
#+BEGIN_SRC emacs-lisp :tangle yes
(setq global-mark-ring-max 5000     ; increase mark ring to contain 5000 entries
      mark-ring-max 5000            ; increase kill ring to contain 5000 entries
      mode-require-final-newline t) ; add a newline to end of file
#+END_SRC

#+RESULTS: ring-max
: t

#+RESULTS:
: 5000

#+srcname: killing
#+BEGIN_SRC emacs-lisp :tangle yes
(setq
 kill-ring-max 5000 ; increase kill-ring capacity
 ;; kill-whole-line t  ; if NIL, killwhole line and move the next line up / commented out by dgm as it might interfere with kill-whole-line-or-region mode
 )
#+END_SRC

#+RESULTS: killing
: t

#+RESULTS:
: t

*** tab-width

Default to 4 visible spaces to display a tab. Sacha has it at 2: =(setq-default tab-width 2)=; tuhdo at 4.

#+srcname: tab-width
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default tab-width 4)

(add-hook 'sh-mode-hook (lambda ()
                          (setq tab-width 4)))
#+END_SRC

#+RESULTS: tab-width
| lambda | nil | (setq tab-width 4) |

*** workgroups

From https://github.com/pashinin/workgroups2 and http://tuhdo.github.io/emacs-tutor3.html

#+BEGIN_SRC emacs-lisp :tangle yes
;; (require 'workgroups2)

;; Change workgroups session file
;; (setq wg-session-file "~/.emacs.d/.emacs_workgroups")
;; (wg-find-session-file "~/.emacs.d/.emacs_workgroups") ;; for emacs to load this file on startup... but it doesn't work... don't know why...

;; Set your own keyboard shortcuts to reload/save/switch WGs:
;; "s" == "Super" or "Win"-key, "S" == Shift, "C" == Control
;; (global-set-key (kbd "<pause>")     'wg-reload-session)
;; (global-set-key (kbd "C-S-<pause>") 'wg-save-session)
;; (global-set-key (kbd "s-z")         'wg-switch-to-workgroup)
;; (global-set-key (kbd "s-/")         'wg-switch-to-previous-workgroup)

;; What to do on Emacs exit / workgroups-mode exit?
;; (setq wg-emacs-exit-save-behavior           'save)      ; Options: 'save 'ask nil
;; (setq wg-workgroups-mode-exit-save-behavior 'save)      ; Options: 'save 'ask nil

;; (workgroups-mode 1)   ; put this one at the bottom of .emacs
#+END_SRC

#+RESULTS:

*** diff-mode 
#+srcname: whitespace
#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'diff-mode-hook (lambda ()
                            (setq-local whitespace-style
                                        '(face
                                          tabs
                                          tab-mark
                                          spaces
                                          space-mark
                                          trailing
                                          indentation::space
                                          indentation::tab
                                          newline
                                          newline-mark))
                            (whitespace-mode 1)))
#+END_SRC

*** Attach multiple files

Attach multiple files to mu4e email message. (Tip from http://www.djcbsoftware.nl/code/mu/mu4e/Attaching-files-with-dired.html).

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'gnus-dired)
;; make the `gnus-dired-mail-buffers' function also work on
;; message-mode derived modes, such as mu4e-compose-mode
(defun gnus-dired-mail-buffers ()
  "Return a list of active message buffers."
  (let (buffers)
    (save-current-buffer
      (dolist (buffer (buffer-list t))
        (set-buffer buffer)
        (when (and (derived-mode-p 'message-mode)
                   (null message-sent-message-via))
          (push (buffer-name buffer) buffers))))
    (nreverse buffers)))

(setq gnus-dired-mail-mode 'mu4e-user-agent)
(add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
#+END_SRC

#+RESULTS:
| diff-hl-dired-mode | stripe-listify-buffer | (lambda nil (setq truncate-lines 1)) | ensure-buffer-name-ends-in-slash | (lambda nil) | turn-on-gnus-dired-mode | helm-gtags-mode |

*** Volatile 

=volatile= makes so that when you yank (paste) something, the yanked (pasted) region will be highlighted.
See http://tuhdo.github.io/emacs-tutor3.html

#+srcname: volatile
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package volatile-highlights)
(volatile-highlights-mode t)
#+END_SRC

#+RESULTS: volatile
: t

#+RESULTS:
: t

*** Clean-indent
Emacs extension for clean auto-indent and backspace unindent.

Includes:
- An auto-indent function (RET) that takes care to delete any unused white spaces
- An unindent function (M-backspace) that aligns the cursor position to match indentation of best candidate from lines above
- Simple auto-indent mode (activate via M-x customize) that disregards smart language based indentation and instead consistently aligns only based on indentation of the line above

#+srcname: clean-indent
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package clean-aindent-mode)
(add-hook 'prog-mode-hook 'clean-aindent-mode)

(defun my-pkg-init()
  (electric-indent-mode -1)  ; no electric indent, auto-indent is sufficient
  (clean-aindent-mode t)
  (setq clean-aindent-is-simple-indent t)
  (define-key global-map (kbd "RET") 'newline-and-indent))
(add-hook 'after-init-hook 'my-pkg-init)
#+END_SRC

#+RESULTS: clean-indent
| my-pkg-init | #[0 \303\211\235\203 \304"\301\305!\210\210	\205 \306 \210\307\211\207 [command-line-args desktop-save-mode inhibit-startup-screen --no-desktop delete 0 desktop-read t] 4] | global-company-mode | ambrevar/reset-file-name-handler-alist | ambrevar/reset-gc-cons-threshold | x-wm-set-size-hint | tramp-register-archive-file-name-handler | table--make-cell-map | magit-auto-revert-mode--init-kludge | magit-startup-asserts | magit-version |

*** dtrt-indent
A minor mode that guesses the indentation offset originally used for creating source code files and transparently adjusts the corresponding settings in Emacs, making it more convenient to edit foreign files.

#+begin_src emacs-lisp :tangle yes
(use-package dtrt-indent
  :init
  (dtrt-indent-mode 1)
  (setq dtrt-indent-verbosity 0))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23923 32766 535721 489000) :init (23923 32766 535713 86000) :config (23923 32766 535556 330000) :config-secs (0 0 5 314000) :init-secs (0 0 50666 683000) :use-package-secs (0 2 301402 504000)))

*** ws-butler -- an unobtrusive way to trim spaces from end of line

- Only lines touched get trimmed. If the white space at end of buffer is changed, then blank lines at the end of buffer are truncated respecting require-final-newline.

- Trimming only happens when saving.

- What does unobtrusive mean? The user is not made explicitly aware when trimming happens. You keep working and the butler takes care of whitespace for you. This means if point is at a location that was trimmed, point is not moved, but the data on disk has been cleaned up (revert the buffer to confirm).

#+begin_src emacs-lisp :tangle yes
(use-package ws-butler
  :init
  (add-hook 'prog-mode-hook 'ws-butler-mode)
  (add-hook 'text-mode 'ws-butler-mode)
  (add-hook 'fundamental-mode 'ws-butler-mode))
#+end_src

*** Undo-tree 

undo-tree set up from http://pragmaticemacs.com/emacs/advanced-undoredo-with-undo-tree/
More info here: https://www.emacswiki.org/emacs/UndoTree

Sacha Chua says: People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo. 

This lets you use C-x u (undo-tree-visualize) to visually walk through the changes you've made, undo back to a certain point
(or redo), and go down different branches. 

#+srcname: undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode 1)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))

;; make ctrl-z undo
(global-set-key (kbd "C-z") 'undo)
;; make ctrl-Z redo
(defalias 'redo 'undo-tree-redo)
(global-set-key (kbd "C-S-z") 'redo)
#+END_SRC

#+RESULTS: undo-tree
: redo

See https://www.reddit.com/r/emacs/comments/5h7k1r/undo_lost_hours_of_work//
Also read http://ergoemacs.org/emacs/emacs_undo_cult_problem.html
However, with =helm-ag= I'm getting errors that seem related to undo-tree, plus I got issues with the git repository changing just because of the undo history and it is not worthwhile, so I comment this out.


#+BEGIN_SRC emacs-lisp :tangle no
;;(setq undo-tree-auto-save-history t)
;;(setq undo-tree-history-directory-alist
;;    (quote (("" . "~/.emacs.d/undo_hist"))))
#+END_SRC

#+RESULTS:
: t

*** COMMENT auto-file-revert

See: http://pragmaticemacs.com/emacs/automatically-revert-buffers/

If you want Emacs to automatically update a buffer if a file changes on disk, then add the following to your config:

#+BEGIN_SRC emacs-lisp :tangle no
;; update any change made on file to the current buffer
(global-auto-revert-mode t)
#+END_SRC

#+RESULTS:
: t

Of course, if your buffer has unsaved changes when the file changes on disk, then Emacs will prompt you and your changes won’t be lost.

This mode only applies to buffers associated with files on the disk, but I like to have my dired view updated if the contents of a directory change. This is accomplished with the following code:

#+BEGIN_SRC emacs-lisp :tangle no
;; auto refresh dired when file changes
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC

#+RESULTS:
| auto-revert-mode | (lambda nil (let ((now (lookup-key dired-mode-map J))) (if (and now (not (eq now 'undefined))) nil (define-key dired-mode-map J 'bmkp-dired-jump)) (setq now (lookup-key dired-mode-map |

*** fill-column 

#+srcname: fill-column
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default fill-column 72)
#+END_SRC

*** ibuffer-use-other-window

#+srcname: ibuffer
#+BEGIN_SRC emacs-lisp :tangle yes
;; always display ibuffer in another window
(setq ibuffer-use-other-window t)
#+END_SRC

*** COMMENT Company mode 

Included in =starter-kit-completion.org=

#+srcname: company
#+BEGIN_SRC emacs-lisp :tangle no
;; (add-hook 'after-init-hook 'global-company-mode) 
#+END_SRC

#+RESULTS: company
| my-pkg-init | #[0 \303\211\235\203 \304"\301\305!\210\210	\205 \306 \210\307\211\207 [command-line-args desktop-save-mode inhibit-startup-screen --no-desktop delete 0 desktop-read t] 4] | global-company-mode | ambrevar/reset-file-name-handler-alist | ambrevar/reset-gc-cons-threshold | x-wm-set-size-hint | tramp-register-archive-file-name-handler | table--make-cell-map | magit-auto-revert-mode--init-kludge | magit-startup-asserts | magit-version |

*** Duplicate-thing

#+srcname: duplicate
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package duplicate-thing)
(global-set-key (kbd "M-D") 'duplicate-thing)
#+END_SRC

#+srcname: ibuffer-vc
#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'ibuffer-hook
          (lambda ()
            (ibuffer-vc-set-filter-groups-by-vc-root)
            (unless (eq ibuffer-sorting-mode 'alphabetic)
              (ibuffer-do-sort-by-alphabetic))))

(setq ibuffer-formats
      '((mark modified read-only vc-status-mini " "
              (name 18 18 :left :elide)
              " "
              (size 9 -1 :right)
              " "
              (mode 16 16 :left :elide)
              " "
              (vc-status 16 16 :left)
              " "
              filename-and-process)))
#+END_SRC

#+RESULTS: ibuffer-vc
| mark | modified | read-only | vc-status-mini |   | (name 18 18 :left :elide) |   | (size 9 -1 :right) |   | (mode 16 16 :left :elide) |   | (vc-status 16 16 :left) |   | filename-and-process |

*** Dired plus

#+srcname: dired+
#+BEGIN_SRC emacs-lisp :tangle yes
;; (require 'dired+)

;; copied  by dgm from: http://emacs-leuven.readthedocs.io/en/latest/?badge=latest

;; Don't hide details in Dired.
;;    (setq diredp-hide-details-initially-flag nil)

;; Don't display the next Dired buffer the same way as the last.
;;    (setq diredp-hide-details-propagate-flag nil)

;; Don't wrap "next" command around to buffer beginning.
;; (setq diredp-wrap-around-flag nil)

;; Dired `find-file' commands reuse directories.
;; (diredp-toggle-find-file-reuse-dir 1)

;; Up, reusing Dired buffers.
;; (define-key dired-mode-map (kbd "C-x C-j")
;;  #'diredp-up-directory-reuse-dir-buffer)

;; tips from Ista Zahn. Not sure if they require dired+
;; https://github.com/izahn/dotemacs

;;; Dired and Dired+ configuration
;; this is commented as it is reapplied somewhere else in this file
;; (add-hook 'dired-mode-hook
;;          (lambda()
;;            (diff-hl-dired-mode)
;;            (diff-hl-margin-mode)))

#+END_SRC

Set emacs to open Bookmark+ on start. From Xah Emacs. Disabled now that I use =Dashboard=

#+srcname: bookmarks
#+BEGIN_SRC emacs-lisp :tangle no
;; included by dgm
;;   (setq inhibit-splash-screen t)
;; (require 'bookmark+) ;; no longer available in MELPA
;;  (bookmark-bmenu-list)
;;  (switch-to-buffer "*Bookmark List*")
;; '(initial-buffer-choice "*Bookmark List*")
;; (setq initial-buffer-choice "*Bookmark List*")
#+END_SRC


#+RESULTS: bookmarks


#+srcname: custom-setup
#+BEGIN_SRC emacs-lisp :tangle no
;;    Load the files in CustomDir using mapc:
;; (mapc 'load (directory-files "~/.emacs.d/customDir" t ".*\.el"))
;; (add-to-list 'load-path "~/.emacs.d/customDir/")
;; (require 'setup-programming)
#+END_SRC


I disable this as flycheck makes emacs too slow.
#+srcname: flycheck-tip
#+BEGIN_SRC emacs-lisp :tangle yes
;;  (require 'flycheck-tip)
;;  (define-key global-map (kbd "\C-c \C-n") 'flycheck-tip-cycle)
;;  (setq flycheck-display-errors-function 'ignore)
#+END_SRC

#+RESULTS: flycheck-tip
: ignore

#+RESULTS:
: ignore


For now, I deactivate the golden-ratio mode because it distract me too much.

#+srcname: golden-ratio
#+BEGIN_SRC emacs-lisp :tangle no
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PACKAGE: golden-ratio                         ;;
;;                                               ;;
;; GROUP: Environment -> Windows -> Golden Ratio ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; activate for helm when helm is installed
;; (require 'golden-ratio)

;; (add-to-list 'golden-ratio-exclude-modes "ediff-mode")
;; (add-to-list 'golden-ratio-exclude-modes "helm-mode")
;; (add-to-list 'golden-ratio-exclude-modes "dired-mode")
;; (add-to-list 'golden-ratio-exclude-modes "ess-mode")

;; I dont want the golden ratio with the Helm window
;;  (defun pl/helm-alive-p ()
;;   (if (boundp 'helm-alive-p)
;;       (symbol-value 'helm-alive-p)))

;;  (add-to-list 'golden-ratio-inhibit-functions 'pl/helm-alive-p)

;; do not enable golden-ratio in theses modes
;;   (setq golden-ratio-exclude-modes '("ediff-mode"
;;                                      "gud-mode"
;;                                      "gdb-locals-mode"
;;                                      "gdb-registers-mode"
;;                                      "gdb-breakpoints-mode"
;;                                      "gdb-threads-mode"
;;                                      "gdb-frames-mode"
;;                                      "gdb-inferior-io-mode"
;;                                      "gud-mode"
;;                                      "gdb-inferior-io-mode"
;;                                      "gdb-disassembly-mode"
;;                                      "gdb-memory-mode"
;;   ;;                                   "magit-log-mode"
;;   ;;                                   "magit-reflog-mode"
;;   ;;                                   "magit-status-mode"
;;                                      "IELM"
;;                                      "eshell-mode"
;;                                      "dired-mode"
;;                                      "helm-mode"
;;                                      "ess-mode"))
;; delete "dired-mode"  from the above list if you want golden-ratio to apply to helm

;;   (golden-ratio-mode)
#+END_SRC

#+RESULTS: golden-ratio :tangle no


I disable this as it is dealt with in -misc.org
#+srcname: frame-title
#+BEGIN_SRC emacs-lisp :tangle no
;; more useful frame title, that show either a file or a
;; buffer name (if the buffer isn't visiting a file)
;; taken from prelude-ui.el
;; (setq frame-title-format
;;      '("" invocation-name " - " (:eval (if (buffer-file-name)
;;                                                    (abbreviate-file-name (buffer-file-name))
;;                                                  "%b"))))
#+END_SRC

#+RESULTS: frame-title
|   | invocation-name | - | (:eval (if (buffer-file-name) (abbreviate-file-name (buffer-file-name)) %b)) |

*** highlight-numbers-and-symbols

#+srcname: highlight-numbers-and-symbols
#+BEGIN_SRC emacs-lisp :tangle yes

(use-package highlight-numbers)
(use-package highlight-symbol)

(add-hook 'prog-mode-hook 'highlight-numbers-mode)

(highlight-symbol-nav-mode)

(add-hook 'prog-mode-hook (lambda () (highlight-symbol-mode)))
(add-hook 'org-mode-hook (lambda () (highlight-symbol-mode)))

(setq highlight-symbol-idle-delay 0.2
      highlight-symbol-on-navigation-p t)

(global-set-key [(control shift mouse-1)]
                (lambda (event)
                  (interactive "e")
                  (goto-char (posn-point (event-start event)))
                  (highlight-symbol-at-point)))

;; keybinds conflict so...
;;(global-set-key (kbd "M-n") 'highlight-symbol-next)
;;(global-set-key (kbd "M-p") 'highlight-symbol-prev)
#+END_SRC

#+RESULTS: highlight-numbers-and-symbols
| lambda | (event) | (interactive e) | (goto-char (posn-point (event-start event))) | (highlight-symbol-at-point) |

*** Info Plus
#+srcname: info+
#+BEGIN_SRC emacs-lisp :tangle yes
;; (use-package info+) ;;no longer available in MELPA?
#+END_SRC

#+RESULTS: info+
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23561 13963 178544 695000) :init (23561 13963 178532 465000) :init-secs (0 0 15510 311000) :use-package-secs (0 4 529907 38000)))

*** Discover my major 
#+srcname: discover-my-major
#+BEGIN_SRC emacs-lisp :tangle yes
;; A quick major mode help with discover-my-major
(global-unset-key (kbd "C-h h"))        ; original "\C-h h" displays "hello world" in different languages
(define-key 'help-command (kbd "h m") 'discover-my-major)
#+END_SRC

#+RESULTS: discover-my-major
: discover-my-major

*** Rainbow mode
#+srcname: rainbow-mode
#+BEGIN_SRC emacs-lisp :tangle yes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PACKAGE: rainbow-mode              ;;
;;                                    ;;
;; GROUP: Help -> Rainbow             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(use-package rainbow-mode
  :ensure t
  :config
  (add-hook 'prog-mode-hook         #'rainbow-mode)
  (add-hook 'html-mode-hook         #'rainbow-mode)
  (add-hook 'css-mode-hook          #'rainbow-mode)
  (add-hook 'org-mode-hook          #'rainbow-mode)
  (add-hook 'latex-mode-hook        #'rainbow-mode)
  (add-hook 'R-mode-hook            #'rainbow-mode)
  (add-hook 'inferior-ess-mode-hook #'rainbow-mode)
  (add-hook 'python-mode-hook       #'rainbow-mode)
  )

;;R-mode-hook runs when you open a new source buffer, so anything you put in that will only affect your source buffers.inferior-ess-mode-hook runs when you start an R console, so anything in there should only apply to the console buffer and not the source.
#+END_SRC

#+RESULTS: rainbow-mode
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23593 1042 76652 672000) :init (23593 1042 76606 522000) :config (23593 1042 76259 444000) :config-secs (0 0 777 90000) :init-secs (0 0 1377 923000) :use-package-secs (0 0 1502 38000)))

*** Kurecolor

- See this video to watch it live: https://www.youtube.com/watch?v=OMIxZhLU71U

- Documentation here: https://github.com/emacsfodder/kurecolor

- Currently not working. Need to revisit in future.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package kurecolor
  :ensure t)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23692 57023 62709 930000) :init (23692 57023 62697 750000) :config (23692 57023 62080 799000) :config-secs (0 0 26 151000) :init-secs (0 0 1129 806000) :use-package-secs (0 0 1239 736000)))

*** Nyam-mode

Only turn on if a window system is available. This prevents error under terminal that does not support X.

#+srcname: nyan-mode
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nyan-mode)

(case window-system
  ((x w32) (nyan-mode)))
#+END_SRC

#+RESULTS: nyan-mode
: t


#+srcname: spaceline
#+BEGIN_SRC emacs-lisp :tangle yes
;; (require 'spaceline-config)
;; (spaceline-emacs-theme)
;; (spaceline-helm-mode)
#+END_SRC

#+RESULTS: spaceline
: t


#+srcname: powerline
#+begin_src emacs-lisp :tangle no
;;  (require 'powerline)
;;  (powerline-default-theme)
#+end_src

#+srcname: modeline
#+begin_src emacs-lisp :tangle yes
;; (require 'smart-mode-line)
;;       (require 'smart-mode-line-powerline-theme)
;;       (sml/apply-theme 'powerline)


;; (setq powerline-arrow-shape 'curve)
;; (setq powerline-default-separator-dir '(right . left))
;; (setq sml/theme 'powerline)
;; (setq sml/mode-width 0)
;; (setq sml/name-width 20)
;; (rich-minority-mode 1)
;; (setf rm-blacklist "")
;; (sml/setup)


;; (if (require 'smart-mode-line nil 'noerror)
;;     (progn
;;       (setq sml/name-width 20)
;;       (setq sml/mode-width 'full)
;;       (setq sml/shorten-directory t)
;;       (setq sml/shorten-modes t)
;;
;;       (rich-minority-mode 1)
;; ;;      (setq rm-blacklist '(" GitGutter" " MRev" " company" " mate" " Projectile"))
;;
;;       (if after-init-time
;;         (sml/setup)
;;         (add-hook 'after-init-hook 'sml/setup))))
;;
;; Alternatives:
;; (sml/apply-theme 'powerline)
;; (sml/apply-theme 'dark)
;; (sml/apply-theme 'light)
;; (sml/apply-theme 'respectful)
;; (sml/apply-theme 'automatic)

;;      (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/" ":DB:"))
;;      (add-to-list 'sml/replacer-regexp-list '("^~/Code/" ":CODE:"))
;;      (add-to-list 'sml/replacer-regexp-list '("^:CODE:investor-bridge" ":IB:"))
;;      (add-to-list 'sml/replacer-regexp-list '("^~/.*/lib/ruby/gems" ":GEMS" ))))
#+end_src

*** Stata

Disabled in order to use ESS default stata mode because this =ado= mode does not allow interacting with Stata (only does for MacOs and Windows).

#+BEGIN_SRC emacs-lisp :tangle no
(add-to-list 'load-path "/home/dgm/.emacs.d/src/ado-mode-1.15.1.4/lisp")
(require 'ado-mode)
#+END_SRC

#+RESULTS:
: ado-mode

*** Which-key
This mode shows a keymap when an incomplete command is entered. It is especially useful for families of commands with a prefix, e.g., =C-c C-o= for outline-mode commands, or ==C-c C-v= for org-babel commands. Just start ktyping your command and pause if you want a hint.

tip from: https://github.com/izahn/dotemacs

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package which-key
  :ensure t
  :config
  (which-key-mode))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23710 39126 376820 348000) :init (23710 39126 376764 98000) :config (23710 39126 376103 227000) :config-secs (0 0 1005 744000) :init-secs (0 0 2188 552000) :use-package-secs (0 0 2389 726000)))

*** General REPL (comint) config
Tip from: https://github.com/izahn/dotemacs

Many programs using REPLs are derived from comint-mode, so we can affect all of them by changing comint-mode settings. Here we disable line wrapping and ask programs to echo the input.

Load eval-in-repl for bash, elisp, and python interaction.

#+BEGIN_SRC emacs-lisp :tangle yes
;; require the main file containing common functions
(use-package eval-in-repl
  :ensure t
  :config 
  (setq comint-process-echoes t)
  ;; truncate lines in comint buffers
  (add-hook 'comint-mode-hook
            (lambda()
              (setq truncate-lines 1)))
  ;; Scroll down for input and output
  (setq comint-scroll-to-bottom-on-input t)
  (setq comint-scroll-to-bottom-on-output t)
  (setq comint-move-point-for-output t))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23547 54059 64969 29000) :init (23547 54059 64933 102000) :config (23547 54059 64322 241000) :config-secs (0 0 1142 991000) :init-secs (0 0 2390 167000) :use-package-secs (0 0 2547 628000)))

*** Comint fix

From: https://www.emacswiki.org/emacs/ComintMode

Comint mode is a package that defines a general command-interpreter-in-a-buffer. The idea is that you can build specific process-in-a-buffer modes on top of comint mode – e.g., lisp, shell, scheme, T, soar, …. This way, all these specific packages share a common base functionality, and a common set of bindings, which makes them easier to use (and saves code, implementation time, etc., etc.).

When closing many processes, from shell to racket, I get a comint error like this:

#+BEGIN_EXAMPLE
Debugger entered--Lisp error: (wrong-type-argument processp nil)
  process-mark(nil)
  ansi-color-process-output("")
  run-hook-with-args(ansi-color-process-output "")
  comint-send-input()
  funcall-interactively(comint-send-input)
  call-interactively(comint-send-input nil nil)
  command-execute(comint-send-input)
#+END_EXAMPLE

I'm trying to fix this.

First tip from https://www.reddit.com/r/emacs/comments/8y144a/avoid_accidental_execution_in_comint_mode/

#+BEGIN_SRC emacs-lisp :tangle yes
(setq comint-get-old-input (lambda () (end-of-buffer) (comint-get-old-input-default)))
#+END_SRC

#+RESULTS:
| lambda | nil | (end-of-buffer) | (comint-get-old-input-default) |

**** Trying to avoid the error about "ansi-color-process-output("")"

For =(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)= to have an effect, =ansi-color-process-output= must be in =comint-output-filter-functions=. If not, use the following line to add it.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
#+END_SRC

#+RESULTS:
| ansi-color-process-output | comint-postoutput-scroll-to-bottom | comint-watch-for-password-prompt |

*** COMMENT shx

Commented out in an attempt to speed up evaluation in R and Stata... and BINGO!!! this was the little motherfucker that made R and Stata super slow interactively. It also caused an error on exit.

Enhance comint-mode. See https://github.com/riscy/shx-for-emacsl

#+BEGIN_SRC emacs-lisp :tangle no
(use-package shx            
  :ensure t
  :init (shx-global-mode 1))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23563 38338 822346 339000) :init (23563 38338 822317 934000) :config (23563 38338 821844 459000) :config-secs (0 0 13 374000) :init-secs (0 0 2171 786000) :use-package-secs (0 0 2344 520000)))

Alternativa from https://github.com/malb/emacs.d/blob/master/malb.org

#+BEGIN_SRC emacs-lisp :tangle no
(use-package shx
  :after comint
  :config (progn
            ;;(with-eval-after-load 'python
            ;;  (add-hook 'inferior-python-mode-hook #'shx-mode))
            ;; (with-eval-after-load 'sage-shell-mode
            ;;   (add-hook 'sage-shell-mode-hook #'shx-mode))
            (with-eval-after-load 'shell
              (add-hook 'shell-mode-hook #'shx-mode)))
  ;; from https://github.com/riscy/shx-for-emacs
  (setq
   ;; vastly improve display performance by breaking up long output lines
   shx-max-output 1024
   ;; prevent input longer than macOS's typeahead buffer from going through
   shx-max-input 1024
   ;; prefer inlined images to have a height of 250 pixels
   shx-img-height 250
   ;; don't show any incidental hint messages about how to use shx
   shx-show-hints nil
   ;; flash the previous comint prompt for a full second when using C-c C-p
   shx-flash-prompt-time 1.0
   ;; use `#' to prefix shx commands instead of the default `:'
   shx-leader "#"))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23563 39460 592701 842000) :init (23563 39460 592655 127000) :config (23563 39460 592361 613000) :config-secs (0 0 651 835000) :init-secs (0 0 1187 492000) :use-package-secs (0 0 1286 219000)))

*** Run R in emacs (ESS)
Tip from: https://github.com/izahn/dotemacs

Support for R in Emacs is good, thanks to http://ess.r-project.org/. As with other programming languages this configuration enables completion via the tab key and code evaluation with C-ret. Many more features are provided by ESS, refer to http://ess.r-project.org/ for details.

#+begin_src emacs-lisp :tangle yes
  ;;;  ESS (Emacs Speaks Statistics)

;; ;; Start R in the working directory by default
;; (setq ess-ask-for-ess-directory nil)
;;
;; ;; Make sure ESS is loaded before we configure it
;; (autoload 'julia "ess-julia" "Start a Julia REPL." t)
;; (with-eval-after-load "ess-site"
;;   ;; disable ehoing input
;;   (setq ess-eval-visibly nil)
;;   ;; Start R in the working directory by default
;;   (setq ess-ask-for-ess-directory nil)
;;   ;; Use tab completion
;;   (setq ess-tab-complete-in-script t)
;;   ;; extra ESS stuff inspired by https://github.com/gaborcsardi/dot-emacs/blob/master/.emacs
;;   (ess-toggle-underscore nil)
;;   (defun my-ess-execute-screen-options (foo)
;;     "cycle through windows whose major mode is inferior-ess-mode and fix width"
;;     (interactive)
;;     (setq my-windows-list (window-list))
;;     (while my-windows-list
;;       (when (with-selected-window (car my-windows-list) (string= "inferior-ess-mode" ;; major-mode))
;;         (with-selected-window (car my-windows-list) (ess-execute-screen-options t)))
;;       (setq my-windows-list (cdr my-windows-list))))
;;   (add-to-list 'window-size-change-functions 'my-ess-execute-screen-options)
;;   (define-key ess-mode-map (kbd "<C-return>") ;; 'ess-eval-region-or-function-or-paragraph-and-step)
;;   ;; truncate long lines in R source files
;;   (add-hook 'ess-mode-hook
;;             (lambda()
;;               ;; don't wrap long lines
;;               (toggle-truncate-lines t)
;;               (outline-minor-mode t))))
#+end_src

Note: for me "C-return" does not work... Comento todo esto porque me temo que entra en conflicto con la costumization del gran Kieran Healy en =starter-kit-stats.org= donde veo que la evaluación está bound a =shift-return= and that works indeed for me.

*** emacs lisp REPL (ielm)
Tip from: https://github.com/izahn/dotemacs

If you want to get the most out of Emacs, you’ll eventually need to learn a little Emacs-lisp. This configuration helps by providing a standard C-ret evaluation key binding, and by providing completion with the tab key.

#+begin_src emacs-lisp :tangle yes
(with-eval-after-load "elisp-mode"
  (require 'company-elisp)
  ;; ielm
  (require 'eval-in-repl-ielm)
  ;; For .el files
  (define-key emacs-lisp-mode-map "C-c C-c" 'eir-eval-in-ielm)
  (define-key emacs-lisp-mode-map (kbd "<C-return>") 'eir-eval-in-ielm)
  ;; For *scratch*
  (define-key lisp-interaction-mode-map "C-c C-c" 'eir-eval-in-ielm)
  (define-key emacs-lisp-mode-map (kbd "<C-return>") 'eir-eval-in-ielm)
  ;; For M-x info
  (define-key Info-mode-map "C-c C-c" 'eir-eval-in-ielm)
  ;; Set up completions
  (add-hook 'emacs-lisp-mode-hook
            (lambda()
              ;; make sure completion calls company-elisp first
              (require 'company-elisp)
              (setq-local company-backends
                          (delete-dups (cons 'company-elisp (cons 'company-files company-backends)))))))
#+end_src

#+RESULTS:
| (lambda nil (require 'company-elisp) (setq-local company-backends (delete-dups (cons 'company-elisp (cons 'company-files company-backends))))) | esk-remove-elc-on-save | run-starter-kit-coding-hook | turn-on-eldoc-mode |

*** Demonstration tools (command-log-mode)

Tip from: https://github.com/izahn/dotemacs

=command-log-mode= is useful for giving emacs demonstrations/tutorials. It shows the keys you’ve pressed and the commands they called.

#+begin_src emacs-lisp :tangle yes
;;(setq command-log-mode-auto-show t)
;;(global-set-key (kbd "\C-x c l") 'global-command-log-mode)
#+end_src

#+RESULTS:
: global-command-log-mode

Good idea but it seems that I don't have the =command-log-mode=... ah, it's a package. i will install in future.

*** auto-complete
Following Drew advice on setting up emacs as a Python IDE (https://www.youtube.com/watch?v=6BlTGPsjGJk).

Gives basic auto completion for most programming modes. But doesn't know syntax. However, it has a nice interface for other packages providing completions like =jedi=.

For now I comment it out because following Drew's advice has meant that I've lost auto completion in elpy mode.

#+begin_src emacs-lisp :tangle yes
;; (require 'auto-complete-config)
;; (ac-config-default)

;; if you really like the menu
;;(setq ac-show-menu-immediately-on-auto-complete t)
#+end_src

#+RESULTS:
: t

** Other stuff from Tuhdo
- Stuff from http://tuhdo.github.io/emacs-tutor3.html

*** New beginning of line
Sometimes, we want to adjust or improve the behaviours of some commands in certain contexts. Consider this situation: C-a, which runs move-beginning-of-line, always move to the beginning of line. However, sometimes we don't always to move to the beginning of line, but move to the first non-whitespace character of that line.

See http://tuhdo.github.io/emacs-tutor3.html

#+BEGIN_SRC emacs-lisp :tangle yes
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Customized functions                ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun prelude-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first. If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key (kbd "\C-a") 'prelude-move-beginning-of-line)
#+END_SRC

#+RESULTS:
: prelude-move-beginning-of-line

*** Recent files.

Info from  https://www.emacswiki.org/emacs/RecentFiles

Recentf is a minor mode that builds a list of recently opened files. This list is is automatically saved across sessions on exiting Emacs - you can then access this list through a command or the menu.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package recentf
  :ensure t)

(recentf-mode 1)
(setq recentf-max-menu-items 25)
(setq recentf-max-saved-items 25)
(global-set-key "\C-x\ \C-r" 'recentf-open-files)
(setq recentf-auto-cleanup 'never)
#+END_SRC

#+RESULTS:
: never

By default, Recentf saves the list of recent files on exiting Emacs (specifically, `recentf-save-list` is called on `kill-emacs-hook`). If Emacs exits abruptly for some reason the recent file list will be lost - therefore you may wish to call `recentf-save-list` periodically, e.g. every 5 minutes:
(DGM disables it because I find it too invasive)

#+BEGIN_SRC emacs-lisp :tangle no
;; (run-at-time nil (* 5 60) 'recentf-save-list)
#+END_SRC

#+RESULTS:

*** recentf-ext    

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package recentf-ext
  :ensure t)
#+END_SRC

*** ztree 

Since ztree works with files and directories, let's consider it in group Files

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ztree)
;;(use-package ztree-diff)
;;(use-package ztree-dir)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23561 15887 36543 611000) :init (23561 15887 36504 265000) :config (23561 15887 36024 575000) :config-secs (0 0 20 788000) :init-secs (0 0 911 118000) :use-package-secs (0 0 1056 805000)))

*** rebox2

Ojo: solo funciona si se llama M-x rebox-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rebox2)
(global-set-key [(meta q)] 'rebox-dwin-fill)
(global-set-key [(shift meta q)] 'rebox-dwin-no-fill)
#+END_SRC

*** helpful 

https://github.com/Wilfred/helpful

Note that the built-in `describe-function' includes both functions and macros. `helpful-function' is functions only, so we provide `helpful-callable' as a drop-in replacement.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helpful)

(global-set-key (kbd "\C-h f") #'helpful-callable)
(global-set-key (kbd "\C-h v") #'helpful-variable)
(global-set-key (kbd "\C-h k") #'helpful-key)
#+END_SRC

*** Lookup 

**** Lookup the current symbol at point. 

C-c C-d is a common keybinding for this in lisp modes.

#+BEGIN_SRC emacs-lisp :tangle no
(global-set-key (kbd "\C-s d") #'helpful-at-point)
#+END_SRC

**** Look up *F*unctions (excludes macros). 

By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
already links to the manual, if a function is referenced there.

#+BEGIN_SRC emacs-lisp :tangle no
(global-set-key (kbd "\C-s-f") #'helpful-function)
#+END_SRC

**** Look up *C*ommands. 

By default, C-h C is bound to describe `describe-coding-system'. I
don't find this very useful, but it's frequently useful to only
look at interactive functions.

#+BEGIN_SRC emacs-lisp :tangle no
(global-set-key (kbd "\C-s-c") #'helpful-command)
#+END_SRC

*** Peek definition with Emacs frame
- Stuff from http://tuhdo.github.io/emacs-frame-peek.html
- So far I have not made it work in this =dgm.org= file but maybe it works with other programming languages.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun rtags-peek-definition ()
  "Peek at definition at point using rtags."
  (interactive)
  (let ((func (lambda ()
                (rtags-find-symbol-at-point)
                (rtags-location-stack-forward))))
    (rtags-start-process-unless-running)
    (make-peek-frame func)))

(defun make-peek-frame (find-definition-function &rest args)
  "Make a new frame for peeking definition"
  (when (or (not (rtags-called-interactively-p)) (rtags-sandbox-id-matches))
    (let (summary
          doc-frame
          x y
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ;; 1. Find the absolute position of the current beginning of the symbol at point, ;;
          ;; in pixels.                                                                     ;;
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          (abs-pixel-pos (save-excursion
                           (beginning-of-thing 'symbol)
                           (window-absolute-pixel-position))))
      (setq x (car abs-pixel-pos))
      ;; (setq y (cdr abs-pixel-pos))
      (setq y (+ (cdr abs-pixel-pos) (frame-char-height)))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 2. Create a new invisible frame, with the current buffer in it. ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (setq doc-frame (make-frame '((minibuffer . nil)
                                    (name . "*RTags Peek*")
                                    (width . 80)
                                    (visibility . nil)
                                    (height . 15))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 3. Position the new frame right under the beginning of the symbol at point. ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (set-frame-position doc-frame x y)

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 4. Jump to the symbol at point. ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (with-selected-frame doc-frame
        (apply find-definition-function args)
        (read-only-mode)
        (when semantic-stickyfunc-mode (semantic-stickyfunc-mode -1))
        (recenter-top-bottom 0))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; 5. Make frame visible again ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (make-frame-visible doc-frame))))

(global-set-key (kbd "M-s-p") 'rtags-peek-definition)
#+END_SRC

#+RESULTS:
: rtags-peek-definition

*** COMMENT eyebrowse configuration

Idea from http://pragmaticemacs.com/emacs/easily-manage-emacs-workspaces-with-eyebrowse/ but for some reason when I activate this bit of code, my configuration file does not work and everything fails.

I have commented this out because with =exwm= I think I don't need =eyebrowse= anymore.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package eyebrowse
  :ensure t
  :defer 1
  :init
  (setq eyebrowse-keymap-prefix (kbd "C-c z"))
  (global-unset-key (kbd "C-c C-w"))
  :diminish eyebrowse-mode
  :config (progn
            (define-key eyebrowse-mode-map (kbd "s-1") 'eyebrowse-switch-to-window-config-1)
            (define-key eyebrowse-mode-map (kbd "s-2") 'eyebrowse-switch-to-window-config-2)
            (define-key eyebrowse-mode-map (kbd "s-3") 'eyebrowse-switch-to-window-config-3)
            (define-key eyebrowse-mode-map (kbd "s-4") 'eyebrowse-switch-to-window-config-4)
            (define-key eyebrowse-mode-map (kbd "s-5") 'eyebrowse-switch-to-window-config-5)
            (define-key eyebrowse-mode-map (kbd "s-6") 'eyebrowse-switch-to-window-config-6)
            (define-key eyebrowse-mode-map (kbd "s-7") 'eyebrowse-switch-to-window-config-7)
            (define-key eyebrowse-mode-map (kbd "s-8") 'eyebrowse-switch-to-window-config-8)
            (define-key eyebrowse-mode-map (kbd "s-9") 'eyebrowse-switch-to-window-config-9)
            (define-key eyebrowse-mode-map (kbd "s-<") 'eyebrowse-prev-window-config)
            (define-key eyebrowse-mode-map (kbd "s->") 'eyebrowse-next-window-config)
            (eyebrowse-mode t)
            (setq eyebrowse-new-workspace t)))
#+END_SRC

#+RESULTS:
: t


So I'll try with this new code:

#+BEGIN_SRC emacs-lisp :tangle no
;;            (eyebrowse-mode t)
;;            (global-set-key (kbd "s-1") 'eyebrowse-switch-to-window-config-1)
;;            (global-set-key (kbd "s-2") 'eyebrowse-switch-to-window-config-2)
;;            (global-set-key (kbd "s-3") 'eyebrowse-switch-to-window-config-3)
;;            (global-set-key (kbd "s-4") 'eyebrowse-switch-to-window-config-4)
;;            (global-set-key (kbd "s-5") 'eyebrowse-switch-to-window-config-5)
;;            (global-set-key (kbd "s-6") 'eyebrowse-switch-to-window-config-6)
;;            (global-set-key (kbd "s-7") 'eyebrowse-switch-to-window-config-7)
;;            (global-set-key (kbd "s-8") 'eyebrowse-switch-to-window-config-8)
;;            (global-set-key (kbd "s-9") 'eyebrowse-switch-to-window-config-9)
;;            (setq eyebrowse-new-workspace t)
#+END_SRC

#+RESULTS:

But again, if I activate this bit of code, when I open emacs most of this file is not processed and I don't have my goodies running (helm, etc). However, if after I open emacs I run this code, then the code and all the rest works... why?

MISTERIO RESUELTO: cuando use' yasnippet para crear el snippet con elisp, me lo dio con begin_src y end_src en minusculas y esto es lo que causaba el caos (tambien pone lo del tangle yes o no pero creo que eso no es problema.)

*** COMMENT C  and C++ support.

- Tips from http://tuhdo.github.io/c-ide.html

Tuhdo tells how to install GNU Global and then the package =ggtags= from Melpa. 
I'm not sure if including this package in the =elpa.org= file will get this =ggtags= package or another with the same name but not from Melpa.

#+begin_src emacs-lisp :tangle no
;; sudo apt-get install global
#+end_src

** Ghub
Magit depends on this. Copied from https://github.com/jwiegley/dot-emacs/blob/master/init.el

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ghub
  :ensure t
  :config
  (require 'auth-source-pass)
  (defvar my-ghub-token-cache nil)

  (advice-add
   'ghub--token :around
   #'(lambda (orig-func host username package &optional nocreate forge)
       (or my-ghub-token-cache
           (setq my-ghub-token-cache
                 (funcall orig-func host username package nocreate forge))))))

(use-package ghub+         
  :defer t)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23934 47113 548749 897000) :init (23934 47113 548708 930000) :init-secs (0 0 173 741000) :use-package-secs (0 0 452 911000)))

** Magit

https://magit.vc/manual/magit.html#Installation

Key binding to get the Magit menu

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package magit
  :ensure t
  :after (ghub)
  :defer t
  :bind (("C-x g" . magit-status) 
         ("C-x M-l" . magit-log-buffer-file)
         ("C-x M-b" . magit-blame)))

(global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
#+END_SRC

#+RESULTS:
: magit-dispatch-popup

The following code makes magit-status run alone in the frame, and then restores the old window configuration when you quit out of magit.

No more juggling windows after commiting. It’s magit bliss.

Source: Magnar Sveen

#+BEGIN_SRC emacs-lisp :tangle yes
;; full screen magit-status
(defadvice magit-status (around magit-fullscreen activate)
  (window-configuration-to-register :magit-fullscreen)
  ad-do-it
  (delete-other-windows))

(defun magit-quit-session ()
  "Restores the previous window configuration and kills the magit buffer"
  (interactive)
  (kill-buffer)
  (jump-to-register :magit-fullscreen))
#+END_SRC

#+RESULTS:
: magit-quit-session

**** Edit With Emacs
Editing input boxes from Chrome with Emacs. Pretty useful to keep all significant text-writing on the web within emacs. I typically use this with posts on Discourse, which has a post editor that overrides normal Emacs key bindings with other functions. As such, markdown-mode is used (dgm comments this out to have the default text mode operative.)

Para usarlo creo que es necesario instalar la extension "edit with emacs" en la chrome web store. This extension has the following information:

Allow user to edit web-page textareas with Emacs (and other editors).  Edit with Emacs is an extension for Google's Chrome(ium) browser family
that allows you to edit text areas on your browser in a more full featured editor. It does this in conjunction with an "Edit Server" which services requests by the browser. This is because extensions cannot spawn new processes as a security measure.  For this reason and for the Chromium extension to work, you need to be running an "edit server" on your local machine. For emacs users it is recommended that you use the supplied native =edit-server.el=. 

The extension packages native elisp version that can be run inside GNU Emacs itself, just follow the instructions from the options page of the extension. It has been known to work with GNU Emacs and Aquamacs (MacOS); it is presently not compatible with XEmacs.

Other example edit servers can be found at the project homepage. There is no reason why other server scripts could not spawn other editors and currently a number of servers support the simple URL based protocol.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package edit-server
  :ensure t
  :config
  (when (locate-library "edit-server")
    (require 'edit-server)
    (setq edit-server-new-frame nil)
    (edit-server-start)))
;;  (setq edit-server-default-major-mode 'markdown-mode)
;;(setq edit-server-new-frame nil))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23563 43807 378915 313000) :init (23563 43807 378870 661000) :config (23563 43807 378554 538000) :config-secs (0 0 3329 984000) :init-secs (0 0 4027 761000) :use-package-secs (0 0 4264 968000)))

Not working for me. So I try =atomic-chrome= (see https://github.com/alpha22jp/atomic-chrome and https://www.reddit.com/r/emacs/comments/8jb4p5/editing_html_textareas_with_emacs_bye_bye_its_all/)

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package atomic-chrome
  :ensure t
  :custom
  (atomic-chrome-url-major-mode-alist
   '(("reddit\\.com" . markdown-mode)
     ;;("github\\.com" . gfm-mode)
     ("uned\\.es" . text-mode))
   "Major modes for URLs.")
  :config
  (atomic-chrome-start-server))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23564 17693 843954 826000) :init (23564 17693 843942 387000) :config (23564 17693 843735 478000) :config-secs (0 0 1721 187000) :init-secs (0 0 2112 456000) :use-package-secs (0 0 2188 501000)))

And this one works!!

Other options here: 
https://emacsnotes.wordpress.com/2018/05/14/editing-html-textareas-with-emacs-bye-bye-its-all-text-hello-textern/
(emacs_chrome, GhostText, It's All Text!, Textern, withExEditor.)

*** Make sure time stamps are in English

Tip from: https://stackoverflow.com/questions/28913294/emacs-org-mode-language-of-time-stamps

#+BEGIN_SRC emacs-lisp :tangle yes
;; System locale to use for formatting time values.
(setq system-time-locale "C")         ; Make sure that the weekdays in the
                                        ; time stamps of your Org mode files and
                                        ; in the agenda appear in English.
#+END_SRC

#+RESULTS:
: C

** Key bindings

#+BEGIN_SRC emacs-lisp :tangle yes
;;    (define-key global-map [?\s-u] 'undo)
;;    (define-key global-map [?\s-j] 'save-buffer)
;;    (define-key global-map [?\s-q] 'move-beginning-of-line)
;;    (define-key global-map [?\s-e] 'move-end-of-line)
;;    (define-key global-map [?\s-k] 'kill-buffer)
#+END_SRC

#+RESULTS:
: kill-buffer
** Harry R. Schwartz  stuff
- Taken from https://github.com/hrs/dotfiles/blob/master/emacs/.emacs.d/configuration.org
*** Rename file

#+begin_src emacs-lisp :tangle yes
(defun hrs/rename-file (new-name)
  (interactive "FNew name: ")
  (let ((filename (buffer-file-name)))
    (if filename
        (progn
          (when (buffer-modified-p)
            (save-buffer))
          (rename-file filename new-name t)
          (kill-buffer (current-buffer))
          (find-file new-name)
          (message "Renamed '%s' -> '%s'" filename new-name))
      (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))
#+end_src

#+RESULTS:
: hrs/rename-file

*** Generate scratch buffer
Rendered obsolete by =scratch= package? Not really because the scratch package forces the scratch buffer to be of the same mode as the current one.

#+begin_src emacs-lisp :tangle yes
(defun hrs/generate-scratch-buffer ()
  "Create and switch to a temporary scratch buffer with a random
     name."
  (interactive)
  (switch-to-buffer (make-temp-name "scratch-")))
#+end_src

#+RESULTS:
: hrs/generate-scratch-buffer

*** Visit last dired buffer

#+begin_src emacs-lisp :tangle yes
(defun hrs/visit-last-dired-file ()
  "Open the last file in an open dired buffer."
  (interactive)
  (end-of-buffer)
  (previous-line)
  (dired-find-file))
#+end_src

#+RESULTS:
: hrs/visit-last-dired-file

*** COMMENT Change window configuration

Tip from https://stackoverflow.com/questions/14881020/emacs-shortcut-to-switch-from-a-horizontal-split-to-a-vertical-split-in-one-move

Commented out because I am using =exwm= now.

#+BEGIN_SRC emacs-lisp :tangle no
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(global-set-key (kbd "s-c") 'toggle-window-split)
#+END_SRC

#+RESULTS:
: toggle-window-split

*** Org customization
How do I change my dotfile so that when I call org-agenda it takes up the entire screen?
https://stackoverflow.com/questions/36873727/make-org-agenda-full-screen

#+BEGIN_SRC emacs-lisp :tangle yes
;; (setq org-agenda-window-setup 'only-window)
;; (setq org-export-dispatch 'only-window)
#+END_SRC

#+RESULTS:
: only-window

*** How to control in which window a buffer is displayed?

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-window-displaying-agenda-p (window)
  (equal (with-current-buffer (window-buffer window) major-mode)
         'org-agenda-mode)) 

(defun my-position-calendar-buffer (buffer alist)
  (let ((agenda-window (car (remove-if-not #'my-window-displaying-agenda-p (window-list)))))
    (when agenda-window
      (let ((desired-window (split-window agenda-window nil 'below)))
        (set-window-buffer desired-window  buffer)
        desired-window))))

(add-to-list 'display-buffer-alist (cons "\\*Calendar\\*" (cons #'my-position-calendar-buffer nil)))
#+END_SRC

#+RESULTS:
| \*Calendar\* | my-position-calendar-buffer |

From my question in https://emacs.stackexchange.com/questions/45650/in-org-mode-what-variable-controls-the-placement-of-the-calendar-view-when-call/45653#45653

The following will make the Calendar to use a window below the selected window

#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'display-buffer-alist
             `(,(rx string-start "*Calendar*" string-end)
               (display-buffer-below-selected)))
#+END_SRC

** Ambrevar's stuff

From his =main.el=

#+BEGIN_SRC emacs-lisp :tangle yes
;;; Save M-: history.
(savehist-mode)

;;; Enforce horizontal splitting. 140 means that the window is large enough to
;;; hold 2 other windows of 70 columns.
(setq split-height-threshold nil
      split-width-threshold 140)

;;; Show matching parenthesis
(show-paren-mode 1)
;;; By default, there’s a small delay before showing a matching parenthesis. Set
;;; it to 0 to deactivate.
(setq show-paren-delay 0)
(setq show-paren-when-point-inside-paren t)

;;; Replace `kill-buffer' binding by `kill-this-buffer'.
(global-set-key (kbd "C-x k") 'kill-this-buffer)

;;; Initial scratch buffer message.
;; commented out as it was too distracting
;;(require 'functions) ; For `ambrevar/fortune-scratch-message'.
;;(let ((fortune (ambrevar/fortune-scratch-message)))
;;  (when fortune
;;    (setq initial-scratch-message fortune)))

;;; Save all visited URLs.
(setq url-history-track t
      url-history-file (expand-file-name "url/history" user-emacs-directory))
#+END_SRC

#+RESULTS:
: /home/dgm/.emacs.d/url/history

** =dired= do what I mean
- Tip from
https://emacs.stackexchange.com/questions/5603/how-to-quickly-copy-move-file-in-emacs-dired

#+BEGIN_SRC emacs-lisp :tangle yes
(setq dired-dwim-target t)
#+END_SRC

#+RESULTS:
: t

** gpastel

After updating packages, this returns error.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package gpastel
  :ensure t
  :config 
  (gpastel-start-listening))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23880 21520 898702 207000) :init (23880 21520 898685 670000) :config (23880 21520 898328 707000) :config-secs (0 0 743 952000) :init-secs (0 0 1485 396000) :use-package-secs (0 0 1735 521000)))

** Customize =emacsclient=

#+BEGIN_SRC emacs-lisp :tangle yes
(setq default-frame-alist '((font . "Pragmata Pro Mono-16")))
(add-to-list 'default-frame-alist '(line-spacing . 0.06))
#+END_SRC

#+RESULTS:
: ((line-spacing . 0.06) (font . Pragmata Pro Mono-16))
 
** COMMENT =qutebrowser=
Originally from https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org with qutebrowser, but too unstable. Changed to chromium

DGM on 29 dic 2018: this is set in =starter-kit-misc.org=
#+BEGIN_SRC emacs-lisp :tangle no
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "chromium")
                                        ;      browse-url-generic-program "qutebrowser")
#+END_SRC

#+RESULTS:
: qutebrowser

** Tell emacs where =fortune= is
From 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package fortune)
(setq fortune-dir "/usr/share/games/fortunes"
      fortune-file "/usr/share/games/fortunes/fortunes")
#+END_SRC

** Better defaults

By the great Technomancy. 

Situation with =uniquify= solved here: https://github.com/jwiegley/use-package/issues/320

Uniquify buffer names is useful for when you have buffers with many similar names, as when there are various open files from different folders named =analysis.R= or similar. 

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'uniquify)
(setq ;;(setq uniquify-buffer-name-style 'reverse)
 ;; (setq uniquify-buffer-name-style 'forward) ;; technomancy's default
 ;;(setq uniquify-separator "|")
 uniquify-after-kill-buffer-p t
 uniquify-buffer-name-style 'post-forward-angle-brackets)  ;; default in kieran healy's config
;;(setq uniquify-ignore-buffers-re "^*")
#+END_SRC  

#+RESULTS:
: post-forward-angle-brackets

bbatov setup is like this (https://github.com/bbatsov/emacs.d/blob/master/init.el)

#+BEGIN_SRC emacs-lisp :tangle no
;; (use-package uniquify
;;  :config
;;  (setq uniquify-buffer-name-style 'forward)
;;  (setq uniquify-separator "/")
;;  ;; rename after killing uniquified
;;  (setq uniquify-after-kill-buffer-p t)
;;  ;; don't muck with special buffers
;; (setq uniquify-ignore-buffers-re "^\\*"))
#+END_SRC


Other stuff from Technomancy's better defaults

#+BEGIN_SRC emacs-lisp :tangle yes
(autoload 'zap-up-to-char "misc"
  "Kill up to, but not including ARGth occurrence of CHAR." t)
(global-set-key (kbd "M-z") 'zap-up-to-char)

(setq apropos-do-all t
      mouse-yank-at-point t)
#+END_SRC

#+RESULTS:
: t

** Caolan's stuff
From https://caolan.org/dotfiles/emacs.html#orgd96aeb0

*** Ediff
Some tips taken from the post Setting up Ediff.

Don't use the weird setup with a control panel in a separate frame, use a normal Emacs window instead.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

Split the windows horizontally instead of vertically as I find it easier to follow.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq ediff-split-window-function 'split-window-horizontally)
#+END_SRC

Restore the windows after Ediff quits. By default, when you quit the Ediff session with =q=, it just leaves the two diff windows around, instead of restoring the window configuration from when Ediff was started.

#+BEGIN_SRC emacs-lisp :tangle yes
;; winner-mode is activated in starter-kit-bindings.org
;; (winner-mode)
(add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC

#+RESULTS:
| winner-undo |

(Above code in =starter-kit-binding.org=)

Don't wait 3 seconds then ask about closing the merge buffer, just close it!

#+BEGIN_SRC emacs-lisp :tangle yes
;; write merge buffer.  If the optional argument save-and-continue is non-nil,
;; then don't kill the merge buffer
(defun caolan/ediff-write-merge-buffer-and-maybe-kill (buf file
                                                           &optional
                                                           show-file save-and-continue)
  (if (not (eq (find-buffer-visiting file) buf))
      (let ((warn-message
             (format "Another buffer is visiting file %s. Too dangerous to save the merge buffer"
                     file)))
        (beep)
        (message "%s" warn-message)
        (with-output-to-temp-buffer ediff-msg-buffer
          (princ "\n\n")
          (princ warn-message)
          (princ "\n\n")
          )
        (sit-for 2))
    (ediff-with-current-buffer buf
                               (if (or (not (file-exists-p file))
                                       (y-or-n-p (format "File %s exists, overwrite? " file)))
                                   (progn
                                     ;;(write-region nil nil file)
                                     (ediff-with-current-buffer buf
                                                                (set-visited-file-name file)
                                                                (save-buffer))
                                     (if show-file
                                         (progn
                                           (message "Merge buffer saved in: %s" file)
                                           (set-buffer-modified-p nil)))
                                     (if (and (not save-and-continue))
                                         (ediff-kill-buffer-carefully buf)))))
    ))

(defun caolan/ediff-maybe-save-and-delete-merge (&optional save-and-continue)
  "Default hook to run on quitting a merge job.
This can also be used to save merge buffer in the middle of an Ediff session.

If the optional SAVE-AND-CONTINUE argument is non-nil, save merge buffer and
continue.  Otherwise:
If `ediff-autostore-merges' is nil, this does nothing.
If it is t, it saves the merge buffer in the file `ediff-merge-store-file'
or asks the user, if the latter is nil.  It then asks the user whether to
delete the merge buffer.
If `ediff-autostore-merges' is neither nil nor t, the merge buffer is saved
only if this merge job is part of a group, i.e., was invoked from within
`ediff-merge-directories', `ediff-merge-directory-revisions', and such."
  (let ((merge-store-file ediff-merge-store-file)
        (ediff-autostore-merges ; fake ediff-autostore-merges, if necessary
         (if save-and-continue t ediff-autostore-merges)))
    (if ediff-autostore-merges
        (cond ((stringp merge-store-file)
               ;; store, ask to delete
               (caolan/ediff-write-merge-buffer-and-maybe-kill
                ediff-buffer-C merge-store-file 'show-file save-and-continue))
              ((eq ediff-autostore-merges t)
               ;; ask for file name
               (setq merge-store-file
                     (read-file-name "Save the result of the merge in file: "))
               (caolan/ediff-write-merge-buffer-and-maybe-kill
                ediff-buffer-C merge-store-file nil save-and-continue))
              ((and (ediff-buffer-live-p ediff-meta-buffer)
                    (ediff-with-current-buffer ediff-meta-buffer
                                               (ediff-merge-metajob)))
               ;; The parent metajob passed nil as the autostore file.
               nil)))
    ))

(add-hook 'ediff-quit-merge-hook #'caolan/ediff-maybe-save-and-delete-merge)
#+END_SRC

Fully expand Org files in Ediff (otherwise it's hard to see the changes between files). This tip taken from the Emacs Stackexchange, which also has an interesting solution to unfold/fold Org elements as Ediff selects/deselects changes, but I found just showing everything to work more reliably.

Note, show-all is marked obsolete in Emacs 25.1 in favor of outline-show-all. But the latter symbol is not bound in 24.5, and since I use Debian stable (Jessie) on my desktop which provides Emacs 24.4, I need to use the older show-all for now.

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'ediff-prepare-buffer-hook #'outline-show-all)
#+END_SRC

#+RESULTS:
| outline-show-all |

*** Cut/copy/comment current line if no region selected
In many programs, like SlickEdit, TextMate and VisualStudio, "cut" and "copy" act on the current line if no text is visually selected. For this, I originally used code from Tim Krones Emacs config, but now I'm using the whole-line-or-region package, which can be customised to use the same line-or-region style for comments too. See comments in whole-line-or-region.el for details.

However, I disable it or else the copy/paste emacs bindings won't work in external apps PLUS uncle dave has defined handy functions to do the copying and killing on current words and lines.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package whole-line-or-region
  :ensure t)

(add-to-list 'whole-line-or-region-extensions-alist
             '(comment-dwim whole-line-or-region-comment-dwim nil))

(whole-line-or-region-global-mode 1)
#+END_SRC

#+RESULTS:
: t
*** Place cursor at beginning of search matches
From: http://www.emacswiki.org/emacs/IncrementalSearch#toc4. With this hook, both ‘C-g’ and ‘RET’ exit the search at the begining of the search string rather than the end. To get back to where you started the search, just use ‘C-x C-x’. This works because isearch sets the mark at the search start.

I (dgm) don't find a use case for it, so I disable it. 

#+BEGIN_SRC emacs-lisp :tangle yes
(add-hook 'isearch-mode-end-hook 'my-goto-match-beginning)

(defun my-goto-match-beginning ()
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end)))

(defadvice isearch-exit (after my-goto-match-beginning activate)
  "Go to beginning of match."
  (when (and isearch-forward isearch-other-end)
    (goto-char isearch-other-end)))
#+END_SRC

#+RESULTS:
: isearch-exit

*** Environment variables
Set environment variable so running CHICKEN Scheme suites via the 'test' egg will display colour output.
#+BEGIN_SRC emacs-lisp :tangle yes
(setenv "TEST_USE_ANSI" "1")
#+END_SRC

#+RESULTS:
: 1

Add my home bin directory to PATH (when I have it) (check next section that is currently commented out because I'm using Purcell's package for setting the environment variables.)

#+BEGIN_SRC emacs-lisp :tangle no
(setenv "PATH" (concat "/home/dgm/bin:" (getenv "PATH")))
#+END_SRC

*** COMMENT Trying to get =M-x stata= working

Originally this got stata working when I called it interactively with =M-x stata=
#+BEGIN_SRC emacs-lisp :tangle no
;; (setenv "PATH" (concat "/usr/local/stata14:/usr/local/stata:" (getenv "PATH")))
;; (setenv "PATH" (concat (getenv "PATH") ":/usr/local/stata"))
;; (setq exec-path (append exec-path '("/usr/local/stata")))
#+END_SRC

#+RESULTS:

However, once I used the script sent from Stata Corp. to make stata work after updating it, this does not work. So I have changed it to:

#+BEGIN_SRC emacs-lisp :tangle no
;; (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin/stata"))
;; (setq exec-path (append exec-path '("/usr/local/bin/stata")))
#+END_SRC

#+RESULTS:

However, I've tangled it up to "no" because I think this is not needed now that I use Purcell's package =exec-path-from-shell=.

*** Flyspell and flycheck
When I start the shell I get a backtrace error related to not finding flyspell, so I get it here. The message is:

#+BEGIN_EXAMPLE
Debugger entered--Lisp error: (void-function flycheck-mode)
  flycheck-mode()
  run-hooks(change-major-mode-after-body-hook comint-mode-hook shell-mode-hook)
  apply(run-hooks (change-major-mode-after-body-hook comint-mode-hook shell-mode-hook))
  run-mode-hooks(shell-mode-hook)
  shell-mode()
  shell()
  (lambda nil (shell))()
  shell-pop--switch-to-shell-buffer(1)
  shell-pop-up(1)
  shell-pop(nil)
  funcall-interactively(shell-pop nil)
  call-interactively(shell-pop nil nil)
  command-execute(shell-pop)
#+END_EXAMPLE


Note =flyspell= is part of emacs so you don't need =use-package=.

UUUGGHHGGHGH: tangled to no. The message refers to flycheck-mode, not flyspell!!!

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'flyspell)
(setq flyspell-mode-on t)
#+END_SRC

#+RESULTS:
: t


Now, I follow https://github.com/flycheck/flycheck/blob/master/doc/user/installation.rst

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck)
;;  :ensure t)
;;  :init (global-flycheck-mode))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23562 65398 372429 797000) :init (23562 65398 372385 594000) :config (23562 65398 371859 359000) :config-secs (0 0 22 237000) :init-secs (0 0 962 713000) :use-package-secs (0 0 1171 921000)))

*** Shell pop-up terminal

Its window behavour is crazy, plus I can define an easy shortcut for popping a shell, so I don't see the point.

From http://pragmaticemacs.com/emacs/pop-up-a-quick-shell-with-shell-pop/. Opens a quick ANSI terminal in the directory of the currently open file.

Code originally by Caolan that made shell-pop a read-only buffer in https://caolan.org/dotfiles/emacs.html. But it had an erratic window behaviour. In the end, I kind of fixed it by using the code in https://www.emacswiki.org/emacs/ShellPop.
The only issue remaining is that the first time round I call shell-pop it splits the window wrongly. Afterwards, it does it alright.

NOTE: font-lock of the shell-prompt did not work until I bumped onto   https://emacs.stackexchange.com/questions/14876/how-can-i-make-ansi-color-codes-inside-the-prompt-show-up-in-shell-mode
and I added the bit of code here and 


~PS1="\[\e[00;32m\]\u\[\e[00m\]@\[\e[00;36m\]\h\[\e[00m\]:\[\e[00;34m\]\w\[\e[00m\]\n\$(printf \"[\[\e[01;31m\]%.*s\[\e[00m\]]\" \$? \$?) \$ "~


in =.bashrc=.

However, to actually get the colors, I followed  http://amitp.blogspot.com/2007/04/emacs-color-in-shell-buffers.html and his choice of colors

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package shell-pop
  :ensure t
  :bind ("<s-escape>" . shell-pop))

;;  (setq shell-pop-default-directory "/home/dgm")
(setq shell-pop-set-internal-mode "shell")
(setq shell-pop-set-internal-mode-shell "/bin/bash")
(setq shell-pop-set-window-height 30) ;the number for the percentage of the selected window. if 100, shell-pop use the whole of selected window, not spliting.
(setq shell-pop-set-window-position "bottom") ;shell-pop-up position. You can choose "top" or "bottom".

;; https://emacs.stackexchange.com/questions/14876/how-can-i-make-ansi-color-codes-inside-the-prompt-show-up-in-shell-mode
(set-face-attribute 'comint-highlight-prompt nil
                    :inherit nil)

  ;;;;;;;;;;;;;;;;;;;;;; http://amitp.blogspot.com/2007/04/emacs-color-in-shell-buffers.html
(setq ansi-color-names-vector ; better contrast colors
      ["black" "red4" "green4" "yellow4"
       "blue3" "magenta4" "cyan4" "white"])
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

;; (setq shell-pop-window-size 30)
;;(setq shell-pop-full-span t)
;;(setq shell-pop-window-position "bottom")
;;:config
;;(setq shell-pop-shell-type (quote ("shell" "*shell*" (lambda nil (shell shell-pop-term-shell)))))
;;(setq shell-pop-term-shell "/bin/bash")
;; need to do this manually or not picked up by `shell-pop'
;;(shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
#+END_SRC

#+RESULTS:
| ansi-color-for-comint-mode-on | company-mode | flycheck-mode | yas-minor-mode | shell-mode-company-init | ess-r-package-activate-directory-tracker |


*** COMMENT Start a regular shell at the bottom.
#+begin_src emacs-lisp  :tangle no
;;(global-set-key (kbd "s--") 'shell)
#+end_src

#+RESULTS:
: shell

And open it at the bottom of current window


#+BEGIN_SRC emacs-lisp :tangle no
;; (add-to-list 'display-buffer-alist
;;              `(,(rx string-start "*shell*" string-end)
;;               (display-buffer-below-selected)))
#+END_SRC

#+RESULTS:
*** Using dumb-jump to jump to definitions
The dumb-jump package provides 'jump to definition' support for multiple languages by simply searching for possible definitions using The Silver Searcher ag, ripgrep rg, or grep. It does not require building stored indexes (TAGS) or background processes etc.

Enable dumb-jump-mode globally:

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dumb-jump
  :ensure t
  :init (lambda ()
          (dumb-jump-mode)))
#+END_SRC

#+RESULTS:

If The Silver Searcher is installed it will use it, otherwise it will revert back to =grep=.

*** EditorConfig plugin
Reads EditorConfig files to set coding style options according to current project.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package editorconfig
  :ensure t
  :config
  (editorconfig-mode 1))
#+END_SRC

#+RESULTS:
: t

*** Thesaurus
Many of the thesaurus packages use an online service, synosaurus gives you the option of using a local Wordnet install. It also has a nice 'replace word' interface.

NOTE: this requires you to install wordnet

#+BEGIN_EXAMPLE
 sudo apt install wordnet
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package synosaurus
  :ensure t
  :config (progn
            (setq synosaurus-backend 'synosaurus-backend-wordnet)
            (setq synosaurus-choose-method 'default)))
#+END_SRC 

#+RESULTS:
: t

*** Dictionary
Since I already use a local Wordnet as a thesaurus, I'm using it for a dictionary as well via the wordnut package.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package wordnut
  :ensure t
  :bind
  ("s-$" . wordnut-search))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23920 55701 21899 53000) :init (23920 55701 21702 363000) :config (23920 55701 21638 620000) :config-secs (0 0 15 446000) :init-secs (0 0 104 86000) :use-package-secs (0 0 460 241000)))

*** Olivetti minor mode
A minor mode for a nice writing environment.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package olivetti
  :ensure t
  :config (setq olivetti-body-width 90))
#+END_SRC

#+RESULTS:
: t

** Uncle Dave
https://github.com/daedreth/UncleDavesEmacs
*** async
Already in =init.el=

#+BEGIN_SRC emacs-lisp :tangle no
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; async ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; activate for all packages. Advised in Helm's wiki
;; also, uncle dave says: Lets us use asynchronous processes wherever
;; possible, pretty useful.

;;(use-package async
;;  :ensure t
;;  :init (dired-async-mode 1))

;;(setq async-bytecomp-allowed-packages '(all))
#+END_SRC

#+RESULTS:
| all |

*** Screenshots
I don’t need scrot to take screenshots, or shutter or whatever tools you might have. This is enough. These won’t work in the terminal version or the virtual console, obvious reasons.

***** Screenshotting the entire screen

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/take-screenshot ()
  "Takes a fullscreen screenshot of the current workspace"
  (interactive)
  (when window-system
    (loop for i downfrom 3 to 1 do
          (progn
            (message (concat (number-to-string i) "..."))
            (sit-for 1)))
    (message "Cheese!")
    (sit-for 1)
    (start-process "screenshot" nil "import" "-window" "root" 
                   (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
    (message "Screenshot taken!")))
(global-set-key (kbd "s-[") 'daedreth/take-screenshot)
#+END_SRC

***** Screenshotting a region

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/take-screenshot-region ()
  "Takes a screenshot of a region selected by the user."
  (interactive)
  (when window-system
    (call-process "import" nil nil nil ".newScreen.png")
    (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
                  (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
    (call-process "rm" nil nil nil ".newScreen.png")))
(global-set-key (kbd "s-]") 'daedreth/take-screenshot-region)
#+END_SRC

#+RESULTS:
: daedreth/take-screenshot-region

*** System monitor
A teeny-tiny system monitor that can be enabled or disabled at runtime, useful for checking performance with power-hungry processes in ansi-term

symon can be toggled on and off with =super+h=.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package symon
  :ensure t
  :bind
  ("s-h" . symon-mode))
#+END_SRC

#+RESULTS:
: symon-mode

*** COMMENT Default shell should be bash
I don’t know why this is a thing, but asking me what shell to launch every single time I open a terminal makes me want to slap babies, this gets rid of it. This goes without saying but you can replace bash with your shell of choice.

DGM: not needed now that I use =pop-shell= plus I don't know why it's now working 
#+BEGIN_SRC emacs-lisp :tangle no
(defvar my-term-shell "/bin/bash")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-shell)
#+END_SRC

#+RESULTS:
: ansi-term

*** Easy to remember keybinding
In loving memory of bspwm, =super+Enter= opens a new terminal, old habits die hard.

#+BEGIN_SRC emacs-lisp :tangle no
;; (global-set-key (kbd "<s-return>") 'ansi-term)
#+END_SRC

#+RESULTS:
: ansi-term

I think this will is too powerful a shortcut for this. I'd rather use it for =swipe=.

*** Ivy 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ivy
  :ensure t)

(setq ivy-display-style 'fancy)
#+END_SRC

#+RESULTS:
: fancy

*** scrolling and why does the screen move
I don’t know to be honest, but this little bit of code makes scrolling with emacs a lot nicer.

#+BEGIN_SRC emacs-lisp :tangle no
;; (setq scroll-conservatively 100)
#+END_SRC

I've disabled it because it is set to 0 in =starter-kit-text.org=.

*** windows, panes and why I hate other-window
Some of us have large displays, others have tiny netbook screens, but regardless of your hardware you probably use more than 2 panes/windows at times, cycling through all of them with C-c o is annoying to say the least, it’s a lot of keystrokes and takes time, time you could spend doing something more productive.

***** =ace-window=
ace-window is a package that uses the same idea from ace-jump-mode for buffer navigation, but applies it to windows. 

Tips from https://pastebin.com/MnSsUWeZ

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-window
  :ensure t
  :config
  (ace-window-display-mode)
  (setq aw-dispatch-always t)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (defvar aw-dispatch-alist
    '((?x aw-delete-window "Delete Window")
      (?m aw-swap-window "Swap Windows")
      (?M aw-move-window "Move Window")
      (?j aw-switch-buffer-in-window "Select Buffer")
      (?n aw-flip-window)
      (?u aw-switch-buffer-other-window "Switch Buffer Other Window")
      (?c aw-split-window-fair "Split Fair Window")
      (?v aw-split-window-vert "Split Vert Window")
      (?b aw-split-window-horz "Split Horz Window")
      (?o delete-other-windows "Delete Other Windows")
      (?? aw-show-dispatch-help)))
  :bind ("M-P" . ace-window))

;; (global-set-key (kbd "M-P") 'ace-window)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23569 36355 585435 681000) :init (23569 36355 585136 639000) :config (23569 36355 585104 709000) :config-secs (0 0 1097 931000) :init-secs (0 0 1157 882000) :use-package-secs (0 0 1713 661000)))

Problema: if I am in an external app within =exwm=, then =ace-window= does not work and I'd rather use =switch-window=.

***** COMMENT switch-window
This magnificent package takes care of this issue. It’s unnoticeable if you have <3 panes open, but with 3 or more, upon pressing C-x o you will notice how your buffers turn a solid color and each buffer is asigned a letter (the list below shows the letters, you can modify them to suit your liking), upon pressing a letter asigned to a window, your will be taken to said window, easy to remember, quick to use and most importantly, it annihilates a big issue I had with emacs. An alternative is ace-window, however by default it also changes the behaviour of C-x o even if only 2 windows are open, this is bad, it also works less well with exwm for some reason.

DGM: I suspect that this package is responsible for my disappearing-cursor problem because it has always happened when moving across windows... the only other suspect I have is Dired as I think it has involved moving files across windows and directories.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package switch-window
  :ensure t
  :config
  (setq switch-window-input-style 'minibuffer)
  (setq switch-window-increase 4)
  (setq switch-window-threshold 2)
  (setq switch-window-shortcut-style 'qwerty)
  (setq switch-window-qwerty-shortcuts
        '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
  :bind
  ([remap other-window] . switch-window))
#+END_SRC

#+RESULTS:
: switch-window

***** COMMENT Following window splits
After you split a window, your focus remains in the previous one. This annoyed me so much I wrote these two, they take care of it.
Note: I've commented this out because below I implement the same functionality. See [[split]]

#+BEGIN_SRC emacs-lisp :tangle no
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

#+RESULTS:
: split-and-follow-vertically

*** =swipe=
I like me some searching, the default search is very meh. In emacs, you mostly use search to get around your buffer, much like with avy, but sometimes it doesn’t hurt to search for entire words or mode, swiper makes sure this is more efficient.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package swiper
  :ensure t
  :bind ("s-i" . 'swiper))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23919 51355 179006 615000) :init (23919 51355 178791 891000) :config (23919 51355 178416 764000) :config-secs (0 0 17 871000) :init-secs (0 0 713 525000) :use-package-secs (0 0 1105 560000)))

*****  Further customization from Pragmatic Emacs

From: http://pragmaticemacs.com/emacs/dont-search-swipe/

#+BEGIN_SRC emacs-lisp :tangle no
;;(global-set-key (kbd "s-i") 'swiper) ;; I'm gonna use this for helm-projectile
(setq ivy-display-style 'fancy)
#+END_SRC

#+RESULTS:
: fancy

The second line in the above code sets the colours of the swiper results display to be a bit more, well, fancy! Apparently this option only works well for emacs versions 24.5 and higher, so get updated. (Already set when I call Ivy).

The other tweak I have made is to get swiper to recenter the display when it exits – I found it a little unpredictable where the point was going to be after I finished swiper. This is done with a little bit of advice:

#+BEGIN_SRC emacs-lisp :tangle yes
;;advise swiper to recenter on exit
(defun bjm-swiper-recenter (&rest args)
  "recenter display after swiper"
  (recenter))
(advice-add 'swiper :after #'bjm-swiper-recenter)
#+END_SRC

#+RESULTS:

*** close-all-buffers
It’s one of those things where I genuinely have to wonder why there is no built in functionality for it. Once in a blue moon I need to kill all buffers, and having ~150 of them open would mean I’d need to spend a few too many seconds doing this than I’d like, here’s a solution.

This can be invoked using C-M-s-k. This keybinding makes sure you don’t hit it unless you really want to.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun close-all-buffers ()
  "Kill all buffers without regard for their origin."
  (interactive)
  (mapc 'kill-buffer (buffer-list)))
(global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC

#+RESULTS:
: close-all-buffers

*** line numbers and programming
Every now and then all of us feel the urge to be productive and write some code. In the event that this happens, the following bit of configuration makes sure that we have access to relative line numbering in programming-related modes. I highly recommend not enabling linum-relative-mode globally, as it messed up something like ansi-term for instance.

Note: I disable this as I find it not very useful and dizzling by way of the moving numbers

#+BEGIN_SRC emacs-lisp :tangle no
(use-package linum-relative
  :ensure t
  :config
  (setq linum-relative-current-symbol "")
  (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC

#+RESULTS:
: t

*** Text manipulation
Here I shall collect self-made functions that make editing text easier.
**** Mark-Multiple
I can barely contain my joy. This extension allows you to quickly mark the next occurence of a region and edit them all at once. Wow!

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mark-multiple
  :ensure t
  :bind ("s-q" . 'mark-next-like-this))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23921 2949 483376 581000) :init (23921 2949 483264 95000) :config (23921 2949 482982 909000) :config-secs (0 0 11 625000) :init-secs (0 0 590 800000) :use-package-secs (0 0 843 838000)))

**** Improved kill-word
Why on earth does a function called kill-word not ... kill a word. It instead deletes characters from your cursors position to the end of the word, let’s make a quick fix and bind it properly.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/kill-inner-word ()
  "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))
(global-set-key (kbd "s-k") 'daedreth/kill-inner-word)
#+END_SRC

#+RESULTS:
: daedreth/kill-inner-word

**** Improved copy-word
And again, the same as above but we make sure to not delete the source word.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/copy-whole-word ()
  (interactive)
  (save-excursion
    (forward-char 1)
    (backward-word)
    (kill-word 1)
    (yank)))
(global-set-key (kbd "s-w") 'daedreth/copy-whole-word) 
#+END_SRC

#+RESULTS:
: daedreth/copy-whole-word
**** Copy a line
Regardless of where your cursor is, this quickly copies a line.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun daedreth/copy-whole-line ()
  "Copies a line without regard for cursor position."
  (interactive)
  (save-excursion
    (kill-new
     (buffer-substring
      (point-at-bol)
      (point-at-eol)))))
(global-set-key (kbd "s-@") 'daedreth/copy-whole-line)
#+END_SRC

#+RESULTS:
: daedreth/copy-whole-line

**** Kill a line
And this quickly deletes a line.

#+BEGIN_SRC emacs-lisp :tangle yes
;;(global-set-key (kbd "M-s-k") 'kill-whole-line)
(global-set-key (kbd "s-%") 'kill-whole-line)
#+END_SRC

#+RESULTS:
: kill-whole-line

*** Minor conveniences
Emacs is at it's best when it just does things for you, shows you the way, guides you so to speak. This can be best achieved using a number of small extensions. While on their own they might not be particularly impressive. Together they create a nice environment for you to work in.

**** Subwords/Camel casing
Emacs treats camelCase strings as a single word by default, this changes said behaviour.

#+BEGIN_SRC emacs-lisp :tangle yes
(global-subword-mode 1)
#+END_SRC

**** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor. Unless you know its position, you cannot move it efficiently. Every time you change buffers, the current position of your cursor will be briefly highlighted now.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package beacon
  :ensure t
  :config
  (beacon-mode 1))
#+END_SRC

#+RESULTS:
: t

**** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them, especially lisp.

Note, however, that Sacha Chua doesn't automatically turn this on because she thinks it slows things down a little. So she has =(use-package rainbow-delimiters :disabled t)=. So keep an eye on it.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :ensure t
  :init
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

#+RESULTS:

*** COMMENT Hungry deletion
On the list of things I like doing, deleting big whitespaces is pretty close to the bottom. Backspace or Delete will get rid of all whitespace until the next non-whitespace character is encountered. You may not like it, thus disable it if you must, but it’s pretty decent.

DGM: I am commenting this out as I found it annoying when, for example, editing ledger files and wanting to delete spaces one by one I found the cursor deleting all the white space and thus indening lines in the wrong manner. La sensacion era como si el buffer estuviera tabify when it wasn't... So I wasn't understanding what was going on until I recalled I had this mode enabled.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package hungry-delete
  :ensure t
  :config
  (global-hungry-delete-mode))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23554 33611 672389 982000) :init (23554 33611 672357 93000) :config (23554 33611 672016 76000) :config-secs (0 0 2391 739000) :init-secs (0 0 3160 173000) :use-package-secs (0 0 3365 347000)))

*** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most. With a simple M-y you can now browse your kill-ring like browsing autocompletion items. C-n and C-p totally work for this.

DGM: nice, but i prefer to use helm to browse the kill ring.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package popup-kill-ring
  :ensure t
  :bind ("M-y" . popup-kill-ring))
#+END_SRC

#+RESULTS:
: popup-kill-ring

** Daniel Mai

https://github.com/danielmai/.emacs.d/blob/master/config.org

*** Page breaks

Here we make page-break characters look pretty, instead of appearing as ^L in Emacs. Here’s an informative article called "Using Page-Breaks in GNU Emacs" by Eric J. M. Ritz.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package page-break-lines
  :ensure t)
#+END_SRC

#+RESULTS:

*** Split window and move to new window <<split>>

Whenever I split windows, I usually do so and also switch to the other window as well, so might as well rebind the splitting key bindings to do just that to reduce the repetition.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun vsplit-other-window ()
  "Splits the window vertically and switches to that window."
  (interactive)
  (split-window-vertically)
  (other-window 1 nil))
(defun hsplit-other-window ()
  "Splits the window horizontally and switches to that window."
  (interactive)
  (split-window-horizontally)
  (other-window 1 nil))

(bind-key "C-x 2" 'vsplit-other-window)
(bind-key "C-x 3" 'hsplit-other-window)
#+END_SRC

#+RESULTS:
: hsplit-other-window

*** COMMENT Transpose frame

Check it out here: https://www.emacswiki.org/emacs/TransposeFrame
Commented out because I don't work with frames and because this functionality is already implemented with =s-\=

#+BEGIN_SRC emacs-lisp :tangle no
(use-package transpose-frame
  :ensure t
  :bind ("C-c t" . transpose-frame))
#+END_SRC

#+RESULTS :
: transpose-frame

*** COMMENT Ace-jump 
A quick way to jump around text in buffers.

See Emacs Rocks Episode 10 for a screencast: http://emacsrocks.com/e10.html

Commented out as =C-o= does the same and =s-z= even better as it applies to any letter anywhere in the buffer.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package ace-jump-mode
  :ensure t
  :diminish ace-jump-mode
  :commands ace-jump-mode
  :bind ("C-s-s" . ace-jump-mode))
#+END_SRC

#+RESULTS:
: ace-jump-mode
*** Smartscan
Quickly jumps between other symbols found at point in Emacs.

Originally, I tried to bind it to =s-p= and =s-n= here, but smartscan kept using =M-p= and =M-n= so now I have changed it at =smartscan.el=. So remember to do this everytime I install .emacs.d anew. 

http://www.masteringemacs.org/article/smart-scan-jump-symbols-buffer

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartscan
  :ensure t
  :config (global-smartscan-mode 1)
  :bind (("C-M-+" . smartscan-symbol-go-forward)
         ("C-M-*" . smartscan-symbol-go-backward))
  ("C-M-'" . smartscan-symbol-replace))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23932 61038 299198 455000) :init (23932 61038 299059 616000) :config (23932 61038 299043 758000) :config-secs (0 0 3819 895000) :init-secs (0 0 3860 798000) :use-package-secs (0 0 4289 188000)))

*** Smoothscrolling
This makes it so =C-n-=ing and =C-p-= ing won’t make the buffer jump around so much.

#+BEGIN_SRC emacs-lisp :tangle no
;; (use-package smooth-scrolling
;;  :ensure t
;;  :config
;;  (smooth-scrolling-mode))
#+END_SRC

#+RESULTS:
: 0.01

More tips from https://www.emacswiki.org/emacs/SmoothScrolling

#+BEGIN_SRC emacs-lisp :tangle yes
;; scroll one line at a time (less "jumpy" than defaults)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
#+END_SRC

#+RESULTS:
: 1

I was driven crazy by the jumps. I had set scroll-step and scroll-conservatively as suggested here but it was still jumping half-screens at random times when scrolling. FINALLY, after many years of cursing, the suggestion of setting auto-window-vscroll to nil, below on this page, worked - even though Emacs documentation only says it applies to tall lines with large images, which I don’t use. In fact it seems to apply to any scrolling with too-slow terminal and too-fast keyboard repeat rate. So, here’s my tested recipe for civilized scrolling, which works regardless of your screen speed and keyboard speed:
(https://www.emacswiki.org/emacs/SmoothScrolling)

#+BEGIN_SRC emacs-lisp :tangle yes
(setq scroll-step 1)
                                        ; Autosave every 500 typed characters. Alternative: try turning off auto save interval altogether.
(setq auto-save-interval 500)
                                        ; Scroll just one line when hitting bottom of window // ;; scrolling to always be a line at a time
(setq scroll-conservatively 10000)
(setq auto-window-vscroll nil)
#+END_SRC

#+RESULTS:

*** Scratch

From: https://github.com/ieure/scratch-el
Convenient package to create *scratch* buffers that are based on the current buffer’s major mode. This is more convienent than manually creating a buffer to do some scratch work or reusing the initial *scratch* buffer.

Se usa con =M-x scratch= y te crea un scratch buffer of the currently used mode. But you can choose another mode by doing =C-u M-x scratch=

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package scratch
  :ensure t
  :commands scratch)
#+END_SRC

#+RESULTS:

*** Visible mode
I found out about this mode by looking through =simple.el=. 
(For the record: =simple.el=  is a grab-bag of basic Emacs commands not specifically related to some major mode or to file-handling.)
I use it to see raw org-mode files without going to a different mode like text-mode, which is what I had done in order to see invisible text (with org hyperlinks). The entire buffer contents will be visible while still being in org mode.

Make visible mode the default, please. I don't use a key binding for this because I don't use it that much and I prefer saving =s-h= for =electric= buffer management.

#+BEGIN_SRC emacs-lisp :tangle yes
(visible-mode 1)
(global-set-key (kbd "s-v") 'visible-mode)
#+END_SRC

#+RESULTS:
: visible-mode

*** Pulseaudio 

Info in https://github.com/flexibeast/pulseaudio-control

Sets prefix to =C-x /=. Then  
=+=: Increase the volume of the currently-selected sink by pulseaudio-control-volume-step (pulseaudio-control-increase-volume).
=-=: Decrease the volume of the currently-selected sink by pulseaudio-control-volume-step (pulseaudio-control-decrease-volume).
=m=: Toggle muting of the currently-selected sink (pulseaudio-control-toggle-current-sink-mute).
=d=: Display volume of the currently-selected sink (pulseaudio-control-display-volume).

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package pulseaudio-control
  :ensure t)

(with-eval-after-load 'pulseaudio-control
  ;; REVIEW: Upstream should set path dynamically.
  ;; https://github.com/flexibeast/pulseaudio-control/issues/7
  (setq pulseaudio-control-pactl-path (executable-find "pactl")
        pulseaudio-control-volume-step "2%"))
#+END_SRC

#+RESULTS:
: 2%

#+BEGIN_SRC emacs-lisp :tangle yes
(pulseaudio-control-default-keybindings)
#+END_SRC

#+RESULTS:
: pulseaudio-control-map

*** Enabling various commands for up/down casing, etc. 

From https://github.com/danielmai/.emacs.d/blob/master/config.org and http://tobytripp.github.io/emacs.d/

#+BEGIN_SRC emacs-lisp :tangle yes
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'dired-find-alternate-file 'disabled nil)
(put 'set-goal-column 'disabled nil)
#+END_SRC

** COMMENT Dashboard

I leave it out as it doesn't work with =exwm=

#+BEGIN_SRC emacs-lisp :tangle no
(use-package dashboard
  :ensure t
  :config
  (dashboard-setup-startup-hook)
                                        ;    (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
  (setq dashboard-items '((recents   . 10)
                          (bookmarks . 10)
                          (projects  . 10)))
  (setq dashboard-banner-logo-title ""))
(message "Testing 2 dashboard chunk is evaluated.")
#+END_SRC

#+RESULTS:
: Testing 2 dashboard chunk is evaluated.

** COMMENT Mark current word
From https://www.emacswiki.org/emacs/MarkCommands#toc7

Commented out as =s-/= does the same and with a better shortcut, as defined  [[select]]

#+BEGIN_SRC emacs-lisp :tangle no
(defun my-mark-current-word (&optional arg allow-extend)
  "Put point at beginning of current word, set mark at end."
  (interactive "p\np")
  (setq arg (if arg arg 1))
  (if (and allow-extend
           (or (and (eq last-command this-command) (mark t))
               (region-active-p)))
      (set-mark
       (save-excursion
         (when (< (mark) (point))
           (setq arg (- arg)))
         (goto-char (mark))
         (forward-word arg)
         (point)))
    (let ((wbounds (bounds-of-thing-at-point 'word)))
      (unless (consp wbounds)
        (error "No word at point"))
      (if (>= arg 0)
          (goto-char (car wbounds))
        (goto-char (cdr wbounds)))
      (push-mark (save-excursion
                   (forward-word arg)
                   (point)))
      (activate-mark))))

(define-key global-map (kbd "C-c x") 'my-mark-current-word) 
#+END_SRC

#+RESULTS:
: my-mark-current-word

** IRC

Sometimes useful for getting help on R or Emacs.

#+source: rirc-configuration
#+begin_src emacs-lisp :tangle yes
;; connect to irc on invocation but don't autojoin any channels (require 'rcirc)
;;  (add-to-list 'rcirc-server-alist
;;                       '("irc.freenode.net")) ;; this code stopped working after my customizations following the mini emacs guide
(setq rcirc-server-alist
      '(("irc.freenode.net" :channels ("#emacs" "#python" "#sml" "#nasm" "#gcc"))))
#+end_src

#+RESULTS: rirc-configuration
| irc.freenode.net | :channels | (#emacs #python #sml #nasm #gcc) |

** Comment or uncomment region 

#+srcname: final-custom
#+begin_src emacs-lisp :tangle yes
;; minimize fringe
(setq-default indicate-empty-lines nil)

;; Add keybindings for commenting regions of text
(global-set-key (kbd "C-c ;") 'comment-or-uncomment-region)
#+end_src

#+RESULTS: final-custom
: comment-or-uncomment-region

** Base dir

#+BEGIN_SRC emacs-lisp :tangle yes
;; Base dir
(cd "~/")
#+END_SRC

#+RESULTS:
: /home/dgm/


** Select whole word <<select>>

From https://emacs.stackexchange.com/questions/35069/best-way-to-select-a-word

#+BEGIN_SRC emacs-lisp :tangle yes
(defun mark-whole-word (&optional arg allow-extend)
  "Like `mark-word', but selects whole words and skips over whitespace.
If you use a negative prefix arg then select words backward.
Otherwise select them forward.

If cursor starts in the middle of word then select that whole word.

If there is whitespace between the initial cursor position and the
first word (in the selection direction), it is skipped (not selected).

If the command is repeated or the mark is active, select the next NUM
words, where NUM is the numeric prefix argument.  (Negative NUM
selects backward.)"
  (interactive "P\np")
  (let ((num  (prefix-numeric-value arg)))
    (unless (eq last-command this-command)
      (if (natnump num)
          (skip-syntax-forward "\\s-")
        (skip-syntax-backward "\\s-")))
    (unless (or (eq last-command this-command)
                (if (natnump num)
                    (looking-at "\\b")
                  (looking-back "\\b")))
      (if (natnump num)
          (left-word)
        (right-word)))
    (mark-word arg allow-extend)))

;; (global-set-key (kbd "s-/") 'mark-whole-word) !!here TODO. REBIND.
#+END_SRC

#+RESULTS:
: mark-whole-word

** Mastering emacs with Mickey Petersen
*** Make =C-n= insert newlines if point is at the end of the buffer

#+BEGIN_SRC emacs-lisp :tangle yes
(setq next-line-add-newlines t)
#+END_SRC

#+RESULTS:
: t

*** Visible mark

Too disruptive. I confuse point for mark and vice versa. 

#+BEGIN_SRC emacs-lisp :tangle no
(defface visible-mark-active ;; put this before (require 'visible-mark)
  '((((type tty) (class mono)))
    (t (:background "magenta"))) "")
(setq visible-mark-max 2)
(setq visible-mark-faces `(visible-mark-face1 visible-mark-face2))

(use-package visible-mark
  :ensure t
  :defer 1
  :init
  (global-visible-mark-mode nil)) ;; too disruptive
#+END_SRC

#+RESULTS:
: [nil 0 1 0 nil require (visible-mark nil t) idle 0]

*** Imenu

Can I make Imenu index the whole buffer even if using FoldingMode and all folds are folded?
From https://www.emacswiki.org/emacs/ImenuMode#toc10

#+BEGIN_SRC emacs-lisp :tangle yes
(defadvice imenu (around unfold-it compile activate)
  (save-restriction
    (widen)
    ad-do-it))
#+END_SRC

#+RESULTS:
: imenu

Quickly force rescan. You can avoid auto rescanning big buffers just making it easy to manually rescan:

#+BEGIN_SRC emacs-lisp :tangle yes
(defun my-imenu-rescan ()
  (interactive)
  (imenu--menubar-select imenu--rescan-item))
#+END_SRC

#+RESULTS:
: my-imenu-rescan

*** Go to symbol easily 

=.el= file for function =ido-goto-symbol= downloaded from https://www.emacswiki.org/emacs/ImenuMode#toc10

#+BEGIN_SRC emacs-lisp :tangle yes
(defun ido-goto-symbol (&optional symbol-list)
  "Refresh imenu and jump to a place in the buffer using Ido."
  (interactive)
  (unless (featurep 'imenu)
    (require 'imenu nil t))
  (cond
   ((not symbol-list)
    (let ((ido-mode ido-mode)
          (ido-enable-flex-matching
           (if (boundp 'ido-enable-flex-matching)
               ido-enable-flex-matching t))
          name-and-pos symbol-names position)
      (unless ido-mode
        (ido-mode 1)
        (setq ido-enable-flex-matching t))
      (while (progn
               (imenu--cleanup)
               (setq imenu--index-alist nil)
               (ido-goto-symbol (imenu--make-index-alist))
               (setq selected-symbol
                     (ido-completing-read "Symbol? " symbol-names))
               (string= (car imenu--rescan-item) selected-symbol)))
      (unless (and (boundp 'mark-active) mark-active)
        (push-mark nil t nil))
      (setq position (cdr (assoc selected-symbol name-and-pos)))
      (cond
       ((overlayp position)
        (goto-char (overlay-start position)))
       (t
        (goto-char position)))))
   ((listp symbol-list)
    (dolist (symbol symbol-list)
      (let (name position)
        (cond
         ((and (listp symbol) (imenu--subalist-p symbol))
          (ido-goto-symbol symbol))
         ((listp symbol)
          (setq name (car symbol))
          (setq position (cdr symbol)))
         ((stringp symbol)
          (setq name symbol)
          (setq position
                (get-text-property 1 'org-imenu-marker symbol))))
        (unless (or (null position) (null name)
                    (string= (car imenu--rescan-item) name))
          (add-to-list 'symbol-names name)
          (add-to-list 'name-and-pos (cons name position))))))))

(global-set-key (kbd "s-?") 'ido-goto-symbol)
#+END_SRC

#+RESULTS:
: ido-goto-symbol

*** TODO =etags= costumization: learn what these =etags= are

TAGS is ancient technology that uses an external tool called =ctags= or =etags= (see manpage for ctags for example) to index function signatures from source files into one big flat file. Emacs has excellent support for TAGS (but again lacks the fuzziness ido provides, unless you write some elisp) but TAGS was never meant for modern object-oriented languages as it struggles with the hierarchical nature of the code; another big problem is that TAGS is unbearably slow on large codebases, making it unusable in single-threaded Emacs.

The two bread-and-butter TAGS commands to find stuff are bound to M-, and M-. (use M-* to jump back); there is also an Emacs-style apropos command called M-x tags-apropos for wildcard search.

If you use my code below, you can use C-. to find by file in the TAGS file, like a poor man’s IDE-style project file.

I don’t remember if I wrote the code below (or if I simply snarfed it from somewhere and modified it.)

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package etags)
(defun ido-find-tag ()
  "Find a tag using ido"
  (interactive)
  (tags-completion-table)
  (let (tag-names)
    (mapc (lambda (x)
            (unless (integerp x)
              (push (prin1-to-string x t) tag-names)))
          tags-completion-table)
    (find-tag (ido-completing-read "Tag: " tag-names))))

(defun ido-find-file-in-tag-files ()
  (interactive)
  (save-excursion
    (let ((enable-recursive-minibuffers t))
      (visit-tags-table-buffer))
    (find-file
     (expand-file-name
      (ido-completing-read
       "Project file: " (tags-table-files) nil t)))))

(global-set-key [remap find-tag] 'ido-find-tag)
(global-set-key (kbd "C-`") 'ido-find-file-in-tag-files)
#+END_SRC

#+RESULTS:
: ido-find-file-in-tag-files

*** Mark functionality
**** Explicitly set the mark

From https://www.masteringemacs.org/article/fixing-mark-commands-transient-mark-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(defun push-mark-no-activate ()
  "Pushes `point' to `mark-ring' and does not activate the region
   Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
  (interactive)
  (push-mark (point) t nil)
  (message "Pushed mark to ring"))

(global-set-key (kbd "C-.") 'push-mark-no-activate)
#+END_SRC

#+RESULTS:
: push-mark-no-activate

**** Jump to mark

The C-u C-SPC command jumps to mark but Petersen prefers to jump to the mark with a shortcut bound to =M-`=.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun jump-to-mark ()
  "Jumps to the local mark, respecting the `mark-ring' order.
  This is the same as using \\[set-mark-command] with the prefix argument."
  (interactive)
  (set-mark-command 1))
(global-set-key (kbd "M-`") 'jump-to-mark)
#+END_SRC

#+RESULTS:
: jump-to-mark

**** Exchange point and mark without activating the region 

The exchange-point-and-mark, bound to C-x C-x, will by default activate the region when it is invoked. You must use the prefix argument to suppress the activation, but I find that to be too cumbersome for day-to-day use so I disable it outright. The snippet below will do this, so if you don’t want that to happen don’t use the snippet below!

#+BEGIN_SRC emacs-lisp :tangle yes
(defun exchange-point-and-mark-no-activate ()
  "Identical to \\[exchange-point-and-mark] but will not activate the region."
  (interactive)
  (exchange-point-and-mark)
  (deactivate-mark nil))
(define-key global-map [remap exchange-point-and-mark] 'exchange-point-and-mark-no-activate)
#+END_SRC

#+RESULTS:
: exchange-point-and-mark-no-activate

** Interleave 

From Reddit: https://www.reddit.com/r/emacs/comments/4gudyw/help_me_with_my_orgmode_workflow_for_notetaking/

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package interleave
  :ensure t)
#+END_SRC

#+RESULTS:

** pdf-tools

From https://github.com/politza/pdf-tools

#+BEGIN_SRC emacs-lisp :tangle no
(use-package pdf-tools
  :ensure t)

;; (pdf-tools-install) ;; commented out as I think it gets activated below
#+END_SRC

New set up from https://www.reddit.com/r/emacs/comments/bge7tc/how_to_solve_lisp_error_error_no_such_page_12_in/

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package pdf-tools
  :config (pdf-tools-install)
  ;; open pdfs scaled to fit page
  (setq-default pdf-view-display-size 'fit-page)
  ;; automatically annotate highlights
  (setq pdf-annot-activate-created-annotations t)
  ;; use normal isearch
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23756 1806 717499 856000) :init (23756 1806 717488 199000) :config (23756 1806 717282 366000) :config-secs (0 0 3952 597000) :init-secs (0 0 4544 781000) :use-package-secs (0 0 4590 657000)))

*** Fix for the error before first and last page
From: https://www.reddit.com/r/emacs/comments/bge7tc/how_to_solve_lisp_error_error_no_such_page_12_in/

There is a command very similar to =pdf-view-next-page=, pdf-view-next-page-command. pdf-view-next-page-command is identical except that it doesn't complain when you try to scroll past the last page. You should open an issue for this. Unless there are some other reasons that I missed, pdf-view-scroll-up-or-next-page and pdf-view-scroll-down-or-previous-page should be calling the ...-command version instead. Until this is fixed by the author, you can use this snippet to redefine the commands yourself.

#+BEGIN_SRC emacs-lisp :tangle yes
(with-eval-after-load "pdf-view"
  (defun pdf-view-scroll-up-or-next-page (&optional arg)
    "Scroll page up ARG lines if possible, else go to the next page.
When `pdf-view-continuous' is non-nil, scrolling upward at the
bottom edge of the page moves to the next page.  Otherwise, go to
next page only on typing SPC (ARG is nil)."
    (interactive "P")
    (if (or pdf-view-continuous (null arg))
        (let ((hscroll (window-hscroll))
              (cur-page (pdf-view-current-page)))
          (when (or (= (window-vscroll) (image-scroll-up arg))
                    ;; Workaround rounding/off-by-one issues.
                    (memq pdf-view-display-size
                          '(fit-height fit-page)))
            (pdf-view-next-page-command)
            (when (/= cur-page (pdf-view-current-page))
              (image-bob)
              (image-bol 1))
            (set-window-hscroll (selected-window) hscroll)))
      (image-scroll-up arg)))

  (defun pdf-view-scroll-down-or-previous-page (&optional arg)
    "Scroll page down ARG lines if possible, else go to the previous page.
When `pdf-view-continuous' is non-nil, scrolling downward at the
top edge of the page moves to the previous page.  Otherwise, go
to previous page only on typing DEL (ARG is nil)."
    (interactive "P")
    (if (or pdf-view-continuous (null arg))
        (let ((hscroll (window-hscroll))
              (cur-page (pdf-view-current-page)))
          (when (or (= (window-vscroll) (image-scroll-down arg))
                    ;; Workaround rounding/off-by-one issues.
                    (memq pdf-view-display-size
                          '(fit-height fit-page)))
            (pdf-view-previous-page-command)
            (when (/= cur-page (pdf-view-current-page))
              (image-eob)
              (image-bol 1))
            (set-window-hscroll (selected-window) hscroll)))
      (image-scroll-down arg))))
#+END_SRC

#+RESULTS:
: pdf-view-scroll-down-or-previous-page

*** pdf colors

Tweaking from Ambrevar's dot file. However, his original combination of colors was too aggresive for me. Researching on the web, I came across this article https://www.cs.cmu.edu/~jbigham/pubs/pdfs/2017/colors.pdf and it looks cool now.

#+BEGIN_SRC emacs-lisp :tangle yes
(when (require 'pdf-tools nil t)
  ;; (setq pdf-view-midnight-colors '("#ffffff" . "#000000")) 
  ;; (setq pdf-view-midnight-colors '("#ff9900" . "#0a0a12" )) ; Amber's original combination. Too agressive for me. 
  (setq pdf-view-midnight-colors '("black" . "#EDD1B9" )) ; peach is the answer.
  (add-hook 'pdf-view-mode-hook 'pdf-view-midnight-minor-mode)
  (pdf-tools-install t t t))
#+END_SRC

#+RESULTS:

** Markdown-mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package markdown-mode
  :ensure t)
#+END_SRC

#+RESULTS:

* Tuhdo's customization
** Compilation
#+begin_src emacs-lisp :tangle yes
;; Compilation
(global-set-key (kbd "<f5>") (lambda ()
                               (interactive)
                               (setq-local compilation-read-command nil)
                               (call-interactively 'compile)))
#+end_src

** Windows' management  

*** with zygospore

Read: https://github.com/LouisKottmann/zygospore.el

Automatically indent when press RET

#+begin_src emacs-lisp :tangle yes
(use-package zygospore
  :bind (("C-x 1" . zygospore-toggle-delete-other-windows)
         ("RET" .   newline-and-indent)))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23923 31552 263267 99000) :init (23923 31552 263072 607000) :init-secs (0 0 106 846000) :use-package-secs (0 7 24665 828000)))

** Debugging with GDB
#+begin_src emacs-lisp :tangle yes
;; setup GDB
(setq
 ;; use gdb-many-windows by default
 gdb-many-windows t

 ;; Non-nil means display source file containing the main routine at startup
 gdb-show-main t
 )
#+end_src

#+RESULTS:
: t
** Editing
Delete Selection mode lets you treat an Emacs region much like a typical text selection outside of Emacs: You can replace the active region just by typing text, and you can delete the selected text just by hitting the Backspace key (<DEL>).

#+begin_src emacs-lisp :tangle yes
(delete-selection-mode)
(global-set-key (kbd "RET") 'newline-and-indent)
#+end_src

*** Query / replace made prettier

Provides a minor mode which displays current match and total matches information in the mode-line in various search modes.

#+begin_src emacs-lisp :tangle yes
(use-package anzu
  :init
  (global-anzu-mode)
  (global-set-key (kbd "M-%") 'anzu-query-replace)
  (global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23923 33334 299974 138000) :init (23923 33334 299966 754000) :config (23923 33334 299811 570000) :config-secs (0 0 5 573000) :init-secs (0 0 18581 875000) :use-package-secs (0 1 712419 760000)))

** Killing

Costumization of simple functions.. check wheather I like them.
#+begin_src emacs-lisp :tangle yes
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single
line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position)
           (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single
  line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))

;; kill a line, including whitespace characters until next non-whitespace character of next line
(defadvice kill-line (before check-position activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (if (and (eolp) (not (bolp)))
          (progn (forward-char 1)
                 (just-one-space 0)
                 (backward-char 1)))))

;; DGM adds this as C-k is bound to both kill-line and kill-visual-line
(defadvice kill-visual-line (before check-position activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (if (and (eolp) (not (bolp)))
          (progn (forward-char 1)
                 (just-one-space 0)
                 (backward-char 1)))))
#+end_src

#+RESULTS:
: kill-visual-line

pp
#+RESULTS:
: kill-line


** Indentation á la Prelude

Taken from prelude-editor.el
Automatically indenting yanked text if in programming-modes

#+begin_src emacs-lisp :tangle yes
(defvar yank-indent-modes
  '(LaTeX-mode TeX-mode)
  "Modes in which to indent regions that are yanked (or yank-popped).
Only modes that don't derive from `prog-mode' should be listed here.")

(defvar yank-indent-blacklisted-modes
  '(python-mode slim-mode haml-mode)
  "Modes for which auto-indenting is suppressed.")

(defvar yank-advised-indent-threshold 1000
  "Threshold (# chars) over which indentation does not automatically occur.")

(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) yank-advised-indent-threshold)
      (indent-region beg end nil)))

(defadvice yank (after yank-indent activate)
  "If current mode is one of 'yank-indent-modes,
indent yanked text (with prefix arg don't indent)."
  (if (and (not (ad-get-arg 0))
           (not (member major-mode yank-indent-blacklisted-modes))
           (or (derived-mode-p 'prog-mode)
               (member major-mode yank-indent-modes)))
      (let ((transient-mark-mode nil))
        (yank-advised-indent-function (region-beginning) (region-end)))))

(defadvice yank-pop (after yank-pop-indent activate)
  "If current mode is one of `yank-indent-modes',
indent yanked text (with prefix arg don't indent)."
  (when (and (not (ad-get-arg 0))
             (not (member major-mode yank-indent-blacklisted-modes))
             (or (derived-mode-p 'prog-mode)
                 (member major-mode yank-indent-modes)))
    (let ((transient-mark-mode nil))
      (yank-advised-indent-function (region-beginning) (region-end)))))

;; prelude-core.el
(defun indent-buffer ()
  "Indent the currently visited buffer."
  (interactive)
  (indent-region (point-min) (point-max)))

;; prelude-editing.el
(defcustom prelude-indent-sensitive-modes
  '(coffee-mode python-mode slim-mode haml-mode yaml-mode)
  "Modes for which auto-indenting is suppressed."
  :type 'list)

(defun indent-region-or-buffer ()
  "Indent a region if selected, otherwise the whole buffer."
  (interactive)
  (unless (member major-mode prelude-indent-sensitive-modes)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-buffer)
          (message "Indented buffer.")))
      (whitespace-cleanup))))

(global-set-key (kbd "s->") 'indent-region-or-buffer)
#+end_src

#+RESULTS:
: indent-region-or-buffer

** Line functions á la Prelude
Add duplicate line function from Prelude. Taken from =prelude-core.el=

#+begin_src emacs-lisp :tangle yes
(defun prelude-get-positions-of-line-or-region ()
  "Return positions (beg . end) of the current line
or region."
  (let (beg end)
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    (setq end (line-end-position))
    (cons beg end)))

;; smart openline
(defun prelude-smart-open-line (arg)
  "Insert an empty line after the current line.
Position the cursor at its beginning, according to the current mode.
With a prefix ARG open line above the current line."
  (interactive "P")
  (if arg
      (prelude-smart-open-line-above)
    (progn
      (move-end-of-line nil)
      (newline-and-indent))))

(defun prelude-smart-open-line-above ()
  "Insert an empty line above the current line.
Position the cursor at it's beginning, according to the current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))

(global-set-key (kbd "s-@") 'prelude-smart-open-line)
(global-set-key (kbd "s-@") 'open-line)
#+end_src

#+RESULTS:
: open-line

** CEDET for C editing

#+begin_src emacs-lisp :tangle yes
(require 'setup-cedet)
#+end_src

#+RESULTS:
: setup-cedet

* Tuhdo's customization of Helm's appearance

Sometimes, customization of helm's looks set in =starter-kit-helm.org= gets overriden... that's why I place it here now.
From: https://www.reddit.com/r/emacs/comments/2z7nbv/lean_helm_window/

Helm window is too big? That's why you have helm-autoresize-mode:

#+BEGIN_SRC emacs-lisp :tangle yes
(setq  helm-display-header-line nil)
#+END_SRC

The resizing is too annoying and you only want the window to be less varied or even at a different fixed size rather than the default size? It can be done with:

#+BEGIN_SRC emacs-lisp :tangle yes
(helm-autoresize-mode -1)
(setq helm-autoresize-max-height 30)
(setq helm-autoresize-min-height 30)
#+END_SRC

Now, you have a Helm window that always takes 30% of your frame height.

One of the thing that annoyed me with Ido is that it is always at the bottom in the minibuffer and raise the mode line. If you are like me, you may want to open Helm window in the current window where point is in, so you don't have to move eyes far away from the upper-half of the window to the minibuffer. This is problematic if you have large monitor (i.e. 24 inches or above).

By setting this:

#+BEGIN_SRC emacs-lisp :tangle yes
;; (setq helm-split-window-in-side-p t)
(setq helm-split-window-inside-p t)
#+END_SRC

Now, Helgm always opens a small window right inside and at the lower half of current window. No more random Helm window! 

You may want to remove the header line for Helm command with only one source. 

For Helm command with multiple sources, the header line appears as a very thin line. This is fine, but if you want Helm to be a bit smart, that is, keep the full source header line when multiple sources and hidden when there's a single source, you can add the following function to =helm-before-initialize-hook=:
(Now, Helm appears as usual when there's multiple sources.)

From https://emacs.stackexchange.com/questions/5772/how-to-change-helms-highlight-color 
I try to change helm selection in minibuffer so that it is highlighted.

#+BEGIN_SRC emacs-lisp :tangle yes
(defvar helm-source-header-default-background (face-attribute 'helm-source-header :background))
(defvar helm-source-header-default-foreground (face-attribute 'helm-source-header :foreground))
(defvar helm-source-header-default-box (face-attribute 'helm-source-header :box))

(defun helm-toggle-header-line ()
  (if (> (length helm-sources) 1)
      (set-face-attribute 'helm-source-header
                          nil
                          :foreground helm-source-header-default-foreground
                          :background helm-source-header-default-background
                          :box helm-source-header-default-box
                          :height 1.0)
    (set-face-attribute 'helm-source-header
                        nil
                        :foreground (face-attribute 'helm-selection :background)
                        :background (face-attribute 'helm-selection :background)
                        :box nil
                        :height 0.1)))
;;(when window-system
;;  (custom-set-faces
;;   '(helm-selection ((t (:background "#4682b4" :foreground "#F5f5f5"))))))
;; Change Helm's selection color
;; Orange3: "#Cd8500"
;;(set-face-attribute 'helm-selection nil 
;;                    :background nil
;;                    :foreground "#Cd8500") 
(set-face-attribute 'helm-selection nil 
                    :background nil
                    :foreground "Orange3")
(set-face-attribute 'helm-source-header  nil
                    :foreground "#dcdcdc")
;; ;; Change Helm's color of Source!!
;; (set-face-attribute 'helm-source-header nil 
;;                    :background "DeepSkyBlue4"
;;                    :foreground "black")

(set-face-attribute 'helm-buffer-directory nil :background 'unspecified :foreground "#1e90ff" :weight 'bold)  
#+END_SRC

#+RESULTS:

** COMMENT Further customization of helm's looks, mainly colors

If I place this in the =starter-kit-helm.org= file, for some reason, probably because some code in the way overlaps the following, it does not work.

#+BEGIN_SRC emacs-lisp :tangle no
;; comment out by dgm
;;;;; (set-face-attribute 'helm-source-header nil :inherit 'header-line :height 'unspecified :background 'unspecified :foreground 'unspecified)
                                        ;(set-face-background 'helm-selection "#4f4f4f")  
                                        ;(set-face-background 'helm-visible-mark "#2f2f2f")
                                        ;(set-face-foreground 'helm-visible-mark nil)
                                        ;(set-face-foreground 'helm-match "DarkOrange3")
                                        ;(set-face-attribute 'helm-buffer-file nil :background 'unspecified :foreground nil :weight 'normal)
                                        ;(set-face-attribute 'helm-buffer-directory nil :background 'unspecified :foreground "#1e90ff" :weight 'bold)  ;; #1e90ff
                                        ;(set-face-attribute 'helm-ff-directory nil :background 'unspecified :foreground 'unspecified :weight 'unspecified :inherit 'helm-buffer-directory)
                                        ;(set-face-attribute 'helm-ff-file nil :background 'unspecified :foreground 'unspecified :weight 'unspecified :inherit 'helm-buffer-file)
                                        ;(set-face-foreground 'helm-grep-finish "green4")
#+END_SRC

#+RESULTS:

* Bookmark Plus

https://www.emacswiki.org/emacs/BookmarkPlus

#+BEGIN_SRC emacs-lisp :tangle yes
(require 'bookmark+)
#+END_SRC

#+RESULTS:
: bookmark+

* Ledger

From 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ledger-mode
  :ensure t
  :init
  (setq ledger-clear-whole-transactions 1)
  ;;:config
  ;;(add-to-list 'ledger-report-mode) ;; Gives error Compiler-macro error for add-to-list: (wrong-number-of-arguments (3 . 5) 2)
  :mode "\\.dat\\'")
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23548 17303 871458 855000) :init (23548 17303 871411 289000) :init-secs (0 0 97 698000) :use-package-secs (0 0 314 844000)))

* Nice symbol for end of file lines

From https://www.reddit.com/r/emacs/comments/2kdztw/emacs_in_evil_mode_show_tildes_for_blank_lines/

Originally here:

#+BEGIN_SRC emacs-lisp :tangle yes
;;(setq-default indicate-empty-lines t)
;;(define-fringe-bitmap 'tilde [0 0 0 113 219 142 0 0] nil nil 'center)
;;(setcdr (assq 'empty-line fringe-indicator-alist) 'tilde)
;;(set-fringe-bitmap-face 'tilde 'font-lock-comment-face)
;;;;;;; (set-fringe-bitmap-face 'tilde 'font-lock-function-name-face) ;; for blue tilde
#+END_SRC

But then the guy turned it into a minor mode! See 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package vi-tilde-fringe)
(global-vi-tilde-fringe-mode 1)
#+END_SRC

#+RESULTS:
: t

To turn it on automatically only for programming modes:

=(add-hook 'prog-mode-hook 'vi-tilde-fringe-mode)=


Open the customization group buffer:

=M-x customize-group RET vi-tilde-fringe RET=

* Diminishing modes 

Your modeline is sacred, and if you have a lot of modes enabled, as you will if you use this config, you might end up with a lot of clutter there, the package diminish disables modes on the mode line but keeps them running, it just prevents them from showing up and taking up space.

THIS WILL BE REMOVED SOON AS USE-PACKAGE HAS THE FUNCTIONALITY BUILT IN

Edit this list as you see fit!

PS: recall that the =diminish= package is installed in =starter-kit.org=.

#+BEGIN_SRC emacs-lisp :tangle yes
(diminish 'which-key-mode)
(diminish 'linum-relative-mode)
(diminish 'hungry-delete-mode)
(diminish 'visual-line-mode)
(diminish 'subword-mode)
(diminish 'beacon-mode)
(diminish 'irony-mode)
(diminish 'page-break-lines-mode)
;;  (diminish 'auto-revert-mode)
(diminish 'rainbow-delimiters-mode)
(diminish 'yas-minor-mode)
(diminish 'rainbow-mode)
;;  (diminish 'undo-tree-mode)
(diminish 'editorconfig-mode)
;;  (diminish 'smartparens-mode) ;; added in -text.org
(diminish 'minimal-mode)
(diminish 'org-mode)
(diminish 'org-indent-mode)
(diminish 'volatile-highlights-mode) 
(diminish 'highlight-symbol-mode) 
(diminish 'pandoc-mode) 
;;  (diminish 'projectile-mode) 
(diminish 'browse-kill-ring-mode) 
(diminish 'auto-fill-mode) 
(diminish 'refill-mode) 
(diminish 'helm-gtags-mode) 
(diminish 'vi-tilde-fringe-mode)
(diminish 'dired)
#+END_SRC

#+RESULTS:

* Euro symbol 

From https://astrofloyd.wordpress.com/2014/08/11/insert-the-euro-symbol-e-in-emacs/
But it doesn't work

#+BEGIN_SRC emacs-lisp :tangle no
(fset 'euro
      (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([24 56 return 35 120 50 48 65 67 return] 0 "%d")) arg)))
#+END_SRC

#+RESULTS:
| lambda | (&optional arg) | Keyboard macro. | (interactive p) | (kmacro-exec-ring-item '([24 56 return 35 120 50 48 65 67 return] 0 %d) arg) |

The euro sign can then be inserted by calling the macro:

M-x euro

* Font-locking shell prompt
Tip from 
http://www.modernemacs.com/post/shell-font-lock/

#+BEGIN_SRC emacs-lisp :tangle yes
(defmacro hy--shell-with-shell-buffer (&rest forms)
  "Execute FORMS in the shell buffer."
  (-let [shell-process
         (gensym)]
    `(-let [,shell-process
            (hy-shell-get-process)]
       (with-current-buffer (process-buffer ,shell-process)
         ,@forms))))

(defmacro hy--shell-with-font-locked-shell-buffer (&rest forms)
  "Execute FORMS in the shell buffer with font-lock turned on."
  `(hy--shell-with-shell-buffer
    (save-current-buffer
      (unless (hy--shell-buffer?)
        (setq hy-shell-buffer (hy--shell-get-or-create-buffer)))
      (set-buffer hy-shell-buffer)

      (unless (font-lock-mode) (font-lock-mode 1))
      (unless (derived-mode-p 'hy-mode) (hy-mode))

      ,@forms)))

(defun hy--shell-faces-to-font-lock-faces (text &optional start-pos)
  "Set all 'face in TEXT to 'font-lock-face optionally starting at START-POS."
  (let ((pos 0)
        (start-pos (or start-pos 0)))
    (while (and (/= pos (length text))
                (setq next (next-single-property-change pos 'face text)))
      (let* ((plist (text-properties-at pos text))
             (plist (-if-let (face (plist-get plist 'face))
                        (progn (plist-put plist 'face nil)  ; Swap face
                               (plist-put plist 'font-lock-face face))
                      plist)))
        (set-text-properties (+ start-pos pos) (+ start-pos next) plist)
        (setq pos next)))))

(defun hy--shell-fontify-prompt-post-command-hook ()
  "Fontify just the current line in `hy-shell-buffer' for `post-command-hook'.

Constantly extracts current prompt text and executes and manages applying
`hy--shell-faces-to-font-lock-faces' to the text."
  (-when-let* (((_ . prompt-end) comint-last-prompt)
               (_ (and prompt-end
                       (> (point) prompt-end)  ; new command is being entered
                       (hy--shell-current-buffer-a-process?))))  ; process alive?
    (let* ((input (buffer-substring-no-properties prompt-end (point-max)))
           (deactivate-mark nil)
           (buffer-undo-list t)
           (font-lock-buffer-pos nil)
           (text (hy--shell-with-font-locked-shell-buffer
                  (delete-region (line-beginning-position) (point-max))
                  (setq font-lock-buffer-pos (point))
                  (insert input)
                  (font-lock-ensure)
                  (buffer-substring font-lock-buffer-pos (point-max)))))
      (hy--shell-faces-to-font-lock-faces text prompt-end))))

(defun hy--shell-font-lock-turn-on ()
  "Turn on fontification of current line for hy shell."
  (hy--shell-with-shell-buffer
   (hy--shell-kill-buffer)

   (setq-local hy-shell-buffer nil)

   (add-hook 'post-command-hook
             'hy--shell-fontify-prompt-post-command-hook nil 'local)
   (add-hook 'kill-buffer-hook
             'hy--shell-kill-buffer nil 'local)))
#+END_SRC

#+RESULTS:
: hy--shell-font-lock-turn-on

* Sacha Chua
** Minibuffer editing - more space!

Sometimes you want to be able to do fancy things with the text that you're entering into the minibuffer. Sometimes you just want to be able to read it, especially when it comes to lots of text. This binds C-M-e in a minibuffer) so that you can edit the contents of the minibuffer before submitting it. 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package miniedit
  :commands minibuffer-edit
  :init (miniedit-install))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23912 62075 948264 318000) :init (23912 62075 948249 876000) :config (23912 62075 948229 579000) :config-secs (0 0 3 966000) :init-secs (0 0 47 445000) :use-package-secs (0 0 116 827000)))

** Copy filename to clipboard

http://emacsredux.com/blog/2013/03/27/copy-filename-to-the-clipboard/ https://github.com/bbatsov/prelude 

#+BEGIN_SRC emacs-lisp :tangle yes
(defun yank-file-name ()
  "Yanks current buffer file name and its path to the kill ring."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Yanks buffer file name and its path '%s' to the kill ring." filename)))) 
#+END_SRC

#+RESULTS:
: yank-file-name
** Edit list   

=M-x edit-list= makes it easier to edit an Emacs Lisp list. 

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package edit-list :commands edit-list)
#+END_SRC

** Weather forecast

Sacha has this but it doesn't work because it doesn't interpret my latitude and longitude as numbers.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package forecast
  :config
  (setq forecast-latitude  40.4
        forecast-longitude -3.7
        forecast-city "Madrid"
        forecast-country "Spain"
        forecast-api-key "b580b82a056cdb3f6089f08ece4b2eb6"
        )
  )
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23735 33070 905741 448000) :init (23735 33070 905733 834000) :config (23735 33070 905590 741000) :config-secs (0 0 254 799000) :init-secs (0 0 543 959000) :use-package-secs (0 0 599 374000)))

** Sunrise/sunset

Special calendar commands can tell you, to within a minute or two, the times of sunrise
and sunset for any date. 

mouse-3 Sunrise/sunset
S
Display times of sunrise and sunset for the selected date (calendar-sunrise-sunset).
=M-x sunrise-sunset=
Display times of sunrise and sunset for today's date. 
=C-u M-x sunrise-sunset=
Display times of sunrise and sunset for a specified date. 
=M-x calendar-sunrise-sunset-month=
Display times of sunrise and sunset for the selected month. 

Within the calendar, to display the local times of sunrise and sunset in the echo area,
move point to the date you want, and type S. Alternatively, click mouse-3 on the date,
then choose ‘Sunrise/sunset’ from the menu that appears. The command M-x
sunrise-sunset is available outside the calendar to display this information for today's
date or a specified date. To specify a date other than today, use C-u M-x
sunrise-sunset, which prompts for the year, month, and day. 

You can display the times of sunrise and sunset for any location and any date with C-u
=C-u M-x sunrise-sunset=. This asks you for a longitude, latitude, number of minutes
difference from Coordinated Universal Time, and date, and then tells you the times of
sunrise and sunset for that location on that date. 

Because the times of sunrise and sunset depend on the location on earth, you need to tell Emacs your latitude, longitude, and location name before using these commands.

Here is an example of what to set: 

#+BEGIN_EXAMPLE
     (setq calendar-latitude 40.1)
     (setq calendar-longitude -88.2)
     (setq calendar-location-name "Urbana, IL")
#+END_EXAMPLE

Use one decimal place in the values of calendar-latitude and calendar-longitude. 

Your time zone also affects the local time of sunrise and sunset. Emacs usually gets time zone information from the operating system, but if these values are not what you want (or if the operating system does not supply them), you must set them yourself. Here is an example: 

#+BEGIN_EXAMPLE
     (setq calendar-time-zone -360)
     (setq calendar-standard-time-zone-name "CST")
     (setq calendar-daylight-time-zone-name "CDT")
#+END_EXAMPLE

The value of calendar-time-zone is the number of minutes difference between your
local standard time and Coordinated Universal Time (Greenwich time). The values of
calendar-standard-time-zone-name and calendar-daylight-time-zone-name are the
abbreviations used in your time zone. Emacs displays the times of sunrise and sunset corrected for daylight saving time. See Daylight Saving, for how daylight saving time is determined. 

As a user, you might find it convenient to set the calendar location variables for your usual physical location in your .emacs file. If you are a system administrator, you may want to set these variables for all users in a default.el file. See Init File. 

#+BEGIN_SRC emacs-lisp :tangle yes
(setq calendar-latitude 40.4)
(setq calendar-longitude -3.7)
(setq calendar-location-name "Madrid, Spain")
#+END_SRC

#+RESULTS:
: Madrid, Spain

*** Pragmatic Emacs alternative

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package wttrin
  :ensure t
  :commands (wttrin)
  :init
  (setq wttrin-default-cities '("Madrid"
                                "Fuengirola"
                                "Malaga")))

(setq wttrin-default-accept-language '("Accept-Language" . "en-US"))
#+END_SRC

#+RESULTS:
: (Accept-Language . en-US)

The only problem is that if the Emacs frame is not wide enough and the lines in the wttrin buffer wrap, it becomes unreadable. 

My solution is to save the window and frame configuration, then resize the frame to be big enough for the wttrin buffer. The previous configuration is then restored when exiting wttrin. These functions take care of that for us: 

Disabled by DGM as it makes wttrin fail to work.

#+BEGIN_SRC emacs-lisp :tangle no
;;advise wttrin to save frame arrangement
;;requires frame-cmds package
(defun bjm/wttrin-save-frame ()
  "Save frame and window configuration and then expand frame for wttrin."
  ;;save window arrangement to a register
  (window-configuration-to-register :pre-wttrin)
  (delete-other-windows)
  ;;save frame setup and resize
  (save-frame-config)
  (set-frame-width (selected-frame) 130)
  (set-frame-height (selected-frame) 48)
  )
(advice-add 'wttrin :before #'bjm/wttrin-save-frame)

(defun bjm/wttrin-restore-frame ()
  "Restore frame and window configuration saved prior to launching wttrin."
  (interactive)
  (jump-to-frame-config-register)
  (jump-to-register :pre-wttrin)
  )
(advice-add 'wttrin-exit :after #'bjm/wttrin-restore-frame)
#+END_SRC

#+RESULTS:

**** Update: open wttrin with default city

By default wttrin prompts you to chose the city from your list when it starts. This function starts wttrin with the first city on your list. You can always change this by hitting =g=. 

#+BEGIN_SRC emacs-lisp :tangle yes
;; function to open wttrin with first city on list
(defun bjm/wttrin ()
  "Open `wttrin' without prompting, using first city in `wttrin-default-cities'"
  (interactive)
  ;; save window arrangement to register 
  (window-configuration-to-register :pre-wttrin)
  (delete-other-windows)
  ;; save frame setup
  (save-frame-config)
  (set-frame-width (selected-frame) 130)
  (set-frame-height (selected-frame) 48)
  ;; call wttrin
  (wttrin-query (car wttrin-default-cities))
  )
#+END_SRC

#+RESULTS:
: bjm/wttrin
g
** Typing of Emacs

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package typing 
  :init
  (autoload 'typing-of-emacs "typing" nil t)
  :config
  (progn
    (setq toe-starting-length 6)
    (setq toe-starting-time-per-word 2)
    (setq toe-max-length 20)))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23592 62164 535459 40000) :init (23592 62164 535445 976000) :config (23592 62164 535242 82000) :config-secs (0 0 354 294000) :init-secs (0 0 5340 661000) :use-package-secs (0 9 443861 775000)))

** Sentences end with a single space

In my world, sentences end with a single space. This makes sentence navigation commands work for me.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq sentence-end-double-space nil)
#+END_SRC

** Killing text

From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el

#+BEGIN_SRC emacs-lisp :tangle yes
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+END_SRC

** Help - guide-key

It's hard to remember keyboard shortcuts. The =guide-key= package pops up help after a short delay.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package guide-key
  :defer t
  :diminish guide-key-mode
  :config
  (progn
    (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
    (guide-key-mode 1)))  ; Enable guide-key-mode
#+END_SRC

** Reading

https://github.com/xahlee/xah_emacs_init/blob/master/xah_emacs_font.el
From Xah Lee:

#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-toggle-margin-right ()
  "Toggle the right margin between `fill-column' or window width.
This command is convenient when reading novel, documentation."
  (interactive)
  (if (eq (cdr (window-margins)) nil)
      (set-window-margins nil 0 (- (window-body-width) fill-column))
    (set-window-margins nil 0 0)))
#+END_SRC

#+RESULTS:
: xah-toggle-margin-right

** Shuffling lines

Don't really know what this does.

#+begin_src emacs-lisp :tangle yes
(defun my/shuffle-lines-in-region (beg end)
  (interactive "r")
  (let ((list (split-string (buffer-substring beg end) "[\r\n]+")))
    (delete-region beg end)
    (insert (mapconcat 'identity (shuffle-list list) "\n"))))
#+end_src

#+RESULTS:
: my/shuffle-lines-in-region

** Pop to mark

Handy way of getting back to previous places. Nice but I already have =C-h SPC= for mark's kill ring and =M-`= to jump to marks in local ring (by way of Petersen)

#+BEGIN_SRC emacs-lisp :tangle yes
;; (bind-key "s-:" 'pop-to-mark-command)
(setq set-mark-command-repeat-pop t)
#+END_SRC

#+RESULTS:
: t

** Jumping to code

#+begin_src emacs-lisp :tangle yes
(define-key emacs-lisp-mode-map (kbd "C-c .") 'find-function-at-point)
(bind-key "C-c f" 'find-function)
#+end_src

** Sorting

#+begin_src emacs-lisp :tangle yes
(defun my/sort-sexps-in-region (beg end)
  "Can be handy for sorting out duplicates.
Sorts the sexps from BEG to END. Leaves the point at where it
couldn't figure things out (ex: syntax errors)."
  (interactive "r")
  (let ((input (buffer-substring beg end))
        list last-point form result)
    (save-restriction
      (save-excursion
        (narrow-to-region beg end)
        (goto-char (point-min))
        (setq last-point (point-min))
        (setq form t)
        (while (and form (not (eobp)))
          (setq form (ignore-errors (read (current-buffer))))
          (when form
            (add-to-list
             'list
             (cons
              (prin1-to-string form)
              (buffer-substring last-point (point))))
            (setq last-point (point))))
        (setq list (sort list (lambda (a b) (string< (car a) (car b)))))
        (delete-region (point-min) (point))
        (insert (mapconcat 'cdr list "\n"))))))
#+end_src

**** Evaluation

Borrowed from Steve Purcell's config. This pretty-prints the results.

#+begin_src emacs-lisp :tangle yes
(bind-key "M-:" 'pp-eval-expression)

(defun sanityinc/eval-last-sexp-or-region (prefix)
  "Eval region from BEG to END if active, otherwise the last sexp."
  (interactive "P")
  (if (and (mark) (use-region-p))
      (eval-region (min (point) (mark)) (max (point) (mark)))
    (pp-eval-last-sexp prefix)))

(bind-key "C-x C-e" 'sanityinc/eval-last-sexp-or-region emacs-lisp-mode-map)
#+end_src

*** Enable minibuffer completion

It can be difficult to remember the full names of Emacs commands, so I use =icomplete-mode= for minibuffer completion. This also makes it easier to discover commands.

#+begin_src emacs-lisp :tangle no
(icomplete-mode 1)
#+end_src

#+RESULTS:
: t

* Skeleton

** Latex

- Recall to =eval-and-replace= =(latex-skeleton)= with =C-c e=. 
- Nota que por alguna razon hace falta las dos declaraciones de Spanish.
- Nota que ="#+LATEX_HEADER: \\immediate\\write18{sh ./vc}\n"= is gone because now I compile =vc= in the makefile.

#+BEGIN_SRC emacs-lisp :tangle yes
(define-skeleton article-skeleton
  "Inserts a Latex article skeleton into current buffer.
This only makes sense for empty buffers."
  "\n"
  "# -*- coding: utf-8 -*-\n"
  "# -*- find-file-hook: org-babel-execute-buffer -*-\n"
  "#+TITLE:\n"
  "#+SUBTITLE:\n" 
  "#+AUTHOR:\n" 
  "#+DATE:\n" 
  "#+OPTIONS: toc:4\n" 
  "#+OPTIONS: H:2 num:nil toc:nil \\n:nil @:t ::t |:t ^:{} _:{} *:t TeX:t LaTeX:t\n"
  "#+PROPERTY: header-args :tangle yes\n"
  "#+LATEX_HEADER: \\usepackage{org-preamble-pdflatex}\n"
  "#+LATEX_HEADER: \\usepackage{graphicx}\n"
  "#+LATEX_HEADER: \\usepackage{longtable}\n"
  "#+LATEX_HEADER: \\usepackage{float}\n"
  "#+LATEX_HEADER: \\usepackage{url}\n"
  "#+LANGUAGE: "str | "spanish""\n"
  "#+LATEX_HEADER: \\usepackage["str | "spanish""]{babel}\n"
  "#+LATEX_HEADER: \\usepackage{sectsty}\n"
  "#+LATEX_HEADER: \\sectionfont{\\normalfont\\scshape}\n"
  "#+LATEX_HEADER: \\subsectionfont{\\normalfont\\bfseries}\n"
  "#+LATEX_HEADER: \\subsubsectionfont{\\normalfont\\itshape}\n"
  "#+LATEX_HEADER: \\pdfoptionpdfminorversion=6\n"
  "#+LATEX_HEADER: \\usepackage{prelim2e}\n"
  "#+LATEX_HEADER: \\immediate\\write18{sh ./vc}\n"
  "#+LATEX_HEADER: \\input{vc}\n"
  "#+LATEX_HEADER: \\renewcommand*{\\PrelimText}{\\textnormal{\\small\\textcolor{black!40}{author: \\VCAuthor\\ -- date: \\VCDateISO\\ -- time: \\VCTime\\ -- commit: \\texttt{\\VCRevision}}}}\n\n"
  "" _ "\n\n"
  "\\printbibliography")
#+END_SRC

#+RESULTS:
: latex-skeleton

** Beamer

#+BEGIN_SRC emacs-lisp :tangle yes
(define-skeleton beamer-skeleton
  "Inserts a Latex beamer skeleton into current buffer.
This only makes sense for empty buffers."
  "\n"
  "# -*- coding: utf-8 -*-\n"
  "# -*- find-file-hook: org-babel-execute-buffer -*-\n"
  "#+TITLE:Fake title\n"
  "#+BEAMER_HEADER: \\title[Short Title]{Long Title}\n"
  "#+BEAMER_HEADER: \\author[\\textcolor{lightgray}{DGM \\& Mora}]{Daniel Guinea-Martin\\inst{1} and Ricardo Mora\\inst{2}\n"
  "#+BEAMER_HEADER: \\institute[]{\\inst{1} Dept.Sociology I, UNED  \\and \\inst{2} Dept. Economics, UC3M}\n"
  "#+DATE:\n"
  "#+LaTeX_CLASS: beamer\n"
  "#+LaTeX_CLASS_OPTIONS: [xcolor={svgnames,x11names},compress]\n"
  "#+LATEX_HEADER: \\usepackage{sanchez-dgm}\n"
  "#+BEAMER_THEME:\n"
  "#+BEAMER_FONT_THEME: professionalfonts\n"
  "#+OPTIONS: H:2 num:t\n"
  "\n\n"
  "" _ "")
#+END_SRC

#+RESULTS:
: beamer-skeleton

* Pragmatic Emacs
** dired-narrow

Narrow dired to match filter.  From: http://pragmaticemacs.com/emacs/dynamically-filter-directory-listing-with-dired-narrow/

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dired-narrow
  :ensure t
  :bind (:map dired-mode-map
              ("/" . dired-narrow)))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23623 36409 259307 947000) :init (23623 36409 259186 945000) :init-secs (0 0 37 660000) :use-package-secs (0 0 224 478000)))

* Input method

I'd rather have Spanish prefix as the default. Tips from: https://emacs.stackexchange.com/questions/418/setting-and-activating-the-default-input-method

#+BEGIN_SRC emacs-lisp :tangle no
(set-input-method 'spanish-prefix) 
(setq default-input-method "spanish-prefix")

(defvar use-default-input-method t)
(make-variable-buffer-local 'use-default-input-method)
(defun activate-default-input-method ()
  (interactive)
  (if use-default-input-method
      (activate-input-method default-input-method)
    (inactivate-input-method)))
(add-hook 'after-change-major-mode-hook 'activate-default-input-method)
;; (add-hook 'minibuffer-setup-hook 'activate-default-input-method)
(add-hook 'org-mode-hook 'activate-default-input-method)
(add-hook 'org-load-hook 'activate-default-input-method)
(add-hook 'LaTeX-mode-hook 'activate-default-input-method)
(add-hook 'latex-mode-hook 'activate-default-input-method)
(add-hook 'mu4e-compose-mode-hook 'activate-default-input-method)
                                        ;(defun inactivate-default-input-method ()
                                        ;  (setq use-default-input-method nil))
                                        ;(add-hook 'c-mode-hook 'inactivate-default-input-method)
#+END_SRC

The variable =use-default-input-method= and the function =inactivate-default-input-method= provide a way to turn off the input method (it may be annoying e.g. in programming modes). If you want to turn off the default method in some modes, you register the function =inactivate-default-input-method= in that mode's startup hook, as in the example above for C mode and derived modes (C++, Java, etc.).

The code above systematically turns on the default input method in the minibuffer (comment out that line to have it off by default). Smarter code might use the same input method or lack thereof as the buffer that was previously active, or might choose an input method depending on what the minibuffer is prompted for (e.g. used for search strings but not for file names), but I declare this beyond the scope of this answer.

If you prefer to whitelist modes where the input method is automatically activated, add the function =activate-default-input-method= below to these modes' startup hook, as in the example below for Text mode and derived modes.

#+BEGIN_EXAMPLE
(defun activate-default-input-method ()
  (interactive)
  (activate-input-method default-input-method))
(add-hook 'text-mode-hook 'activate-default-input-method)
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle no
(set-input-method "spanish-prefix")
                                        ;(set-input-method 'spanish-prefix) 
(setq default-input-method "spanish-prefix")
                                        ;(setq-default default-input-method 'spanish-prefix)

(defun activate-default-input-method ()
  (interactive)
  (activate-input-method default-input-method))
(add-hook 'org-mode-hook 'activate-default-input-method)
(add-hook 'org-load-hook 'activate-default-input-method)
(add-hook 'LaTeX-mode-hook 'activate-default-input-method)
(add-hook 'latex-mode-hook 'activate-default-input-method)
(add-hook 'mu4e-compose-mode-hook 'activate-default-input-method)
(add-hook 'mu4e-compose-pre-hook 'activate-default-input-method) 
(add-hook 'mu4e-compose-parent-message 'activate-default-input-method) 

                                        ; (add-hook 'mu4e-mode-hook #'activate-default-input-method)

(defun inactivate-default-input-method ()
  (setq use-default-input-method nil))
(add-hook 'c-mode-hook 'inactivate-default-input-method)
(add-hook 'fundamental-mode 'inactivate-default-input-method)
#+END_SRC

#+RESULTS:
| inactivate-default-input-method |

** Input method shortcut

=defun= defined in Marcel van der Boom's configuration files.
After I change to Spanish with =s-z=, I toggle the input method with =C-\=

DGM on march, 3rd: I've made spanish-prefix the default so this is not needed
March 6: well, it's not working exactly. It works after I set up the new input method. But before it does not. So I need my shortcut back
But now that I've changed some lines in the bit on input method in =dgm.org= this =mrb= stuff does not work at all...

#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrb/set-input-method()
  (interactive)
  (setq default-input-method "spanish-prefix")
  ;; Toggle only if it not active yet
  (if (not current-input-method)
      (toggle-input-method)))

;;(exwm-input-set-key (kbd "s-x") #'exwm-input-toggle-keyboard)
(exwm-input-set-key (kbd "s-s") #'mrb/set-input-method)
#+END_SRC

#+RESULTS:

* undo-propose

To use undo-propose, call "M-x undo-propose" in the buffer you are editing.
This will send you to a new temporary buffer, which is read-only except
for allowing `undo' commands.  Cycle through the list of undo's as normal.
When you are finished, type "C-c C-c" to add the chain of undo's as a
single edit to the undo history.  To cancel, type "C-c C-k".  You can also
ediff the proposed chain of undo's by typing "C-c C-d".

Read: 

- https://www.reddit.com/r/emacs/comments/awj96h/undopropose_published_in_melpa/
- https://github.com/jackkamm/undo-propose-el
- https://www.reddit.com/r/emacs/comments/atykf9/undopropose_simple_and_safe_undo_in_emacs/

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-propose)
#+END_SRC

* Reverse paragraphs

Very useful for, for example, changing the order of the Makefile from bottom up to up-bottom.

See https://www.emacswiki.org/emacs/ReverseParagraphs

Got: 

#+BEGIN_EXAMPLE
- foo is bar
  and bar is expensive.

- foo is quux
  and quux is useful.
#+END_EXAMPLE

Result:

#+BEGIN_EXAMPLE
- foo is quux
  and quux is useful.

- foo is bar
  and bar is expensive.
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :tangle yes
(defun reverse-paragraphs (beg end)
  "Reverse the order of paragraphs in a region.
From a program takes two point or marker arguments, BEG and END."
  (interactive "r")
  (when (> beg end)
    (let (mid) (setq mid end end beg beg mid)))
  (save-excursion
    ;; the last paragraph might be missing a trailing newline
    (goto-char end)
    (setq end (point-marker))
    ;; the real work.
    (goto-char beg)
    (let (paragraphs fix-newline)
      (while (< beg end)
	    ;; skip to the beginning of the next paragraph instead of
	    ;; remaining on the position separating the two paragraphs
	    (when (= 0 (forward-paragraph 1))
	      (goto-char (1+ (match-end 0))))
	    (when (> (point) end)
	      (goto-char end))
	    (setq paragraphs (cons (buffer-substring beg (point))
			                   paragraphs))
	    (delete-region beg (point)))
      ;; if all but the last paragraph end with two newlines, add a
      ;; newline to the last paragraph
      (when (and (null (delete 2 (mapcar (lambda (s)
					                       (when (string-match "\n+$" s -2)
					                         (length (match-string 0 s))))
					                     (cdr paragraphs))))
		         (when (string-match "\n+$" (car paragraphs) -2)
		           (= 1 (length (match-string 0 (car paragraphs))))))
	    (setq fix-newline t)
	    (setcar paragraphs (concat (car paragraphs) "\n")))
      ;; insert paragraphs
      (dolist (par paragraphs)
	    (insert par))
      (when fix-newline
	    (delete-char -1)))))
#+END_SRC

#+RESULTS:
: reverse-paragraphs

* Try 

Recommended by the great Mike Zamansky at https://www.youtube.com/watch?v=49kBWM3RQQ8&list=PL1J8_tSSqnK4yrmlxd1ArVpP5ZgnPIeKZ&index=13&t=0s

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package try
  :ensure t)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23710 38257 96833 110000) :init (23710 38257 96735 587000) :config (23710 38257 94764 845000) :config-secs (0 0 42 340000) :init-secs (0 0 9704 337000) :use-package-secs (0 10 384370 599000)))

* =grep= all opened buffers

Fromm https://stackoverflow.com/questions/2641211/emacs-interactively-search-open-buffers

#+BEGIN_SRC emacs-lisp :tangle yes
;; I know that string is in my Emacs somewhere!
(require 'cl)
(defcustom search-all-buffers-ignored-files (list (rx-to-string '(and bos (or ".bash_history" "TAGS") eos)))
  "Files to ignore when searching buffers via \\[search-all-buffers]."
  :type 'editable-list)

(require 'grep)
(defun search-all-buffers (regexp prefix)
  "Searches file-visiting buffers for occurence of REGEXP.  With
prefix > 1 (i.e., if you type C-u \\[search-all-buffers]),
searches all buffers."
  (interactive (list (grep-read-regexp)
                     current-prefix-arg))
  (message "Regexp is %s; prefix is %s" regexp prefix)
  (multi-occur
   (if (member prefix '(4 (4)))
       (buffer-list)
     (remove-if
      (lambda (b) (some (lambda (rx) (string-match rx  (file-name-nondirectory (buffer-file-name b)))) search-all-buffers-ignored-files))
      (remove-if-not 'buffer-file-name (buffer-list))))

   regexp))

;; (global-set-key [f7] 'search-all-buffers)
#+END_SRC

#+RESULTS:
: search-all-buffers
 
* Create column of alphabet's digits

- From http://ergoemacs.org/emacs/emacs_insert-alphabets.html

#+BEGIN_SRC emacs-lisp :tangle yes
(defun xah-insert-column-az ()
  "Insert letters A to Z vertically, similar to `rectangle-number-lines'.
The commpand will prompt for a start char, and number of chars to insert.
The start char can be any char in Unicode.
URL `http://ergoemacs.org/emacs/emacs_insert-alphabets.html'
Version 2019-03-07"
  (interactive)
  (let (
        ($startChar (string-to-char (read-string "Start char: " "a")))
        ($howmany (string-to-number (read-string "How many: " "26")))
        ($colpos (- (point) (line-beginning-position))))
    (dotimes ($i $howmany )
      (progn
        (insert-char (+ $i $startChar))
        (forward-line)
        (beginning-of-line)
        (forward-char $colpos)))))
#+END_SRC

#+RESULTS:
: xah-insert-column-az

Usage: 
- Select column where you want to place the letters. 
- Do =C-u= (the universal argument) 
- and then =C-x r N= (for inserting list of numbers). 
- Type =65= (unicode codepoint of letter =A=. =a= is =97=). 
- Remove the default =%2d=, type =%c=.  (the =%c= is for character format).

* COMMENT Better line numbers
Joe di Castro says: Display a more appealing line numbers. I don't use them too much because is a very slow feature, but sometimes it comes handy.

DGM: not sure it is better.
#+BEGIN_SRC emacs-lisp :tangle no
                                        ; 2014-04-04: Holy moly its effort to get line numbers like vim!
                                        ; http://www.emacswiki.org/emacs/LineNumbers#toc6
(unless window-system
  (add-hook 'linum-before-numbering-hook
            (lambda ()
              (setq-local linum-format-fmt
                          (let ((w (length (number-to-string
                                            (count-lines (point-min) (point-max))))))
                            (concat "%" (number-to-string w) "d"))))))

(defun joe-linum-format-func (line)
  (concat
   (propertize (format linum-format-fmt line) 'face 'linum)
   (propertize " " 'face 'linum)))

(unless window-system
  (setq linum-format 'joe-linum-format-func))
#+END_SRC

#+RESULTS:

* Twitter


#+BEGIN_SRC emacs-lisp :tangle yes
(use-package twittering-mode)
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23876 24572 365881 952000) :init (23876 24572 365873 813000) :config (23876 24572 365671 940000) :config-secs (0 0 5 73000) :init-secs (0 0 20833 634000) :use-package-secs (0 0 20886 646000)))

* Browser switching

#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "s-;") 'ivy-switch-buffer)

(global-set-key (kbd "s-*") 'electric-buffer-list)
                                        ; This hook run after buffer formatted, so it is necessary to re-fontify it...
(add-hook 'electric-buffer-menu-mode-hook
	      '(lambda ()
	         (font-lock-mode 1)
	         (font-lock-fontify-buffer)))

(setq ido-default-buffer-method 'selected-window)
(unless ido-mode
  (ido-mode 1))
(global-set-key (kbd "s-l") 'ido-switch-buffer)
(global-set-key (kbd "C-c b") 'ido-switch-buffer)
#+END_SRC

#+RESULTS:
: ido-switch-buffer

* =helm-resume=

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "s-r") #'helm-resume)
#+end_src

#+RESULTS:
: helm-resume

* Cheatsheet

See https://github.com/darksmile/cheatsheet/blob/master/cheatsheet.el

Run =cheatsheet-show= and enjoy looking at your own Emacs cheatsheet.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package cheatsheet
  :ensure t
  :config
  (cheatsheet-add :group 'Bindings
                  :key "describe-personal-keybinding"
                  :description "Personal bindings")
  (cheatsheet-add :group 'Bindings
                  :key "C-h m"
                  :description "Bindings for all modes active in buffer")
  (cheatsheet-add :group 'Bindings-Free
                  :key "s-:"
                  :description "")
  (cheatsheet-add :group 'Bookmarks
                  :key "C-x r m"
                  :description "Create bookmark")
  (cheatsheet-add :group 'Bookmarks
                  :key "C-x r l"
                  :description "List bookmark")
  (cheatsheet-add :group 'Bookmarks
                  :key "C-u a"
                  :description "Annotate bookmark where point is")
  (cheatsheet-add :group 'Bookmarks
                  :key "a"
                  :description "Read note on bookmark where point is")
  (cheatsheet-add :group 'Buffer-Cycling
                  :key "s-<tab>"
                  :description "ambrevar/switch-to-last-buffer")
  (cheatsheet-add :group 'Buffer-Cycling
                  :key "C-x b"
                  :description "helm-mini. Cycles EXWM buffers")
  (cheatsheet-add :group 'Buffer-Cycling
                  :key "s-l"
                  :description "ido-switch-buffer: C-c b when in an external app")
  (cheatsheet-add :group 'Buffer-Cycling
                  :key "s-n"
                  :description "helm-projectile-switch-to-buffer. Includes current P's and EXWM buffers")
  (cheatsheet-add :group 'Buffer-Cycling
                  :key "C-c y"
                  :description "bury-buffer")
  (cheatsheet-add :group 'Buffer-Cycling
                  :key "s-;"
                  :description "ivy-switch-buffer. Like iBuffer: list of buffers for editing")
  (cheatsheet-add :group 'Buffer-List
                  :key "s-*"
                  :description "electric-buffer-list")
  (cheatsheet-add :group 'Buffer-List
                  :key "C-x C-b"
                  :description "iBuffer. List of buffers for editing")
  (cheatsheet-add :group 'Buffer-Closing
                  :key "C-M-s-k"
                  :description "Close-all-buffers. s is the super key")
  (cheatsheet-add :group 'Browsing
                  :key "&"
                  :description "Open eww url in Chromium")
  (cheatsheet-add :group 'Browsing
                  :key "C-c h g"
                  :description "helm-google-suggest gives Google results in Helm buffer. Type slow")
  (cheatsheet-add :group 'Browsing
                  :key "s-b"
                  :description "helm-surfraw")
  (cheatsheet-add :group 'Browsing
                  :key "C-\{"
                  :description "daedreth/launch-browser")
  (cheatsheet-add :group 'Browsing
                  :key "R"
                  :description "eww-readable. Find text, leaving out navigation menus and the like.")
  (cheatsheet-add :group 'Browsing
                  :key "s-}"
                  :description "Web browsing with engine-mode: Google maps and Wolfram included")
  (cheatsheet-add :group 'Browsing
                  :key "M-x sos"
                  :description "StackOverflow only")
  (cheatsheet-add :group 'Browsing
                  :key "M-x my-helm-stackoverflow-lookup"
                  :description "Alternative for StackOverflow only")
  (cheatsheet-add :group 'Chromium
                  :key "C-l"
                  :description "Mark url")
  (cheatsheet-add :group 'Common
                  :key "C-x C-c"
                  :description "save-buffers-kill-emacs")
  (cheatsheet-add :group 'Debugging
                  :key "M-x gdb"
                  :description "IDE-like interface, with specialized buffers for controlling breakpoints, stack frames, and other aspects of the debugger state.")
  (cheatsheet-add :group 'Diary
                  :key "i"
                  :description "org-agenda-diary-entry. Works from Org-agenda and calendar")
  (cheatsheet-add :group 'Diary
                  :key "C-c C-q"
                  :description "quit-window")
  (cheatsheet-add :group 'Diary
                  :key "C-c C-s"
                  :description "diary-show-all-entries")
  (cheatsheet-add :group 'Dired
                  :key "C-x d"
                  :description "helm-mode-dired. TAB to select; RET to jump to selection")
  (cheatsheet-add :group 'Dired
                  :key "/"
                  :description "Dired narrow to match filter")
  (cheatsheet-add :group 'Dired
                  :key "C-l"
                  :description "Delete directory in path")
  (cheatsheet-add :group 'Dired
                  :key "C-k"
                  :description "Delete path to write a new path")
  (cheatsheet-add :group 'Dired-Projectile
                  :key "C-d"
                  :description "Open dired when in P session")
  (cheatsheet-add :group 'Dired
                  :key "$"
                  :description "dired-hide-subdir. Hide or unhide the current subdirectory and move to next directory")
  (cheatsheet-add :group 'Dired
                  :key "&"
                  :description "dired-do-async-shell-command. Run a shell command COMMAND on the marked files asynchronously")
  (cheatsheet-add :group 'Dired-Projectile
                  :key "M-C"
                  :description "Copy marked files in P session to another opened Dired dir")
  (cheatsheet-add :group 'Dired-Projectile
                  :key "M-R"
                  :description "Move files in P session to another opened Dired dir")
  (cheatsheet-add :group 'Dired-Projectile
                  :key "C-c f"
                  :description "Create Virtual Dired buffer with files marked in helm-projectile-find-files: s-u")
  (cheatsheet-add :group 'Dired-Projectile
                  :key "C-c a"
                  :description "Add files marked to Virtual Dired buffer in helm-projectile-find-files: s-u")
  (cheatsheet-add :group 'Dired-Projectile
                  :key "C-c d"
                  :description "Remove entries from Virtual Dired buffer from helm-projectile-find-files session: s-u")
  (cheatsheet-add :group 'Editing
                  :key "C-x l"
                  :description "count-lines-page")
(cheatsheet-add :group 'Editing
                  :key "C-x 8-"
                  :description "Prefix to insert symbols")
  (cheatsheet-add :group 'Editing
                  :key "M--c"
                  :description "Upper case last word: Mientras haces M-- dale a la c")
  (cheatsheet-add :group 'Editing
                  :key "s-@"
                  :description "open-line and prelude-smart-open-line. Insert an empty line after the current line.")
  (cheatsheet-add :group 'Editing
                  :key "C-x C-q"
                  :description "read-only-mode")
  (cheatsheet-add :group 'Editing
                  :key "s-v"
                  :description "See raw contents that usually are invisible-like hyperlinks")
  (cheatsheet-add :group 'Editing
                  :key "M-SPC"
                  :description "just-one-space: Delete all spaces and tabs around point, leaving one space-or N spaces")
  (cheatsheet-add :group 'Editing
                  :key "M-D"
                  :description "Duplicate line or region")
  (cheatsheet-add :group 'Editing
                  :key "comment-box"
                  :description "Puts region inside a box")
  (cheatsheet-add :group 'Editing
                  :key "C-c ;"
                  :description "Comment and uncomment region")
  (cheatsheet-add :group 'Editing
                  :key "s-k"
                  :description "Kills the entire word your cursor is in")
  (cheatsheet-add :group 'Editing
                  :key "M-z"
                  :description "zap-up-to-char")
  (cheatsheet-add :group 'Editing
                  :key "gs-w"
                  :description "Copy whole word")
  (cheatsheet-add :group 'Editing
                  :key "s-@"
                  :description "Copies a line where your cursor is in")
  (cheatsheet-add :group 'Editing
                  :key "s-%"
                  :description "Kills whole line where your cursor is in")
  (cheatsheet-add :group 'Editing
                  :key "yank-file-name"
                  :description "Yanks current buffer file name and its path to the kill ring")
  (cheatsheet-add :group 'Editing
                  :key "C-`"
                  :description "ido-find-file-in-tag-files")
  (cheatsheet-add :group 'Editing
                  :key "M-x reverse-paragraphs"
                  :description "Reverse the order of paragraphs in a region")
  (cheatsheet-add :group 'Editing
                  :key "M-x xah-insert-column-az"
                  :description "Inserts numbers or letters in column. Read dgm.org")
  (cheatsheet-add :group 'Editing
                  :key "C-x a"
                  :description "Join this line to previous and fix up whitespace at join")
  (cheatsheet-add :group 'Editing
                  :key "s-\\"
                  :description "align-regexp")
  (cheatsheet-add :group 'Editing
                  :key "s-/"
                  :description "indent-region")
  (cheatsheet-add :group 'Editing
                  :key "s->"
                  :description "indent-region-or-buffer")
  (cheatsheet-add :group 'Editing
                  :key "M-/"
                  :description "hippie-expand")
  (cheatsheet-add :group 'Editing
                  :key "s-c"
                  :description "helm-colors")
  (cheatsheet-add :group 'Editing
                  :key "s-!"
                  :description "toggle-theme")
  (cheatsheet-add :group 'Editing
                  :key "s-y"
                  :description "ivy-yasnippet")
  (cheatsheet-add :group 'Editing
                  :key "C-c k"
                  :description "yas-expand. Expand a snippet before point.")
  (cheatsheet-add :group 'Editing
                  :key "s-#"
                  :description "sudo-edit")
  (cheatsheet-add :group 'Editing
                  :key "C-x C-i"
                  :description "indent-rigidly. Indent all lines starting in the region. Then <right>/<left> or <S-right>/<S-left> to actually indent")
  (cheatsheet-add :group 'Editing-Killing
                  :key "M-w"
                  :description "kill-ring-save: Save the region as if killed, but don’t kill it. When no active region, copy a single line instead")
  (cheatsheet-add :group 'Editing-Killing
                  :key "C-w"
                  :description "kill-region: Kill text between point and mark. When no active region, kill single line instead")
  (cheatsheet-add :group 'Editing-Killing
                  :key "C-k"
                  :description "kill-line and kill-visual-line. kill a line, including whitespace characters until next non-whitespace character of next line")
  (cheatsheet-add :group 'Editing-MultipleRegions
                  :key "s-q"
                  :description "mark-next-like-this. Mark next occurence of a region and edit all at once")
  (cheatsheet-add :group 'Editing-MultipleRegions
                  :key "C-;"
                  :description "iedit: Edit multiple regions in the same way simultaneously")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m l"
                  :description "mc/edit-lines: When active region spans multiple lines, add cursor to each line")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m a"
                  :description "mc/edit-beginnings-of-lines")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m e"
                  :description "mc/edit-ends-of-lines")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m E"
                  :description "mc/mark-more-like-this-extended")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m N"
                  :description "mc/mark-next-like-this. MC not based on continuous lines, but on keywords")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m P"
                  :description "mc/mark-previous-like-this. MC not based on continuous lines, but on keywords")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m u"
                  :description "mc/unmark-next-like-this. MC not based on continuous lines, but on keywords")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m U"
                  :description "mc/unmark-previous-like-this. MC not based on continuous lines, but on keywords")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m A"
                  :description "mc/mark-all-like-this: Works on same line. Mark region 1st. MC based on keywords")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m z"
                  :description "mc/insert-numbers")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m r"
                  :description "mc/mark-all-in-region")
  (cheatsheet-add :group 'Editing-MultipleCursors
                  :key "C-c C-m h"
                  :description "mc-hide-unmatched-lines-mode")
  (cheatsheet-add :group 'Emacs
                  :key "C-<digit>"
                  :description "digit-argument. No need to do C-u <digit>. Could do M-<digit> too.")
  (cheatsheet-add :group 'Email
                  :key "C-*"
                  :description "mu4e")
  (cheatsheet-add :group 'Email
                  :key "C-c C-k"
                  :description "mu4e-message-kill-buffer")
  (cheatsheet-add :group 'Email
                  :key "a"
                  :description "Lists possible actions when inside message like Show In Browser or Show Thread")
  (cheatsheet-add :group 'Email
                  :key "e"
                  :description "mu4e-view-save-attachmen. Offer to save multiple email attachments from the current message.")
  (cheatsheet-add :group 'Email
                  :key "A"
                  :description "mu4e-view-attachment-action")
  (cheatsheet-add :group 'Email
                  :key "g"
                  :description "mu4e-view-go-to-url. Open URL")
  (cheatsheet-add :group 'Email
                  :key "S"
                  :description "helm-mu. Defined in mu4e-main-mode-map")
  (cheatsheet-add :group 'Email
                  :key "C-i"
                  :description "helm-execute-persistent-action. In helm-mu, execute action, open email at point in another window and move point there, without quitting helm")
  (cheatsheet-add :group 'Email
                  :key "M-x helm-mu-contacts"
                  :description "Greps contacts so regexp allowed. M-SPC to select multiple sources. Available actions with C-z are insert selected contacts at point and copy selected contacts to clipboard.")
  (cheatsheet-add :group 'Expressions-Eval
                  :key "C-x C-e"
                  :description "sanityinc/eval-last-sexp-or-region")
  (cheatsheet-add :group 'Expressions-Copying
                  :key "C-M w"
                  :description "sp-copy-sexp: Copies next bit of the sexp")
  (cheatsheet-add :group 'Expressions-Copying
                  :key "M-x my/org-insert-defun"
                  :description "Inserts an Org source block with the definition for FUNCTION")
  (cheatsheet-add :group 'Expressions-Find
                  :key "C-c f"
                  :description "find-function")
  (cheatsheet-add :group 'Expressions-Find
                  :key "C-c ."
                  :description "find-function-at-point")
  (cheatsheet-add :group 'Expressions-Find
                  :key "M-."
                  :description "xref-find-definitions. See function in source file; jump to nodes in Texinfo, if etags has recorded the nodes")
  (cheatsheet-add :group 'Expressions-Find
                  :key "M-,"
                  :description "Go back from xref-find-definitions")
  (cheatsheet-add :group 'Expressions-Killing
                  :key "C-M k"
                  :description "sp-kill-sexp: Kills next bit of the sexp")
  (cheatsheet-add :group 'Expressions-Killing
                  :key "C-k"
                  :description "sp-kill-hybrid-sexp: Kills sexp from point onwards")
  (cheatsheet-add :group 'Expressions-Killing
                  :key "M-k"
                  :description "sp-backward-kill-sexp: Kills previous bit of sexp")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M a"
                  :description "Begin of function")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M e"
                  :description "End of function")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M f"
                  :description "sp-forward-sexp: Block movement")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M b"
                  :description "sp-backward-sexp: Block movement")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M n"
                  :description "sp-next-sexp: Top-level-ish transversal")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M p"
                  :description "sp-previous-sexp: Top-level-ish transversal")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M-+"
                  :description "smartscan-symbol-go-forward. Set in elpa/smartscan.el")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M-*"
                  :description "smartscan-symbol-go-backward. Set in elpa/smartscan.el")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "M-'"
                  :description "smartscan-symbol-replace. Set in smartscan.el")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-<down>"
                  :description "sp-down-exp: Traversing lists")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-<up>"
                  :description "sp-up-exp: Traversing lists")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "M-<down>"
                  :description "sp-backward-down-sexp: Traversing lists")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "M-<up>"
                  :description "sp-backward-up-sexp: Traversing lists")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M a"
                  :description "Begin of function")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M e"
                  :description "End of function")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M f"
                  :description "sp-forward-sexp: Block movement")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M b"
                  :description "sp-backward-sexp: Block movement")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-M n"
                  :description "sp-next-sexp: Top-level-ish transversal")
  (cheatsheet-add :group 'Expressions-Movement
                  :key "C-S b"
                  :description "sp-backward-symbol: Free-form movement")
  (cheatsheet-add :group 'Expressions-Movements
                  :key "C-S f"
                  :description "sp-forward-symbol: Free-form movement")
  (cheatsheet-add :group 'Expressions-Marking
                  :key "C-M SPC"
                  :description "mark-sexp function of lisp.el")
  (cheatsheet-add :group 'Expressions-Org
                  :key "s-~"
                  :description "Wrap region with matching tilde in Org")
  (cheatsheet-add :group 'Expressions-Org
                  :key "s-="
                  :description "Wrap region with matching equality in Org")
  (cheatsheet-add :group 'Expressions-Wrapping
                  :key "C-M SPC and Wrapping symbol"
                  :description "Wrap region with matching characters-parentheses, brackets, etc-depending on mode")
  (cheatsheet-add :group 'Expressions-Wrapping
                  :key "C-c and Parenthesis"
                  :description "Wrap word with matching characters-parentheses, brackets, etc")
  (cheatsheet-add :group 'Expressions-Wrapping-Slurp
                  :key "C-<right>"
                  :description "sp-forward-slurp-sexp: Slurping extends the inclusion of parentheses")
  (cheatsheet-add :group 'Expressions-Wrapping-Slurp
                  :key "C-<left>"
                  :description "sp-backward-slurp-sexp: Slurping extends the inclusion of parentheses")
  (cheatsheet-add :group 'Expressions-Wrapping-Barf
                  :key "M-<right>"
                  :description "sp-forward-barf-sexp: Burfing contracts the extension of parentheses")
  (cheatsheet-add :group 'Expressions-Wrapping-Barf
                  :key "M-<left>"
                  :description "sp-backward-barf-sexp: Barfing contracts the extension of parentheses")
  (cheatsheet-add :group 'Expressions-Unwrapping
                  :key "M-\["
                  :description "sp-backward-unwrap-sex: Unwraps current exp")
  (cheatsheet-add :group 'Expressions-Unwrapping
                  :key "M-\]"
                  :description "sp-unwrap-sex: Unwrapps next exp")
  (cheatsheet-add :group 'Expressions-Swapping
                  :key "C-M t"
                  :description "sp-transpose-sexp")
  (cheatsheet-add :group 'EXWM
                  :key "s-e"
                  :description "helm-run-external-command")
  (cheatsheet-add :group 'EXWM
                  :key "s-r"
                  :description "exwm-reset: Reset the state of the selected window: non-fullscreen, line-mode, etc")
  (cheatsheet-add :group 'EXWM
                  :key "C-q"
                  :description "exwm-input-send-next-key: the next key is sent literally to the application")
  (cheatsheet-add :group 'EXWM
                  :key "s-&"
                  :description "ambrevar/exwm-start: Open in external application")
  (cheatsheet-add :group 'EXWM
                  :key "C-c-t-f"
                  :description "Resize frame from external app-Usually when saving something")
  (cheatsheet-add :group 'Find-char
                  :key "C-o"
                  :description "avy-goto-word-1: Jump to char at word start")
  (cheatsheet-add :group 'Find-char
                  :key "s-z"
                  :description "avy-goto-char: Jump to any char in window")
  (cheatsheet-add :group 'Find-Files
                  :key "C-x f"
                  :description "ido-recentf-open: Find recent file")
  (cheatsheet-add :group 'Find-Files
                  :key "C-x C-r"
                  :description "recentf-open-files. Long list of recent files")
  (cheatsheet-add :group 'Find-Files
                  :key "C-x C-f"
                  :description "helm-find-files")
  (cheatsheet-add :group 'Find-Files
                  :key "M-x helm-for-filess"
                  :description "Find in opened, recent, bookmarked files; files in current dir; files anywhere with locate")
  (cheatsheet-add :group 'Find-Files
                  :key "C-x C-g"
                  :description "deft-find-file")
  (cheatsheet-add :group 'Find-Files
                  :key "C-c d"
                  :description "deft. Switch to Deft buffer and load files.")
  (cheatsheet-add :group 'Find-Files
                  :key "C-c C-c"
                  :description "deft-filter-clear")
  (cheatsheet-add :group 'Find-Files
                  :key "C-c C-q"
                  :description "quit-window. Works in Deft")
  (cheatsheet-add :group 'Find-Files
                  :key "C-c d"
                  :description "deft. Switch to Deft buffer and load files.")
  (cheatsheet-add :group 'Find-Files
                  :key "C-c C-q"
                  :description "quit-window. Works with deft")
  (cheatsheet-add :group 'Find-Files
                  :key "s-d"
                  :description "helm-find frontend for *nix FIND command in current dir; C-u chooses dir")
  (cheatsheet-add :group 'Find-Files
                  :key "s-D"
                  :description "helm-locate frontend of *unix LOCATE command")
  (cheatsheet-add :group 'Find-Dirs-Projectile
                  :key "s-+"
                  :description "helm-projectile-find-dir: Find dirs in current P project")
  (cheatsheet-add :group 'Find-Files-Projectile
                  :key "C-c p a"
                  :description "List files with same name, different extensions in current P project")
  (cheatsheet-add :group 'Find-Files-Projectile
                  :key "s-|"
                  :description "helm-projectile-find-file-dwim: Find file in P project based on context at point")
  (cheatsheet-add :group 'Find-Files-Projectile
                  :key "C-c p e"
                  :description "List recently visited files in current P project")
  (cheatsheet-add :group 'Find-Files-Projectile
                  :key "s-\`"
                  :description "helm-projectile-find-other-file: Same name, different extension")
  (cheatsheet-add :group 'Find-Occurrences
                  :key "s-o"
                  :description "helm-occur: TAB to temporarily move to highlighted match")
  (cheatsheet-add :group 'Find-Occurrences
                  :key "s-i"
                  :description "swiper")
  (cheatsheet-add :group 'Find-Occurences
                  :key "s-\'"
                  :description "helm-regexp to test regexp interactively and save it. Actions on C-z")
  (cheatsheet-add :group 'Find-Ocurrences
                  :key "M-x helm-swoop"
                  :description "Show lines matching a pattern; cursor jumps to the line we go to")
  (cheatsheet-add :group 'Find-Org
                  :key "s-p"
                  :description "helm-org-in-buffer-headings: Find Org heading")
  (cheatsheet-add :group 'Find-Org
                  :key "s-u"
                  :description "Rifle search in Org files")
  (cheatsheet-add :group 'Grep
                  :key "search-all-buffers"
                  :description "Greps all opened buffers")
  (cheatsheet-add :group 'Grep
                  :key "s-f"
                  :description "helm-ag: grep-like program implemented in C")
  (cheatsheet-add :group 'Grep-Helm
                  :key "C-c h w"
                  :description "wgrep-helm: Edit a helm-grep-mode buffer and apply those changes to the file buffer")
  (cheatsheet-add :group 'Grep-Projectile
                  :key "s-g"
                  :description "helm-projectile-grep: Search symbol at point. If region active, searches region")
  (cheatsheet-add :group 'Grep-Projectile
                  :key "C-s"
                  :description "Grep in project when using P. C-u for recursive grep")
  (cheatsheet-add :group 'Helm
                  :key "C-c TAB"
                  :description "Yank selected candidate in Helm session at point")
(cheatsheet-add :group 'Helm
                  :key "M-SPC"
                  :description "Select multiple sources")
  (cheatsheet-add :group 'Helm
                  :key "s-r"
                  :description "helm-resume previous H session, inputs included. C-u lets choose Helm buffer. C-c n inside Helm session")
  (cheatsheet-add :group 'Helm
                  :key "C-c o"
                  :description "In H session, open selected candidate in another window")
  (cheatsheet-add :group 'Helm
                  :key "C-c h"
                  :description "Helm prefix / If in C-x C-f session, list visited files/dirs")
  (cheatsheet-add :group 'Helm
                  :key "C-c C-i"
                  :description "Insert selection: columns")
  (cheatsheet-add :group 'Helm
                  :key "C-w"
                  :description "Yank word at point into Helm prompt")
  (cheatsheet-add :group 'Helm
                  :key "M-n"
                  :description "Yank symbol at point into Helm prompt")
  (cheatsheet-add :group 'Helm-Bibtex
                  :key "C-c \]"
                  :description "helm-bibtex: search BibTeX files for refs to insert into the current document")
  (cheatsheet-add :group 'Helm-Menu
                  :key "C-c h w"
                  :description "helm-buffer-switch-other-window: Works on a helm menu like the one by C-x b")
  (cheatsheet-add :group 'Helm-Menu
                  :key "C-c h k"
                  :description "helm-buffer-run-kill-persistent: Works on a helm menu like the one by C-x b")
  (cheatsheet-add :group 'Help
                  :key "C-h p"
                  :description "Search the standard Emacs Lisp libraries by topic keywords")  
  (cheatsheet-add :group 'Help
                  :key "C-h i m"
                  :description "Search the info system and open the menu. Then type something, like 'org' and RET")  
  (cheatsheet-add :group 'Help
                  :key "C-h C-a"
                  :description "about-emacs: For information about GNU Emacs and the GNU system")  
  (cheatsheet-add :group 'Help
                  :key "C-h m"
                  :description "describe-mode")  
  (cheatsheet-add :group 'Help
                  :key "helm-descbinds"
                  :description "Currently active key bindings are searcheable")
  (cheatsheet-add :group 'Help
                  :key "C-c ?"
                  :description "Help in a Helm session")
  (cheatsheet-add :group 'Help
                  :key "s-m"
                  :description "helm-man-woman: Manual entries for *nix commands")
  (cheatsheet-add :group 'Help
                  :key "s-a"
                  :description "helm-apropos for commands, functions, variables and faces. Original in C-h d")
  (cheatsheet-add :group 'Help
                  :key "s-\)"
                  :description "Search emacs, elisp and CL info pages")
  (cheatsheet-add :group 'Help
                  :key "helm-info-*"
                  :description "Search info nodes for various topics like emacs, elisp, gdb, etc. TAB to view")
  (cheatsheet-add :group 'Help
                  :key "C-h f"
                  :description "helpful-callable: Show help for function, macro or special form named SYMBOL")
  (cheatsheet-add :group 'Help
                  :key "C-h k"
                  :description "helpful-key")
  (cheatsheet-add :group 'Help
                  :key "C-h v"
                  :description "helpful-variable")
  (cheatsheet-add :group 'Help-Org
                  :key "?"
                  :description "With cursor on heading's stars, ? opens window with shortcuts available")
  (cheatsheet-add :group 'History
                  :key "C-c C-l"
                  :description "History in Eshell, Shell and Minibuffer")
  (cheatsheet-add :group 'iMenu
                  :key "s-?"
                  :description "ido-goto-symbol. Refresh imenu and jump to a place in the buffer using Ido")
  (cheatsheet-add :group 'iMenu
                  :key "M-i"
                  :description "helm-semantic-or-imenu")
  (cheatsheet-add :group 'Input
                  :key "s-s"
                  :description "mrb/set-input-method: Change input method to Spanish prefix")
  (cheatsheet-add :group 'Input
                  :key "C-\\"
                  :description "toggle-input-method. Use one back slash")
  (cheatsheet-add :group 'Kill
                  :key "M-y"
                  :description "helm-show-kill-ring")
  (cheatsheet-add :group 'Kill-Projectile
                  :key "M-D"
                  :description "Kill marked item in P session")
  (cheatsheet-add :group 'Lisp
                  :key "C-c h TAB"
                  :description "helm-lisp-completion-at-point for elisp")
  (cheatsheet-add :group 'Lisp
                  :key "M-:"
                  :description "Evaluate EXPRESSION and pretty-print its value.")
  (cheatsheet-add :group 'Lisp
                  :key "s-\("
                  :description "helm-eval-expression-with-eldoc interactively evaluates elisp exp")
  (cheatsheet-add :group 'Lisp
                  :key "s-\)"
                  :description "ap/helm-info-emacs-elisp-cl: Emacs and eLisp manual with Helm")
  (cheatsheet-add :group 'Mark
                  :key "C-x C-x"
                  :description "cua-exchange-point-and-mark")
  (cheatsheet-add :group 'Mark
                  :key "C-x h"
                  :description "mark-whole-buffer")
  (cheatsheet-add :group 'Mark
                  :key "C-."
                  :description "Pushes point to mark-ring and does not activate the region")
  (cheatsheet-add :group 'Mark
                  :key "C-SPC"
                  :description "cua-set-mark: Set mark at where point is, clear mark, or jump to mark.")
  (cheatsheet-add :group 'Mark
                  :key "M-`"
                  :description "Jumps to the local mark, respecting the mark-ring order. C-u C-SPC does it too")
  (cheatsheet-add :group 'Mark
                  :key "s-RET"
                  :description "helm-all-mark-rings: Find mark in local and global rings")
  (cheatsheet-add :group 'Mark
                  :key "s-SPC"
                  :description "er/expand-region")
  (cheatsheet-add :group 'Mark
                  :key "s-BKSPC"
                  :description "er/contract-region")
  (cheatsheet-add :group 'Mark
                  :key "C-x C-x"
                  :description "Exchange point and mark without activating region")
  (cheatsheet-add :group 'Mark
                  :key "M-h"
                  :description "org-mark-element. Put point at beginning of this element, mark at end")
  (cheatsheet-add :group 'Mark
                  :key "C-c @"
                  :description "org-mark-subtree. Mark the subtree at point. Repeat to mark subsequent subtrees of the same level")
  (cheatsheet-add :group 'Minibuffer
                  :key "C-M-e"
                  :description "Miniedit: enter minibuffer edit")
  (cheatsheet-add :group 'Minibuffer
                  :key "C-c C-c"
                  :description "Miniedit: exit minibuffer edit")
  (cheatsheet-add :group 'Movement
                  :key "s-,"
                  :description "beginning-of-buffer")
  (cheatsheet-add :group 'Movement
                  :key "s-.>"
                  :description "end-of-buffer")
  (cheatsheet-add :group 'Narrowing
                  :key "C-x n b"
                  :description "Narrows to block in org-src block, for example")
  (cheatsheet-add :group 'Narrowing
                  :key "C-x n d"
                  :description "Narrows to defun")
  (cheatsheet-add :group 'Narrowing
                  :key "C-x n e"
                  :description "Narrows to element-A line, for ex.")
  (cheatsheet-add :group 'Narrowing
                  :key "C-x n n"
                  :description "Narrows to region")
  (cheatsheet-add :group 'Narrowing
                  :key "C-x n p"
                  :description "Narrows to page")
  (cheatsheet-add :group 'Narrowing
                  :key "C-x n s"
                  :description "Narrows to subtree in Org")
  (cheatsheet-add :group 'Narrowing
                  :key "C-x n w"
                  :description "Widens ")
  (cheatsheet-add :group 'Narrowing
                  :key "N"
                  :description "org-narrow-to-subtree")
  (cheatsheet-add :group 'Narrowing
                  :key "W"
                  :description "Widen in Org subtree") 
  (cheatsheet-add :group 'Org
                  :key "s-<"
                  :description "org-cut-subtree: cut tree and paste it elsewhere in the hierarchy.")
  (cheatsheet-add :group 'Org
                  :key "C-c @"
                  :description "Insert as Org link current highlighted file in P session")
  (cheatsheet-add :group 'Org
                  :key "M-Shift-<right>"
                  :description "Demote heading and all subheadings")
  (cheatsheet-add :group 'Org
                  :key "r"
                  :description "Positioned on stars of heading, demote heading but not subheadings")
  (cheatsheet-add :group 'Org
                  :key "R"
                  :description "Positioned on stars of heading, demote heading and all subheadings")
  (cheatsheet-add :group 'Org
                  :key "M-<right>"
                  :description "Demote only current heading but NOT its subheadings")
  (cheatsheet-add :group 'Org
                  :key "C-c C-o"
                  :description "org-open-at-point: Open links")
  (cheatsheet-add :group 'Org
                  :key "C-c C-x M-w"
                  :description "org-copy-subtree. Copy subtree to kill ring. With a numeric prefix argument N, copy the N sequential subtrees")
  (cheatsheet-add :group 'Org
                  :key "a"
                  :description "org-archive-subtree-default. Place cursor at start of heading. a will archive it")
  (cheatsheet-add :group 'Org
                  :key "i"
                  :description "Place cursor at start of heading. i will open clock menu")
  (cheatsheet-add :group 'Org
                  :key "t"
                  :description "Place cursor at start of heading. Toggle todo state. SPC to clear")
  (cheatsheet-add :group 'Org
                  :key "T"
                  :description "Place cursor at start of heading. Column view with effort and clocksum")
  (cheatsheet-add :group 'Org
                  :key "SPC"
                  :description "Place cursor at start of heading. See hierachical path to this heading")
  (cheatsheet-add :group 'Org
                  :key "C-c C-w"
                  :description "org-refile")
  (cheatsheet-add :group 'Org
                  :key "g"
                  :description "org-refile. Works if you place cursor on stars")
  (cheatsheet-add :group 'Org
                  :key "C-c C-x p"
                  :description "org-set-property. Edit a task's properties,e.g.,set STYLE to habit")
  (cheatsheet-add :group 'Org
                  :key "N"
                  :description "org-narrow-to-subtree")
  (cheatsheet-add :group 'Org
                  :key "W"
                  :description "Widen") 
  (cheatsheet-add :group 'Org
                  :key "S"
                  :description "org-sort. Sorts subtrees") 
  (cheatsheet-add :group 'Org
                  :key "S-<up><down>"
                  :description "On heading, add priority tag")
  (cheatsheet-add :group 'Org
                  :key "M-<up><down>"
                  :description "org-move-subtree-up or -down. On heading, move it up or down in hierarchy")
  (cheatsheet-add :group 'Org
                  :key "M-<left><right>"
                  :description "Promote/demote heading or all headings in a region")
  (cheatsheet-add :group 'Org
                  :key "S-<left><right>"
                  :description "On heading, add or change TODO status")
  (cheatsheet-add :group 'Org
                  :key "M-x org-repair-property-drawers"
                  :description "Fix properties drawers in current buffer. To use when habits or schedules don't show rightly")
  (cheatsheet-add :group 'Org-agenda
                  :key "A"
                  :description "Interactively select another agenda view and append it to the current view")
  (cheatsheet-add :group 'Org-agenda
                  :key "o"
                  :description "When in agenda view, delete other windows")
  (cheatsheet-add :group 'Org-agenda
                  :key "T or < C-c a t"
                  :description "my/org-agenda-for-subtree")
  (cheatsheet-add :group 'Org-agenda
                  :key "t"
                  :description "org-agenda-todo. When in an agenda's item, choose state")
  (cheatsheet-add :group 'Org-agenda
                  :key "K"
                  :description "Toggle org-habits")
  (cheatsheet-add :group 'Org-agenda
                  :key "C-, and C-'"
                  :description "org-cycle-agenda-files. Has to be located in heading of agenda file")
  (cheatsheet-add :group 'Org-agenda
                  :key "R"
                  :description "org-agenda-clockreport-mode. Toggle clocktable mode. Info about clocked time in the displayed period")
  (cheatsheet-add :group 'Org-agenda
                  :key "SPC"
                  :description "org-agenda-show-and-scroll-up. Display the original location of the item in another window. If repeated, scroll that other window")
  (cheatsheet-add :group 'Org-agenda
                  :key "TAB"
                  :description "org-agenda-goto. Go to the original location of the item in another window")
  (cheatsheet-add :group 'Org-agenda
                  :key "RET"
                  :description "org-agenda-switch-to. Go to the original location of the item and delete other windows")
  (cheatsheet-add :group 'Org-agenda
                  :key "J"
                  :description "org-agenda-clock-goto. Go to the currently clocked-in task in the agenda buffer")
  (cheatsheet-add :group 'Org-agenda
                  :key "F"
                  :description "org-agenda-follow-mode. Toggle Follow mode. As you move the cursor through the agenda buffer, the other window shows the corresponding location in the Org file")
  (cheatsheet-add :group 'Org-agenda
                  :key "v"
                  :description "Choose time spam in view and more")
  (cheatsheet-add :group 'Org-agenda
                  :key "v R"
                  :description "org-agenda-clockreport-mode. Toggle clock table. A quick report on time usage. Works directly with R only")
  (cheatsheet-add :group 'Org-agenda
                  :key "b"
                  :description "org-agenda-earlier. Move back one day or week")
  (cheatsheet-add :group 'Org-agenda
                  :key "f"
                  :description "org-agenda-later. Move forward one day or week")
  (cheatsheet-add :group 'Org-agenda
                  :key "l"
                  :description "org-agenda-log-mode. Shows entries marked DONE while logging was on and are entries clocked on that day, recording their timing")
  (cheatsheet-add :group 'Org-agenda
                  :key "v L"
                  :description "org-agenda-log-mode. how all possible logbook entries, including state changes")
  (cheatsheet-add :group 'Org-agenda
                  :key "G"
                  :description "org-agenda-toggle-time-grid. Toggle the time grid on and off")
  (cheatsheet-add :group 'Org-agenda
                  :key "J"
                  :description "org-agenda-clock-goto. Jump to the currently clocked in task within the agenda")
  (cheatsheet-add :group 'Org-agenda
                  :key "s"
                  :description "org-save-all-org-buffers. Save all Org buffers in the current Emacs session, and also the locations of IDs")
  (cheatsheet-add :group 'Org-agenda
                  :key "S"
                  :description "Show sunrise/Sunset times")
  (cheatsheet-add :group 'Org-agenda
                  :key "M"
                  :description "Show lunar phases")
  (cheatsheet-add :group 'Org-agenda
                  :key "C"
                  :description "Convert to other calendars")
  (cheatsheet-add :group 'Org-agenda
                  :key "M-x my/org-show-active-projects"
                  :description "Show my current projects. From Sacha")
  (cheatsheet-add :group 'Org-agenda
                  :key "g"
                  :description "org-agenda-redo-all. Rebuild all agenda views in the current buffer")
  (cheatsheet-add :group 'Org-agenda
                  :key "SPC"
                  :description "org-agenda-show-and-scroll-up. Display the Org file which contains the item at point. If repeated, scroll that Org file")
  (cheatsheet-add :group 'Org-agenda
                  :key "DEL"
                  :description "org-agenda-show-scroll-down. Scroll down the window showing the agenda")
  (cheatsheet-add :group 'Org-capture 
                  :key "C-c C-c"
                  :description "On heading of Org-captured entry, choose tag")
  (cheatsheet-add :group 'Org-capture
                  :key "SPC"
                  :description "Clear tag selection")
  (cheatsheet-add :group 'Org-capture
                  :key "C-c C-r"
                  :description "my/org-refile-and-jump org-capture-mode-map. Refile a capture and then jump to the new location... Leaves one hanging buffer. I think C-c C-w is better")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c j"
                  :description "org-clock-goto. jump to current task from anywhere")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x C-e"
                  :description "org-clock-modify-effort-estimate. Manually set the effort for a particular headline")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x e"
                  :description "Prompted for an effort estimation")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x C-c"
                  :description "org-agenda-columns. Turn on org-columns reporting your time use-Quit with q")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x i"
                  :description "Generate a local column view-Quit with q-Not working!")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x C-i"
                  :description "org-clock-in. Clock in to the section you're currently in or clock-in to a different task")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c I"
                  :description "eos/org-clock-in. History of tasks to pick from when I clock in to thing")
  (cheatsheet-add :group 'Org-clock
                  :key "I"
                  :description "In org-agenda, clock in highlighted task or clock-in to a different task")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x C-o"
                  :description "org-clock-out. Clock out of whatever you're clocked in to")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c O"
                  :description "org-clock-out. Clock out of whatever you're clocked in to")
  (cheatsheet-add :group 'Org-clock
                  :key "O"
                  :description "In org-agenda, clock out of highlighted task")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x C-x"
                  :description "org-clock-in-last. Clock in to the last clocked task")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x C-j"
                  :description "org-clock-goto. Jump to whatever headline you are currently clocked in to or to the most recently clocked one")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x C-q"
                  :description "org-clock-cancel. Cancel the current clock-removes all of its current time ")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x C-d"
                  :description "org-clock-display. Display clock times for headlines in current file")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x C-r"
                  :description "org-clock-report. Generate a report for clock activity.NOT WORKING")
  (cheatsheet-add :group 'Org-clock
                  :key "C-c C-x C-z"
                  :description "org-resolve-clocks. Resolve any half-open clocks")
  (cheatsheet-add :group 'Org-clock
                  :key "v c"
                  :description "Show overlapping clock entries, clocking gaps, and other clocking problems in the current agenda range. Use b to go back one day, l to exit")
  (cheatsheet-add :group 'Org-clock
                  :key "Fn-Shift-<left><right>"
                  :description "On date entry will shift the days; On brackets will change them to <>")
  (cheatsheet-add :group 'Org-clock
                  :key "Fn-Shift-<up><down>"
                  :description "On clock entry will shift the time")
  (cheatsheet-add :group 'Org-latex
                  :key "C-c C-x C-l"
                  :description "org-toggle-latex-fragment. C-c C-c to show the equation code")
  (cheatsheet-add :group 'Org-movement
                  :key "M-{"
                  :description "org-backward-element. Move to the previous element at the same level, when possible")
  (cheatsheet-add :group 'Org-movement
                  :key "M-}"
                  :description "org-forward-element. Move to the next element at the same level, when possible")
  (cheatsheet-add :group 'Org-movement
                  :key "n"
                  :description "Place cursor at start of heading, n will move to next heading of any level. C-M-n and C-c C-n do the same")
  (cheatsheet-add :group 'Org-movement
                  :key "p"
                  :description "Place cursor at start of heading, b will move to previous heading. C-M-p and C-c C-p do the same")
  (cheatsheet-add :group 'Org-recipes
                  :key "C-c i"
                  :description "Insert raw code under a heading")
  (cheatsheet-add :group 'Org-table
                  :key "M-Shift-<down>"
                  :description "Insert a new row above the current row. With a prefix argument, the line is created below the current one")
  (cheatsheet-add :group 'Org-table
                  :key "Shift-TAB"
                  :description "Re-align, move to previous field-like previous cell")
  (cheatsheet-add :group 'Org-table
                  :key "Shift-TAB"
                  :description "Re-align, move to previous field-like previous cell")
  (cheatsheet-add :group 'Org-table
                  :key "TAB"
                  :description "Re-align the table, move to the next field. Creates a new row if necessary")
  (cheatsheet-add :group 'Org-timestamps
                  :key "Shift-<up><down>"
                  :description "Increment/decrement stamp")
  (cheatsheet-add :group 'Magit
                  :key "f a X h"
                  :description "Force pull from remote: f a, then move point to remote head, X h")
  (cheatsheet-add :group 'Packages
                  :key "M-x try"
                  :description "Try a package before installing for good")
  (cheatsheet-add :group 'Password
                  :key "M-x password-store"
                  :description "password-store")
  (cheatsheet-add :group 'Password
                  :key "M-x helm-pass"
                  :description "helm-pass")
  (cheatsheet-add :group 'Password
                  :key "C-x #"
                  :description "Save and exit")
  (cheatsheet-add :group 'Password-Ivy
                  :key "M-i"
                  :description "Select entry in Ivy-Pass")
  (cheatsheet-add :group 'Password-Ivy
                  :key "RET"
                  :description "Copy password in kill ring")
  (cheatsheet-add :group 'Prefixes
                  :key "C-x r"
                  :description "Registers and bookmarks")
  (cheatsheet-add :group 'Prefixes
                  :key "C-c"
                  :description "Org commands")
  (cheatsheet-add :group 'Prefixes
                  :key "C-x r"
                  :description "Registers and bookmarks")
  (cheatsheet-add :group 'Projectile
                  :key "s-h"
                  :description "helm-projectile: select project and buffers/files")
  (cheatsheet-add :group 'Projectile
                  :key "s-j"
                  :description "helm-projectile-find-file: Powerful P session for file management")
  (cheatsheet-add :group 'Python
                  :key "M-x run-python"
                  :description "Launch iPython")
  (cheatsheet-add :group 'Reading
                  :key "xah-toggle-margin-right"
                  :description "For reading novel or documentation: Toggle right margin")
  (cheatsheet-add :group 'Register
                  :key "s-x"
                  :description "helm-register. Then TAB or RET to insert. Equivalent to C-x r i")
  (cheatsheet-add :group 'Redshift
                  :key "C-\("
                  :description "Redshift on. If repeated, intensity increases")
  (cheatsheet-add :group 'Redshift
                  :key "C-\)"
                  :description "Redshift off")
  (cheatsheet-add :group 'Replace
                  :key "C-c s"
                  :description "Global replacement by dynamically building regular expressions")
  (cheatsheet-add :group 'Replace
                  :key "C-c q"
                  :description "Decide to replace per match by dynamically building regular expressions")
  (cheatsheet-add :group 'Replace
                  :key "M-%"
                  :description "anzu-query-replace")
  (cheatsheet-add :group 'Replace
                  :key "C-M-%"
                  :description "anzu-query-replace-regexp")
  (cheatsheet-add :group 'Revert
                  :key "C-c r"
                  :description "Replace buffer text visited file on disk. C-u offers to revert from latest auto-save file")
  (cheatsheet-add :group 'Scratch
                  :key "M-x scratch"
                  :description "With C-u you choose mode, otherwise current mode is used")
  (cheatsheet-add :group 'Screenshot
                  :key "s-["
                  :description "Takes a fullscreen screenshot of the current workspace")
  (cheatsheet-add :group 'Screenshot
                  :key "s-]"
                  :description "Takes a screenshot of a region selected by the user")
  (cheatsheet-add :group 'Security
                  :key "s-_"
                  :description "daedreth/lock-screen")
  (cheatsheet-add :group 'Shell
                  :key "C-x m"
                  :description "Open eshell")
  (cheatsheet-add :group 'Shell
                  :key "C-x M"
                  :description "Open eshell even if one is active")
  (cheatsheet-add :group 'Shell
                  :key "M-e"
                  :description "Open Eshell when in P session")
  (cheatsheet-add :group 'Org-Skeleton
                  :key "M-x article-skeleton"
                  :description "Inserts a skeleton for Org-export to LaTeX")
  (cheatsheet-add :group 'OrgSkeleton
                  :key "M-x beamer-skeleton"
                  :description "Inserts a  for Org-export to Beamer")
  (cheatsheet-add :group 'Spelling
                  :key "C-M-$"
                  :description "Change dictionary")
  (cheatsheet-add :group 'Spelling
                  :key "M-$"
                  :description "Spellcheck word or region")
  (cheatsheet-add :group 'System
                  :key "s-t"
                  :description "helm-top for TOP program to display Linux processes")
  (cheatsheet-add :group 'Typing
                  :key "M-x typing-of-emacs"
                  :description "Practise typing")
  (cheatsheet-add :group 'Typing
                  :key "my/org-entry-wpm"
                  :description "Curious about how fast I type. Works under Org tree")
  (cheatsheet-add :group 'Undo-Propose
                  :key "M-x undo-propose"
                  :description "Cycle through the list of undo's as normal in a new temporary buffer")
  (cheatsheet-add :group 'Undo-Propose
                  :key "C-c C-c"
                  :description "Add the chain of undo's as a single edit to the undo history")
  (cheatsheet-add :group 'Undo-Propose
                  :key "C-c C-d"
                  :description "Ediff the proposed chain of undo's")
  (cheatsheet-add :group 'Undo-Propose
                  :key "C-c C-k"
                  :description "Cancel undo-propose")
  (cheatsheet-add :group 'Undo-Tree
                  :key "C-z"
                  :description "undo-tree-undo: Undo changes. C-u limits it to current region")
  (cheatsheet-add :group 'Undo-Tree
                  :key "C-x u"
                  :description "undo-tree-visualize: undo. Visualize the current buffer's undo tree")
  (cheatsheet-add :group 'Weather
                  :key "M-x forecast"
                  :description "forecast package")
  (cheatsheet-add :group 'Weather
                  :key "M-x wttrin"
                  :description "forecast package with drawings")
  (cheatsheet-add :group 'Weather
                  :key "M-x sunrise-sunset"
                  :description "Shows times for sunrise and sunset in minibuffer. More settings in dgm.org")
  (cheatsheet-add :group 'Windows
                  :key "C-x 1"
                  :description "zygospore-toggle-delete-other-windows RET: lets you revert C-x 1-delete-other-window-by pressing C-x 1 again")
  (cheatsheet-add :group 'Windows
                  :key "M-P"
                  :description "ace-window")
  (cheatsheet-add :group 'Windows
                  :key "C-x 2"
                  :description "Vertical split windows and move to new window")
  (cheatsheet-add :group 'Windows
                  :key "C-x 3"
                  :description "Horizontal split windows and move to new window")
  (cheatsheet-add :group 'Windows
                  :key "C-$"
                  :description "ambrevar/toggle-window-split: Transpose windows")
  (cheatsheet-add :group 'Windows
                  :key "C-&"
                  :description "rotate-windows")
  (cheatsheet-add :group 'Windows
                  :key "s-M-<left>"
                  :description "shrink-window-horizontally")
  (cheatsheet-add :group 'Windows
                  :key "s-M-<right>"
                  :description "enlarge-window-horizontally")
  (cheatsheet-add :group 'Windows
                  :key "s-M-<down>"
                  :description "shrink-window")
  (cheatsheet-add :group 'Windows
                  :key "s-M-<up>"
                  :description "enlarge-window")
  (cheatsheet-add :group 'Windows
                  :key "C-c <left>"
                  :description "winner-undo: Switch back to earlier window config; undo changes in window config")
  (cheatsheet-add :group 'Windows
                  :key "C-c <right> or <down>"
                  :description "winner-redo: Restore a more recent window configuration saved by Winner mode")
  (cheatsheet-add :group 'Window-Movement
                  :key "s-<left>"
                  :description "windmove-left")
  (cheatsheet-add :group 'Window-Movement
                  :key "s-<right>"
                  :description "windmove-right")
  (cheatsheet-add :group 'Window-Movement
                  :key "s-<up>"
                  :description "windmove-up")
  (cheatsheet-add :group 'Window-Movement
                  :key "s-<down>"
                  :description "windmove-down")
  :bind ("s-:" . cheatsheet-show)
  )
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23950 12701 583672 765000) :init (23950 12701 583609 57000) :init-secs (0 0 27 870000) :use-package-secs (0 0 181 508000)))



* Remapping =M-<= and =M->=

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "s-,") 'beginning-of-buffer)
(global-set-key (kbd "s-.") 'end-of-buffer)
#+end_src

#+RESULTS:
: end-of-buffer

* Get various new windows at the bottom of the screen 

This next bit is from https://github.com/syl20bnr/spacemacs/issues/6820 to try and get the shell and IPython at the bottom of the screen 

#+BEGIN_SRC emacs-lisp :tangle yes
(push (cons "\\*shell\\*" display-buffer--same-window-action) display-buffer-alist)
(push (cons "\\*IPython3\\*" display-buffer--same-window-action) display-buffer-alist)
(push (cons "\\*IPython\\*" display-buffer--same-window-action) display-buffer-alist)
(push (cons "\\*Python\\*" display-buffer--same-window-action) display-buffer-alist)
(push (cons "\\*stata\\*" display-buffer--same-window-action) display-buffer-alist)
(push (cons "\\*cheatsheet\\*" display-buffer--same-window-action) display-buffer-alist)
#+END_SRC

#+RESULTS:
| \*cheatsheet\*   | display-buffer-same-window      | (inhibit-same-window) |
| \*stata\*        | display-buffer-same-window      | (inhibit-same-window) |
| \*IPython\*      | display-buffer-same-window      | (inhibit-same-window) |
| \*IPython3\*     | display-buffer-same-window      | (inhibit-same-window) |
| \*shell\*        | display-buffer-same-window      | (inhibit-same-window) |
| \*stata\*        | display-buffer-same-window      | (inhibit-same-window) |
| \*IPython\*      | display-buffer-same-window      | (inhibit-same-window) |
| \*IPython3\*     | display-buffer-same-window      | (inhibit-same-window) |
| \*shell\*        | display-buffer-same-window      | (inhibit-same-window) |
| \`\*Calendar\*\' | (display-buffer-below-selected) |                       |
| \*Calendar\*     | my-position-calendar-buffer     |                       |


* Security
On Sept 27, 2019, when I try to look up for package doing =M-x package-list-packages=, I get an error: 

#+begin_example
Failed to verify signature archive-contents.sig:
No public key for 066DAFCB81E42C40 created at 2019-09-27T11:10:02+0200 using RSA
Command output:
gpg: Signature made Fri 27 Sep 2019 11:10:02 AM CEST
gpg:                using RSA key C433554766D3DDC64221BFAA066DAFCB81E42C40
gpg: Can't check signature: No public key
#+end_example

Investigating I go to http://elpa.gnu.org/packages/gnu-elpa-keyring-update.html and 
I do as it says:

1. Fetch the new key manually, e.g. with something like:

#+begin_example
gpg --homedir ~/.emacs.d/elpa/gnupg --receive-keys 066DAFCB81E42C40
#+end_example

2. Modify the expiration date of the old key, e.g. with something like:

#+begin_example
      gpg --homedir ~/.emacs.d/elpa/gnupg \
          --quick-set-expire 474F05837FBDEF9B 1y
#+end_example

Esto no funciona. Obtengo: 

#+begin_example
gpg: "474F05837FBDEF9B" is not a fingerprint
#+end_example

Temporarily disable signature verification (see variable `package-check-signature').

#+begin_example
(setq package-check-signature nil)
#+end_example

After all this, I do =M-x package-refresh-contents= and this updates all my packages, which I think is a mistake.



* Provide

Trying this on 28 dic 2018. I don't really know why it is needed or not.

#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'dgm)
#+END_SRC

#+RESULTS:
: dgm

* Final message
#+source: message-line
#+begin_src emacs-lisp :tangle yes
(message "Starter Kit User (DGM) File loaded.")
#+end_src

#+RESULTS: message-line
: Starter Kit User File loaded.

