



*** COMMENT Run R in emacs (ESS)
Tip from: https://github.com/izahn/dotemacs

Support for R in Emacs is good, thanks to http://ess.r-project.org/. As with other programming languages this configuration enables completion via the tab key and code evaluation with C-ret. Many more features are provided by ESS, refer to http://ess.r-project.org/ for details.

#+begin_src emacs-lisp :tangle yes
    ;;;  ESS (Emacs Speaks Statistics)

  ;; ;; Start R in the working directory by default
  ;; (setq ess-ask-for-ess-directory nil)
  ;;
  ;; ;; Make sure ESS is loaded before we configure it
  ;; (autoload 'julia "ess-julia" "Start a Julia REPL." t)
  ;; (with-eval-after-load "ess-site"
  ;;   ;; disable ehoing input
  ;;   (setq ess-eval-visibly nil)
  ;;   ;; Start R in the working directory by default
  ;;   (setq ess-ask-for-ess-directory nil)
  ;;   ;; Use tab completion
  ;;   (setq ess-tab-complete-in-script t)
  ;;   ;; extra ESS stuff inspired by https://github.com/gaborcsardi/dot-emacs/blob/master/.emacs
  ;;   (ess-toggle-underscore nil)
  ;;   (defun my-ess-execute-screen-options (foo)
  ;;     "cycle through windows whose major mode is inferior-ess-mode and fix width"
  ;;     (interactive)
  ;;     (setq my-windows-list (window-list))
  ;;     (while my-windows-list
  ;;       (when (with-selected-window (car my-windows-list) (string= "inferior-ess-mode" ;; major-mode))
  ;;         (with-selected-window (car my-windows-list) (ess-execute-screen-options t)))
  ;;       (setq my-windows-list (cdr my-windows-list))))
  ;;   (add-to-list 'window-size-change-functions 'my-ess-execute-screen-options)
  ;;   (define-key ess-mode-map (kbd "<C-return>") ;; 'ess-eval-region-or-function-or-paragraph-and-step)
  ;;   ;; truncate long lines in R source files
  ;;   (add-hook 'ess-mode-hook
  ;;             (lambda()
  ;;               ;; don't wrap long lines
  ;;               (toggle-truncate-lines t)
  ;;               (outline-minor-mode t))))
#+end_src

Note: for me "C-return" does not work... Comento todo esto porque me temo que entra en conflicto con la costumization del gran Kieran Healy en =starter-kit-stats.org= donde veo que la evaluación está bound a =shift-return= and that works indeed for me.


#+BEGIN_SRC emacs-lisp :tangle no
  (use-package pdf-tools
    :defer t)

  ;; (pdf-tools-install) ;; commented out as I think it gets activated below
#+END_SRC

*** COMMENT Mac Key mode
Used with Mitsuharu Yamamoto's carbon-patched Emacs, which turns
off support for default mac bindings. Turned off by default.
#+srcname: mac-keys
#+begin_src emacs-lisp :tangle no
  (require 'mac-key-mode)
  (mac-key-mode 1)
  (add-hook 'mac-key-mode-hook
            (lambda()
              (interactive)
              (if mac-key-mode
                  (setq mac-option-modifier 'meta)
                (setq mac-option-modifier nil)
                )))
#+end_src

*** Pragmatic Emacs alternative with =wttrin=
The only problem is that if the Emacs frame is not wide enough and the lines in the wttrin buffer wrap, it becomes unreadable.

My solution is to save the window and frame configuration, then resize the frame to be big enough for the wttrin buffer. The previous configuration is then restored when exiting wttrin. These functions take care of that for us:

Disabled by DGM as it makes wttrin fail to work.

#+BEGIN_SRC emacs-lisp :tangle no
  ;;advise wttrin to save frame arrangement
  ;;requires frame-cmds package
  (defun bjm/wttrin-save-frame ()
    "Save frame and window configuration and then expand frame for wttrin."
    ;;save window arrangement to a register
    (window-configuration-to-register :pre-wttrin)
    (delete-other-windows)
    ;;save frame setup and resize
    (save-frame-config)
    (set-frame-width (selected-frame) 130)
    (set-frame-height (selected-frame) 48)
    )
  (advice-add 'wttrin :before #'bjm/wttrin-save-frame)

  (defun bjm/wttrin-restore-frame ()
    "Restore frame and window configuration saved prior to launching wttrin."
    (interactive)
    (jump-to-frame-config-register)
    (jump-to-register :pre-wttrin)
    )
  (advice-add 'wttrin-exit :after #'bjm/wttrin-restore-frame)
#+END_SRC

#+RESULTS:

******* COMMENT switch-window
This magnificent package takes care of this issue. It’s unnoticeable if you have <3 panes open, but with 3 or more, upon pressing C-x o you will notice how your buffers turn a solid color and each buffer is asigned a letter (the list below shows the letters, you can modify them to suit your liking), upon pressing a letter asigned to a window, your will be taken to said window, easy to remember, quick to use and most importantly, it annihilates a big issue I had with emacs. An alternative is ace-window, however by default it also changes the behaviour of C-x o even if only 2 windows are open, this is bad, it also works less well with exwm for some reason.

DGM: I suspect that this package is responsible for my disappearing-cursor problem because it has always happened when moving across windows... the only other suspect I have is Dired as I think it has involved moving files across windows and directories.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package switch-window
    :defer t
    :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
          '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
    :bind
    ([remap other-window] . switch-window))
#+END_SRC

#+RESULTS:
: switch-window

******* COMMENT Following window splits
After you split a window, your focus remains in the prebbbbvious one. This annoyed me so much I wrote these two, they take care of it.
Note: I've commented this out because below I implement the same functionality. See [[split]]

#+BEGIN_SRC emacs-lisp :tangle no
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

#+RESULTS:
: split-and-follow-vertically

*** COMMENT shx

Commented out in an attempt to speed up evaluation in R and Stata... and BINGO!!! this was the little motherfucker that made R and Stata super slow interactively. It also caused an error on exit.

Enhance comint-mode. See https://github.com/riscy/shx-for-emacsl

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package shx
    :defer t
    :init (shx-global-mode 1))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23563 38338 822346 339000) :init (23563 38338 822317 934000) :config (23563 38338 821844 459000) :config-secs (0 0 13 374000) :init-secs (0 0 2171 786000) :use-package-secs (0 0 2344 520000)))

Alternativa from https://github.com/malb/emacs.d/blob/master/malb.org

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package shx
    :defer t
    :after comint
    :config (progn
              ;;(with-eval-after-load 'python
              ;;  (add-hook 'inferior-python-mode-hook #'shx-mode))
              ;; (with-eval-after-load 'sage-shell-mode
              ;;   (add-hook 'sage-shell-mode-hook #'shx-mode))
              (with-eval-after-load 'shell
                (add-hook 'shell-mode-hook #'shx-mode)))
    ;; from https://github.com/riscy/shx-for-emacs
    (setq
     ;; vastly improve display performance by breaking up long output lines
     shx-max-output 1024
     ;; prevent input longer than macOS's typeahead buffer from going through
     shx-max-input 1024
     ;; prefer inlined images to have a height of 250 pixels
     shx-img-height 250
     ;; don't show any incidental hint messages about how to use shx
     shx-show-hints nil
     ;; flash the previous comint prompt for a full second when using C-c C-p
     shx-flash-prompt-time 1.0
     ;; use `#' to prefix shx commands instead of the default `:'
     shx-leader "#"))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23563 39460 592701 842000) :init (23563 39460 592655 127000) :config (23563 39460 592361 613000) :config-secs (0 0 651 835000) :init-secs (0 0 1187 492000) :use-package-secs (0 0 1286 219000)))

***** line numbers and programming
Every now and then all of us feel the urge to be productive and write some code. In the event that this happens, the following bit of configuration makes sure that we have access to relative line numbering in programming-related modes. I highly recommend not enabling linum-relative-mode globally, as it messed up something like ansi-term for instance.

Note: I disable this as I find it not very useful and dizzling by way of the moving numbers

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package linum-relative
    :config
    (setq linum-relative-current-symbol "")
    (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC

#+RESULTS:
: t

***** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most. With a simple M-y you can now browse your kill-ring like browsing autocompletion items. C-n and C-p totally work for this.

DGM: nice, but i prefer to use helm to browse the kill ring.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package popup-kill-ring
    :defer t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC

#+RESULTS:
: popup-kill-ring

***** COMMENT Hungry deletion
On the list of things I like doing, deleting big whitespaces is pretty close to the bottom. Backspace or Delete will get rid of all whitespace until the next non-whitespace character is encountered. You may not like it, thus disable it if you must, but it’s pretty decent.

DGM: I am commenting this out as I found it annoying when, for example, editing ledger files and wanting to delete spaces one by one I found the cursor deleting all the white space and thus indening lines in the wrong manner. La sensacion era como si el buffer estuviera tabify when it wasn't... So I wasn't understanding what was going on until I recalled I had this mode enabled.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package hungry-delete
    :defer t
    :config
    (global-hungry-delete-mode))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (23554 33611 672389 982000) :init (23554 33611 672357 93000) :config (23554 33611 672016 76000) :config-secs (0 0 2391 739000) :init-secs (0 0 3160 173000) :use-package-secs (0 0 3365 347000)))

****** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor. Unless you know its position, you cannot move it efficiently. Every time you change buffers, the current position of your cursor will be briefly highlighted now.

As much as I like it, it produces interferences.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package beacon
    :defer t
    :config
    (beacon-mode 1))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (24174 25303 116491 741000) :init (24174 25303 116448 801000) :config (24174 25303 115167 252000) :config-secs (0 0 2126 491000) :init-secs (0 0 4012 662000) :use-package-secs (0 0 4173 185000)))


***** COMMENT Ace-jump
A quick way to jump around text in buffers.

See Emacs Rocks Episode 10 for a screencast: http://emacsrocks.com/e10.html

Commented out as =C-o= does the same and =s-z= even better as it applies to any letter anywhere in the buffer.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ace-jump-mode
    :defer t
    :diminish ace-jump-mode
    :commands ace-jump-mode
    :bind ("C-s-s" . ace-jump-mode))
#+END_SRC

#+RESULTS:
: ace-jump-mode
