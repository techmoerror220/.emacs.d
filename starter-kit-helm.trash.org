Basic commands with for interfacing with =exwm= with =helm=

#+BEGIN_SRC emacs-lisp :tangle no
(with-eval-after-load 'helm
  ;; Need `with-eval-after-load' here since 'helm-map is not defined in 'helm-config.
  ;;  (ambrevar/define-keys helm-map "s-\\" 'helm-toggle-resplit-and-swap-windows) ;; already used in starter-kit-exwm.org for ambrevar/toggle-window-split
  ;; (exwm-input-set-key (kbd "s-c") #'helm-resume)  ;; get the latest helm thing you did!, i.e., reopen the last helm search. Hey: if I enable this line, instead of helm-resume I get helm-occur. Why?
  ;; (exwm-input-set-key (kbd "s-b") #'helm-mini) ;; not needed as already in =C-x b=
  ;; (exwm-input-set-key (kbd "s-f") #'helm-find-files) ;; already in C-x C-f
  ;; (exwm-input-set-key (kbd "s-:") #'helm-for-files) ;; tuhdo doesn't use it, so it goes
  (exwm-input-set-key (kbd "s-D") #'helm-locate)
  (exwm-input-set-key (kbd "s-d") #'helm-find))
  ;;(when (fboundp 'ambrevar/helm-locate-meta)
  ;;  (exwm-input-set-key (kbd "!!here") #'ambrevar/helm-locate-meta))
  ;; (exwm-input-set-key (kbd "s-F") #'helm-ag)
  ;; (exwm-input-set-key (kbd "s-f") #'helm-do-grep-ag))
  ;;(exwm-input-set-key (kbd "s-g") 'ambrevar/helm-grep-git-or-ag)
  ;;(exwm-input-set-key (kbd "s-G") 'ambrevar/helm-grep-git-all-or-ag))
#+END_SRC


* Look at the Emacs or Elisp manual with helm

From: https://www.reddit.com/r/emacs/comments/cuc8hl/how_do_you_remember_various_features_of_emacs/


#+BEGIN_SRC emacs-lisp :tangle no
(defun ap/helm-info-emacs-elisp-cl ()
  "Helm for Emacs, Elisp, and CL-library info pages."
  (interactive)
  (helm :sources '(helm-source-info-emacs
                   helm-source-info-elisp
                   helm-source-info-cl)))

(global-set-key (kbd "s-\)") 'ap/helm-info-emacs-elisp-cl)
#+END_SRC

#+RESULTS:
: ap/helm-info-emacs-elisp-cl



* Quit Helm with one key stroke

Often when invoking helm and wanting to cancel, I have to press =C-g= multiple times. Trying here to reduce it to one time.

From: https://www.reddit.com/r/emacs/comments/7eboyr/closing_helmmx_with_single_key_press/

Originally i had also =(define-key helm-M-x-map (kbd "ESC") 'helm-keyboard-quit)= but then I got the message "(void-variable helm-M-x-map)" and could not use Helm.


#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'helm-after-initialize-hook
          (lambda()
            (define-key helm-buffer-map (kbd "C-g") 'helm-keyboard-quit)
            (define-key helm-map (kbd "C-g") 'helm-keyboard-quit)))
#+END_SRC

#+RESULTS:
| (lambda nil (define-key helm-buffer-map (kbd C-g) 'helm-keyboard-quit) (define-key helm-map (kbd C-g) 'helm-keyboard-quit)) | (lambda nil (define-key helm-buffer-map (kbd ESC) 'helm-keyboard-quit) (define-key helm-map (kbd ESC) 'helm-keyboard-quit)) | helm-reset-yank-point |

** Customization

https://github.com/emacs-helm/helm/wiki/Grep

#+begin_src emacs-lisp :tangle no
(setq helm-grep-ag-command "ag --line-numbers -S --hidden --color --color-match '31;43' --nogroup %s %s %s")
(setq helm-grep-ag-pipe-cmd-switches '("--color-match '31;43'"))
#+end_src

#+RESULTS:
| --color-match '31;43' |


* Grep, Ack, AG
** COMMENT =helm-ack=

=C-x C-f= you start a =helm-find-files= session. There you can do =C-s= to recursively grep a selected directory.  Every time you type a character, helm updates grep result immediately. You can use ack-grep to replace grep with this configuration:

DGM, 4 sept 2019: not sure ack is better than grep.

#+begin_src emacs-lisp :tangle no
(use-package helm-ack
  :config 
  (when (executable-find "ack-grep")
    (setq helm-grep-default-command "ack-grep -Hn --no-group --no-color %e %p %f"
          helm-grep-default-recurse-command "ack-grep -H --no-group --no-color %e %p %f")))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (24463 12502 133331 166000) :init (24463 12502 133312 827000) :init-secs (0 0 41 20000) :use-package-secs (0 0 114 969000)))

** Grep in Projectile project

#+begin_src emacs-lisp :tangle no
 (global-set-key (kbd "s-g") 'helm-projectile-grep)
 ;; (global-set-key (kbd "s-f") 'helm-projectile-ag)

#+end_src

#+RESULTS:
: helm-projectile-grep

*** Customization
https://github.com/emacs-helm/helm/wiki/Grep

#+begin_src emacs-lisp :tangle no
(setq helm-grep-default-command
      "grep --color=always -d skip %e -n%cH -e %p %f"
      helm-grep-default-recurse-command
      "grep --color=always -d recurse %e -n%cH -e %p %f")
#+end_src

#+RESULTS:
: grep --color=always -d recurse %e -n%cH -e %p %f

* helm-man-woman

With helm-man-woman, you can quickly jump to any man entry using the Helm interface, either by typing in Helm prompt or if the point is on a symbol, opening the man page at point. To enable man page at point, add the following code: 

#+begin_src emacs-lisp :tangle no
(add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
(global-set-key (kbd "s-m") 'helm-man-woman)
#+end_src

#+RESULTS:
| helm-source-imenu | helm-source-imenu-all | helm-source-info-elisp | helm-source-etags-select | helm-source-man-pages | helm-source-occur | helm-source-moccur | helm-source-grep-ag | helm-source-grep-git | helm-source-grep |

** Tuhdo on indexing method

#+BEGIN_EXAMPLE
(use-package helm-projectile
  :init
  (helm-projectile-on)
  (setq projectile-completion-system 'helm)
  (setq projectile-indexing-method 'alien))))
#+END_EXAMPLE

** Various =helm-projectile= shortcuts

#+begin_src emacs-lisp :tangle no
;; (define-key projectile-mode-map [?\s-d] 'projectile-switch-project)
(define-key projectile-mode-map [?\s-\|] 'helm-projectile-find-file-dwim)
(define-key projectile-mode-map [?\s-\`] 'helm-projectile-find-other-file)
(define-key projectile-mode-map [?\s-\*] 'helm-projectile-find-dir)
(define-key projectile-mode-map [?\s-j] 'helm-projectile-find-file)
(define-key projectile-mode-map [?\s-n] 'helm-projectile-switch-to-buffer)
;;(define-key projectile-mode-map [?\s-y] 'projectile-ag) ;; this is not working. 
#+end_src

#+RESULTS:
: helm-projectile-switch-to-buffer

;; (define-key projectile-mode-map [?\s-u] 'helm-projectile-find-file-in-known-projects) 
;(setq projectile-switch-project-action 'helm-projectile)
;(global-set-key (kbd "s-h") 'helm-projectile)
;; from https://projectile.readthedocs.io/en/latest/usage/
;; You can go one step further and set a list of folders which Projectile is automatically going to check for projects. But in reality, if I re-start the computer, Projectile does not recall this list. 
#+END_SRC

#+RESULTS: helm-projectile
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (24468 17416 676966 405000) :use-package-secs (0 0 778 197000) :init (24468 17416 676875 158000) :config (24468 17416 676862 517000) :config-secs (0 0 293 862000) :init-secs (0 0 588 488000)))

#+RESULTS: projectile
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (24467 60600 569116 147000) :init (24467 60600 568515 643000) :config (24467 60600 568480 166000) :config-secs (0 4 900998 288000) :init-secs (0 4 901050 52000) :use-package-secs (0 4 901695 797000)))

Need to use =helm-projectile-find-other-file=. See https://tuhdo.github.io/helm-projectile.html

#+BEGIN_SRC emacs-lisp :tangle no
(setq projectile-other-file-alist '(("cpp" "h" "hpp" "ipp")
                                    ("ipp" "h" "hpp" "cpp")
                                    ("hpp" "h" "ipp" "cpp")
                                    ("cxx" "hxx" "ixx")
                                    ("ixx" "cxx" "hxx")
                                    ("hxx" "ixx" "cxx")
                                    ("c" "h")
                                    ("m" "h")
                                    ("mm" "h")
                                    ("h" "c" "cpp" "ipp" "hpp" "m" "mm")
                                    ("cc" "hh")
                                    ("hh" "cc")
                                    ("vert" "frag")
                                    ("frag" "vert")
                                    (nil "lock" "gpg")
                                    ("lock" "")
                                    ("gpg" "")))

(add-to-list 'projectile-other-file-alist '("org" "el")) ;; switch from org -> el 
(add-to-list 'projectile-other-file-alist '("el" "org")) ;; switch from el -> org 
(add-to-list 'projectile-other-file-alist '("Rnw" "R"))
(add-to-list 'projectile-other-file-alist '("R" "Rnw"))
(add-to-list 'projectile-other-file-alist '("Rnw" "tex"))
(add-to-list 'projectile-other-file-alist '("tex" "Rnw"))
(add-to-list 'projectile-other-file-alist '("org" "tex"))
(add-to-list 'projectile-other-file-alist '("tex" "org"))
(add-to-list 'projectile-other-file-alist '("tex" "log"))
(add-to-list 'projectile-other-file-alist '("log" "tex"))
(add-to-list 'projectile-other-file-alist '("org" "html"))
(add-to-list 'projectile-other-file-alist '("html" "org"))
#+END_SRC

** Advice from Tuhdo for ignoring files

From https://github.com/bbatsov/projectile/issues/184

#+BEGIN_SRC emacs-lisp :tangle no
(add-to-list 'projectile-globally-ignored-files "*.png")
(setq projectile-globally-ignored-file-suffixes '(".cache"))
#+END_SRC

#+RESULTS:
| .cache |

* Eldoc 

ELDOC is interactive eLisp evaluation.

In Sacha's dotfiles, she says: "Eldoc provides minibuffer hints when working with Emacs Lisp."

#+BEGIN_SRC emacs-lisp :tangle no
;; helm-eval-expression-with-eldoc
;; (global-set-key (kbd "C-c h M-:") 'helm-eval-expression-with-eldoc)
(global-set-key (kbd "s-(") 'helm-eval-expression-with-eldoc)
#+END_SRC

#+RESULTS:
: helm-eval-expression-with-eldoc

* Google and Wikipedia

#+BEGIN_SRC emacs-lisp :tangle no
;; helm-google-suggest
(global-set-key (kbd "C-c h g") 'helm-google-suggest)
(global-set-key (kbd "C-c h w") 'helm-wikipedia-suggest)
#+END_SRC

** Generic configuration

#+BEGIN_SRC emacs-lisp :tangle no
(setq
 helm-follow-mode-persistent t
 helm-reuse-last-window-split-state t
 helm-findutils-search-full-path t
 helm-show-completion-display-function nil
 helm-completion-mode-string ""
 helm-dwim-target 'completion
 ;; helm-echo-input-in-header-line t
 helm-use-frame-when-more-than-two-windows nil
 ;; helm-apropos-fuzzy-match t
 ;; helm-buffers-fuzzy-matching t
 ;; helm-eshell-fuzzy-match t
 ;; helm-imenu-fuzzy-match t
 ;; helm-M-x-fuzzy-match t
 ;; helm-recentf-fuzzy-match t
 ;; Use woman instead of man.
 helm-man-or-woman-function nil
 ;; https://github.com/emacs-helm/helm/issues/1910
 helm-buffers-end-truncated-string "…"
 helm-buffer-max-length 22
 helm-window-show-buffers-function 'helm-window-mosaic-fn
 helm-window-prefer-horizontal-split t)
#+END_SRC

** Apropos 

#+BEGIN_SRC emacs-lisp :tangle no
;; Command: helm-apropos
;; To enable fuzzy matching, add this setting:
(setq helm-apropos-fuzzy-match t)
;; (global-set-key [remap apropos-command] 'helm-apropos) ;; dgm comments out on sept 2019
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
;;; Add bindings to `helm-apropos`. TODO: Does not work most of the times.
;;; https://github.com/emacs-helm/helm/issues/1140
;;; Commented out by DGM on 4 sept 2019
(defun ambrevar/helm-def-source--emacs-commands (&optional default)
  (helm-build-in-buffer-source "Commands"
    :init `(lambda ()
             (helm-apropos-init 'commandp ,default))
    :fuzzy-match helm-apropos-fuzzy-match
    :filtered-candidate-transformer (and (null helm-apropos-fuzzy-match)
                                         'helm-apropos-default-sort-fn)
    :candidate-transformer 'helm-M-x-transformer-1
    :nomark t
    :action '(("Describe Function" . helm-describe-function)
              ("Find Function" . helm-find-function)
              ("Info lookup" . helm-info-lookup-symbol))))

(global-set-key (kbd "s-a") 'helm-apropos)
#+END_SRC

#+RESULTS:
: helm-apropos

** =top=

#+begin_src emacs-lisp :tangle no
(helm-top-poll-mode)
(global-set-key (kbd "s-t") 'helm-top)
#+end_src

#+RESULTS:
: helm-top


* Fuzzy matching for searches
To enable fuzzy matching, add the following settings:

On semantic, read https://tuhdo.github.io/helm-intro.html: Semantic is a package that provides language-aware editing commands based on 'source-code parsers'. When enabled, each file you visit is automatically parsed. Semantic provides execellent support for C/C++. To enable Semantic mode, execute =(semantic-mode 1)= (done in =starter-kit-completion.org=).

Helm offers an interface to both Semantic and Imenu at the same time: If `semantic-mode' is active in the current buffer, then use semantic for generating tags, otherwise fall back to imenu. If point is on a symbol, helm feeds the symbol into input prompt by default.

On =(setq helm-follow-input-idle-delay 0.5) ;; https://tech.toryanderson.com/posts/image-previews-with-helm-follow-mode/=: 
Image previews with helm-follow-mode: When using helm-find-file you can use helm-follow-mode to cause images to show themselves as you move over them, replacing the need to start up some other program to preview images. The shortcut for that while within helm-find-file is C-c C-f.
By default, you will be ejected from the follow mode as soon as you move over a non-image file. The following customizatoin will give it a little more tolerance:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq helm-recentf-fuzzy-match t)

  ;; Command: helm-find-files
  ;; helm-find-files is file navigation on steroids:
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (setq helm-follow-input-idle-delay 0.5) ;; https://tech.toryanderson.com/posts/image-previews-with-helm-follow-mode/
  ;;(global-set-key (kbd "<s-escape>") 'helm-recentf)

  ;; Command: helm-semantic-or-imenu
  ;; recall I have ==(semantic-mode 1)= in =starter-kit-completion.org=
  (setq helm-imenu-fuzzy-match    t)

  (global-set-key (kbd "M-i") 'helm-semantic-or-imenu)

  ;; Command: helm-locate
  (setq helm-locate-fuzzy-match t)

  ;; From ambrevar: Fallback on 'find' if 'locate' is not available.
  (unless (executable-find "locate")
    (setq helm-locate-recursive-dirs-command "find %s -type d -regex .*%s.*$"))

  ;; See https://github.com/emacs-helm/helm/issues/1962.
  ;; DGM comments it out on 4 sept 2019 as I don't use it
  ;; (defun ambrevar/helm-locate-meta (&optional update)
  ;;   "Like `helm-locate' but also use the databases found in /media and /run/media.
  ;; With prefix argument, UPDATE the databases with custom uptions thanks to the
  ;; 'updatedb-local' script."
  ;;   (interactive "P")
  ;;   (let ((user-db (expand-file-name "~/.cache/locate.db"))
  ;;         (media-dbs (apply 'append
  ;;                           (mapcar
  ;;                            (lambda (root) (ignore-errors (file-expand-wildcards (concat root "/*/locate.db"))))
  ;;                            (list (concat "/run/media/" (user-login-name))
  ;;                                  (concat "/media/" (user-login-name))
  ;;                                  "/media")))))
  ;;     (when update
  ;;       (with-temp-buffer
  ;;         (if (= (shell-command "updatedb-local" (current-buffer)) 0)
  ;;             (message "%s" (buffer-string))
  ;;           (error "%s" (current-buffer)))))
  ;;     (helm-locate-with-db
  ;;      (mapconcat 'identity
  ;;                 (cons user-db media-dbs)
  ;;                 ":")
  ;;      nil (thing-at-point 'filename))))

  ;; Command: helm-occur
  ;; search for patterns in current buffer
  ;; (global-set-key (kbd "C-c h o") 'helm-occur)
  (global-set-key (kbd "s-o") 'helm-occur)

  ;; helm-resume: taken to dgm.org or else it didn't replace <exwm-reset>
  ;; (global-set-key (kbd "s-r") 'helm-resume)

  ;; Command: helm-lisp-completion-at-point
  ;; To enable fuzzy matching, add this setting:
  (setq helm-lisp-fuzzy-completion t)

  ;; Command: helm-all-mark-rings
  ;; (global-set-key (kbd "<s-return>") 'helm-all-mark-rings)
  ;; <> compulsory for return but not for s
  (global-set-key (kbd "s-<return>") 'helm-all-mark-rings)

  ;; Command: helm-register
  (global-set-key (kbd "C-c h x") 'helm-register)
  (global-set-key (kbd "s-x") 'helm-register)
#+END_SRC

#+RESULTS:
: helm-register


* Key bindings 

The default "C-x c" is quite close to "C-x C-c", which quits Emacs. Changed to "C-c h". Note: We must set "C-c h" globally, because we cannot change `helm-command-prefix-key' once `helm-config' is loaded.

#+BEGIN_SRC emacs-lisp :tangle no
(global-set-key (kbd "C-c h") 'helm-command-prefix)
(global-unset-key (kbd "C-x c"))

    ;; Make M-x be equal to M-x helm-M-x
(global-set-key (kbd "M-x") 'helm-M-x)

(setq helm-M-x-fuzzy-match t) ;; optional fuzzy matching for helm-M-x

    ;; Command: helm-show-kill-ring
(global-set-key (kbd "M-y") 'helm-show-kill-ring)

    ;; Command: helm-mini
(global-set-key (kbd "C-x b") 'helm-mini)
#+END_SRC

#+RESULTS:
: helm-mini

* Limit candidates for speed

- Limit max number of matches displayed for speed. In Pragmatic Emacs's =helm-for-files= and in Sacha Chua's dotfiles.

#+BEGIN_SRC emacs-lisp :tangle no
(setq helm-candidate-number-limit 100)
#+END_SRC

#+RESULTS:
: 100

* Sacha Chua

#+BEGIN_SRC emacs-lisp :tangle no
    ;; From https://gist.github.com/antifuchs/9238468
    (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
          helm-input-idle-delay 0.01  ; this actually updates things
                                        ; reeeelatively quickly.
          helm-yas-display-key-on-candidate t
          helm-quick-update t
          helm-M-x-requires-pattern nil
          helm-ff-skip-boring-files t)
#+END_SRC

#+RESULTS:
: t

** Minibuffer

If you get into the minibuffer (=C-x b= for =helm-mini=), then you get its history with =C-c C-l=.

#+BEGIN_SRC emacs-lisp :tangle no
;; Command: helm-mini-buffer-history
(define-key minibuffer-local-map (kbd "C-c C-l") 'helm-minibuffer-history)
#+END_SRC

#+RESULTS:
: helm-minibuffer-history

Show minibuffer history with Helm

#+begin_src emacs-lisp :tangle no
(define-key minibuffer-local-map (kbd "M-p") 'helm-minibuffer-history)
(define-key minibuffer-local-map (kbd "M-n") 'helm-minibuffer-history)
#+end_src

** Mark ring

Save current position to mark ring:

#+begin_src emacs-lisp :tangle no
(add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)
#+end_src

** Tuhdo's bindings

#+begin_src emacs-lisp :tangle no
(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action but this gives rise to problems. See https://github.com/jkitchin/org-ref/issues/527
(define-key helm-map (kbd "C-i")   'helm-execute-persistent-action) ; make TAB work in terminal
(define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

(define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
(define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
(define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)
#+end_src

** Tuhdo's costumization

#+begin_src emacs-lisp :tangle no
(when (executable-find "curl")
  (setq helm-google-suggest-use-curl-p t))

(setq helm-google-suggest-use-curl-p t
      helm-scroll-amount 4 ; scroll 4 lines other window using M-<next>/M-<prior>
      ;; helm-quick-update t ; do not display invisible candidates
      helm-ff-search-library-in-sexp t ; search for library in `require' and `declare-function' sexp.

      ;; you can customize helm-do-grep to execute ack-grep
      ;; helm-grep-default-command "ack-grep -Hn --smart-case --no-group --no-color %e %p %f"
      ;; helm-grep-default-recurse-command "ack-grep -H --smart-case --no-group --no-color %e %p %f"
      helm-split-window-in-side-p t ;; open helm buffer inside current window, not occupy whole other window

      helm-echo-input-in-header-line t

      ;; helm-candidate-number-limit 500 ; limit the number of displayed canidates
      helm-ff-file-name-history-use-recentf t
      helm-move-to-line-cycle-in-source t ; move to end or beginning of source when reaching top or bottom of source.
      helm-buffer-skip-remote-checking t

      helm-mode-fuzzy-match t

      helm-buffers-fuzzy-matching t ; fuzzy matching buffer names when non-nil
                                        ; useful in helm-mini that lists buffers
      helm-org-headings-fontify t
      ;; helm-find-files-sort-directories t
      ;; ido-use-virtual-buffers t
      helm-semantic-fuzzy-match t
      ;; helm-M-x-fuzzy-match t
      ;; helm-imenu-fuzzy-match t
      ;; helm-lisp-fuzzy-completion t
      ;; helm-apropos-fuzzy-match t
      ;; helm-locate-fuzzy-match t
      helm-display-header-line nil)
#+end_src

(use-package helm
  :diminish helm-mode
  :bind-keymap
  (("C-c h" . helm-command-map)  
  ("C-c h"  . helm-command-prefix))  
  :bind  (("M-x"        . helm-M-x)
         ("M-y"        . helm-show-kill-ring)
         ("C-x b"      . helm-mini)
         ("M-i"        . helm-semantic-or-imenu)
         ("s-o"        . helm-occur)
         ("C-x C-f"    . helm-find-files)
         ("s-<return>" . helm-all-mark-rings)
         ("s-x"        . helm-register)
         ("s-t"        . helm-top)
         ("s-\("        . helm-eval-expression-with-eldoc)
         ([remap find-tag]  . helm-etags-select)
         ("s-\)"       . ap/helm-info-emacs-elisp-cl)
         :map helm-command-map
         ("<tab>" . helm-execute-persistent-action)
         ("C-i" . helm-execute-persistent-action)
         ("C-z" . helm-select-action)
         ("C-g" . helm-keyboard-quit)
         ("C-c h g"    . helm-google-suggest)
         ("C-c h w"    . helm-wikipedia-suggest)
         :map helm-grep-mode-map
         ("<return>" . helm-grep-mode-jump-other-window)         
         ("n" . helm-grep-mode-jump-other-window-forward)
         ("p" . helm-grep-mode-jump-other-window-backward)
         :map shell-mode-map
         ("C-c C-l" . helm-comint-input-ring) ; in shell mode
         :map minibuffer-local-map
         ("C-c C-l" . helm-minibuffer-history)
         ("M-p" . helm-minibuffer-history)
         ("M-n" . helm-minibuffer-history))
  :init 
  (global-unset-key (kbd "C-x c"))
  (setq helm-command-prefix-key "C-c h")
  (global-set-key (kbd "C-c h") 'helm-command-prefix)  
  (require 'helm-config)
  (require 'helm-grep)
  (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)
  (add-hook 'helm-after-initialize-hook
              (lambda()
                (define-key helm-buffer-map (kbd "C-g") 'helm-keyboard-quit)
                (define-key helm-map (kbd "C-g") 'helm-keyboard-quit)))
  :config 
    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    (setq helm-google-suggest-use-curl-p t
          helm-scroll-amount 4 ; scroll 4 lines other window using M-<next>/M-<prior>
          ;; helm-quick-update t ; do not display invisible candidates
          helm-ff-search-library-in-sexp t ; search for library in `require' and `declare-function' sexp.

          ;; you can customize helm-do-grep to execute ack-grep
          ;; helm-grep-default-command "ack-grep -Hn --smart-case --no-group --no-color %e %p %f"
          ;; helm-grep-default-recurse-command "ack-grep -H --smart-case --no-group --no-color %e %p %f"
          helm-split-window-in-side-p t ;; open helm buffer inside current window, not occupy whole other window

          helm-echo-input-in-header-line t

          ;; helm-candidate-number-limit 500 ; limit the number of displayed canidates
          helm-ff-file-name-history-use-recentf t
          helm-move-to-line-cycle-in-source t ; move to end or beginning of source when reaching top or bottom of source.
          helm-buffer-skip-remote-checking t

          helm-mode-fuzzy-match t

          helm-buffers-fuzzy-matching t ; fuzzy matching buffer names when non-nil
                                            ; useful in helm-mini that lists buffers
          helm-org-headings-fontify t
          ;; helm-find-files-sort-directories t
          ;; ido-use-virtual-buffers t
          helm-semantic-fuzzy-match t
          ;; helm-M-x-fuzzy-match t
          ;; helm-imenu-fuzzy-match t
          ;; helm-lisp-fuzzy-completion t
          ;; helm-apropos-fuzzy-match t
          ;; helm-locate-fuzzy-match t
          helm-display-header-line nil)

        (setq helm-candidate-number-limit 100)

            (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
                  helm-input-idle-delay 0.01  ; this actually updates things
                                                ; reeeelatively quickly.
                  helm-yas-display-key-on-candidate t
                  helm-quick-update t
                  helm-M-x-requires-pattern nil
                  helm-ff-skip-boring-files t)

        (setq helm-M-x-fuzzy-match t) ;; optional fuzzy matching for helm-M-x

        (setq helm-recentf-fuzzy-match t)

        ;; Command: helm-find-files
        ;; helm-find-files is file navigation on steroids:
        (setq helm-follow-input-idle-delay 0.5) ;; https://tech.toryanderson.com/posts/image-previews-with-helm-follow-mode/
        ;;(global-set-key (kbd "<s-escape>") 'helm-recentf)

        ;; Command: helm-semantic-or-imenu
        ;; recall I have ==(semantic-mode 1)= in =starter-kit-completion.org=
        (setq helm-imenu-fuzzy-match  t)

        ;; Command: helm-locate
        (setq helm-locate-fuzzy-match t)

        ;; From ambrevar: Fallback on 'find' if 'locate' is not available.
        (unless (executable-find "locate")
          (setq helm-locate-recursive-dirs-command "find %s -type d -regex .*%s.*$"))

        (setq helm-lisp-fuzzy-completion t)

        (setq
         helm-follow-mode-persistent t
         helm-reuse-last-window-split-state t
         helm-findutils-search-full-path t
         helm-show-completion-display-function nil
         helm-completion-mode-string ""
         helm-dwim-target 'completion
         helm-use-frame-when-more-than-two-windows nil
         helm-man-or-woman-function nil
         helm-buffers-end-truncated-string "…"
         helm-buffer-max-length 22
         helm-window-show-buffers-function 'helm-window-mosaic-fn
         helm-window-prefer-horizontal-split t)

        (setq helm-apropos-fuzzy-match t)

        (helm-top-poll-mode)

        (defun ap/helm-info-emacs-elisp-cl ()
          "Helm for Emacs, Elisp, and CL-library info pages."
          (interactive)
          (helm :sources '(helm-source-info-emacs
                           helm-source-info-elisp
                           helm-source-info-cl)))
  (helm-mode 1))


    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action but this gives rise to problems. See https://github.com/jkitchin/org-ref/issues/527
    (define-key helm-map (kbd "C-i")   'helm-execute-persistent-action) ; make TAB work in terminal
    (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
    (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
    (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
    (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)
        (define-key minibuffer-local-map (kbd "C-c C-l") 'helm-minibuffer-history)
        (define-key minibuffer-local-map (kbd "M-p") 'helm-minibuffer-history)
        (define-key minibuffer-local-map (kbd "M-n") 'helm-minibuffer-history)
          ;; Make M-x be equal to M-x helm-M-x
        (global-set-key (kbd "M-x") 'helm-M-x)
            ;; Command: helm-show-kill-ring
        (global-set-key (kbd "M-y") 'helm-show-kill-ring)
            ;; Command: helm-mini
        (global-set-key (kbd "C-x b") 'helm-mini)
        (global-set-key (kbd "M-i") 'helm-semantic-or-imenu)
        (global-set-key (kbd "s-o") 'helm-occur)
        (global-set-key (kbd "C-x C-f") 'helm-find-files)
        (global-set-key (kbd "s-<return>") 'helm-all-mark-rings)
        (global-set-key (kbd "C-c h x") 'helm-register)
        (global-set-key (kbd "s-x") 'helm-register)
        (global-set-key (kbd "s-t") 'helm-top)
        (global-set-key (kbd "C-c h g") 'helm-google-suggest)
        (global-set-key (kbd "C-c h w") 'helm-wikipedia-suggest)
        (global-set-key (kbd "s-(") 'helm-eval-expression-with-eldoc)
        (define-key global-map [remap find-tag] 'helm-etags-select)
                (define-key helm-buffer-map (kbd "C-g") 'helm-keyboard-quit)
                (define-key helm-map (kbd "C-g") 'helm-keyboard-quit)))
        (global-set-key (kbd "s-\)") 'ap/helm-info-emacs-elisp-cl)

  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
;; from: https://github.com/bbatsov/projectile#usage
    ;; (projectile-global-mode t)
    (projectile-mode +1) ;; You now need to explicitly enable projectile and set a prefix. See      https://stackoverflow.com/questions/31421106/why-emacs-project-c-c-p-is-undefined, I guess it's already done with (projectile-global-mode t) in the use-package settings... but just in case.
    ;;(define-key projectile-mode-map (kbd "s--") 'projectile-command-map)

* COMMENT Helm-color
I don't use it that much...
#+begin_src emacs-lisp :tangle no
;;(global-set-key (kbd "s-c") 'helm-colors) 
#+end_src

#+RESULTS:
: helm-colors

* Worf and hydra

=worf= needs =hydra=

#+BEGIN_SRC emacs-lisp :tangle no
(use-package hydra)
(use-package worf)
#+END_SRC

** COMMENT Worf costumization to work as a search engine across org headers

#+BEGIN_SRC emacs-lisp :tangle no
;; ——— WORF Utilities ———————————————————————————————————————————————————————————————
;; https://github.com/abo-abo/worf/blob/master/worf.el
(defun worf--pretty-heading (str lvl)
  "Prettify heading STR or level LVL."
  (setq str (or str ""))
  (setq str (propertize str 'face (nth (1- lvl) org-level-faces)))
  (let (desc)
    (while (and (string-match org-bracket-link-regexp str)
                (stringp (setq desc (match-string 3 str))))
      (setq str (replace-match
                 (propertize desc 'face 'org-link)
                 nil nil str)))
    str))
(defun worf--pattern-transformer (x)
  "Transform X to make 1-9 select the heading level in `worf-goto'."
  (if (string-match "^[1-9]" x)
      (setq x (format "^%s" x))
    x))

(defun worf-goto ()
  "Jump to a heading with `helm'."
  (interactive)
  (require 'helm-match-plugin) ;; commented out by DGM as I think it is not needed. See https://stackoverflow.com/questions/19098272/initialization-error-caused-by-helm-match-plugin
  (let ((candidates
         (org-map-entries
          (lambda ()
            (let ((comp (org-heading-components))
                  (h (org-get-heading)))
              (cons (format "%d%s%s" (car comp)
                            (make-string (1+ (* 2 (1- (car comp)))) ?\ )
                            (if (get-text-property 0 'fontified h)
                                h
                              (worf--pretty-heading (nth 4 comp) (car comp))))
                    (point))))))
        helm-update-blacklist-regexps
        helm-candidate-number-limit)
    (helm :sources
          `((name . "Headings")
            (candidates . ,candidates)
            (action . (lambda (x) (goto-char x)
                        (call-interactively 'show-branches)
                        (worf-more)))
            (pattern-transformer . worf--pattern-transformer)))))

(global-set-key (kbd "C-=") 'worf-goto)
#+END_SRC

#+RESULTS:
: worf-goto

*** Tuhdo's set up

#+begin_src emacs-lisp :tangle no
(use-package projectile
   :init
  (projectile-global-mode)
  (setq projectile-enable-caching t))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (24034 9694 517929 992000) :init (24034 9694 517918 228000) :config (24034 9694 517634 638000) :config-secs (0 0 9 408000) :init-secs (0 5 707366 238000) :use-package-secs (0 5 707478 796000)))


* Comint 

Disabled as it gives rise to lisp error

#+BEGIN_SRC emacs-lisp :tangle no
;; Command: helm-comint-input-ring
;; (define-key shell-mode-map (kbd "C-c h C-c h") 'helm-comint-input-ring)
#+END_SRC

#+RESULTS:

** COMMENT Convenience

Commented out by DGM on 4 sept 2019
#+BEGIN_SRC emacs-lisp :tangle no
;;; Convenience.
(defun ambrevar/helm-toggle-visible-mark-backwards (arg)
  (interactive "p")
  (helm-toggle-visible-mark (- arg)))
;; (define-key helm-map (kbd "S-SPC") 'ambrevar/helm-toggle-visible-mark-backwards)

;; (global-set-key  (kbd "C-<f4>") 'helm-execute-kmacro)
#+END_SRC

** COMMENT More stuff!!!

Commented out by DGM on 4 sept 2019

#+BEGIN_SRC emacs-lisp :tangle no
(setq helm-source-names-using-follow '("Occur" "Git-Grep" "AG" "mark-ring" "Org Headings" "Imenu"))

;;; From https://www.reddit.com/r/emacs/comments/5q922h/removing_dot_files_in_helmfindfiles_menu/.
(defun ambrevar/helm-skip-dots (old-func &rest args)
  "Skip . and .. initially in helm-find-files.  First call OLD-FUNC with ARGS."
  (apply old-func args)
  (let ((sel (helm-get-selection)))
    (if (and (stringp sel) (string-match "/\\.$" sel))
        (helm-next-line 2)))
  (let ((sel (helm-get-selection))) ; if we reached .. move back
    (if (and (stringp sel) (string-match "/\\.\\.$" sel))
        (helm-previous-line 1))))

(advice-add #'helm-preselect :around #'ambrevar/helm-skip-dots)
(advice-add #'helm-ff-move-to-first-real-candidate :around #'ambrevar/helm-skip-dots)

(with-eval-after-load 'desktop
  (add-to-list 'desktop-globals-to-save 'kmacro-ring)
  (add-to-list 'desktop-globals-to-save 'last-kbd-macro)
  (add-to-list 'desktop-globals-to-save 'kmacro-counter)
  (add-to-list 'desktop-globals-to-save 'kmacro-counter-format)
  (add-to-list 'desktop-globals-to-save 'helm-ff-history)
  (add-to-list 'desktop-globals-to-save 'comint-input-ring))
;;; Column indices might need some customizing. See `helm-top-command' and
;;; https://github.com/emacs-helm/helm/issues/1586 and
;;; https://github.com/emacs-helm/helm/issues/1909.
#+END_SRC


 ** COMMENT The =M-s= prefix
Use the =M-s= prefix just like `occur'. 
Note that the =s= in the prefix is the letter =s= and not the =super= key.
Note that I think =M-i= does the same.

DGM, 16 july: I disable this as the prefix =M-s= is not working. Don't know why. 


#+BEGIN_SRC emacs-lisp :tangle no
(define-key prog-mode-map (kbd "M-s f") 'helm-semantic-or-imenu)
;;; The text-mode-map binding targets structured text modes like Markdown.
(define-key text-mode-map (kbd "M-s f") 'helm-semantic-or-imenu)
(with-eval-after-load 'org
  (require 'helm-org-contacts nil t)
  (define-key org-mode-map (kbd "M-s f") 'helm-org-in-buffer-headings))
(with-eval-after-load 'woman
  (define-key woman-mode-map (kbd "M-s f") 'helm-imenu))
(with-eval-after-load 'man
  (define-key Man-mode-map (kbd "M-s f") 'helm-imenu))
#+END_SRC

#+RESULTS:


*** =helm-regexp=

Commenting out by DGM on sept 2019

#+BEGIN_SRC emacs-lisp :tangle no
;;(global-set-key [remap query-replace-regexp] 'helm-regexp)
(global-set-key (kbd "s-\"") 'helm-regexp)
;;(unless (boundp 'completion-in-region-function)
;;  (define-key lisp-interaction-mode-map [remap completion-at-point] 'helm-lisp-completion-at-point)
;;  (define-key emacs-lisp-mode-map       [remap completion-at-point] 'helm-lisp-completion-at-point))
#+END_SRC

#+RESULTS:
: helm-regexp

And still more on grep, but they are already defined in the =exwm= shortcuts, so I take them out

#+BEGIN_SRC emacs-lisp :tangle no
(ambrevar/global-set-keys
 "C-x M-g" 'ambrevar/helm-grep-git-or-ag
 "C-x M-G" 'helm-do-grep-ag)
#+END_SRC

** COMMENT From Ambrevar: 
DGM: I'm commenting out Ambrevar's stuff on 4 sept 2019.

Do not exclude any files from 'git grep'.

#+BEGIN_SRC emacs-lisp :tangle no
(setq helm-grep-git-grep-command "git --no-pager grep -n%cH --color=always --full-name -e %p -- %f")

(defun ambrevar/helm-grep-git-or-ag (arg)
  "Run `helm-grep-do-git-grep' if possible; fallback to `helm-do-grep-ag' otherwise.
Requires `call-process-to-string' from `functions'."
  (interactive "P")
  (require 'vc)
  (require 'functions)
  (if (and (vc-find-root default-directory ".git")
           (or arg (split-string (ambrevar/call-process-to-string "git" "ls-files" "-z") "\0" t)))
      (helm-grep-do-git-grep arg)
    (helm-do-grep-ag nil)))

(defun ambrevar/helm-grep-git-all-or-ag ()
  "Run `helm-grep-do-git-grep' over all git files."
  (interactive)
  (helm-grep-do-git-grep t))
#+END_SRC

#+RESULTS:
: ambrevar/helm-grep-git-all-or-ag


** Tuhdo's bindings

#+begin_src emacs-lisp :tangle yes
;;    (global-set-key (kbd "C-x b") 'helm-buffers-list)
;;    (global-set-key (kbd "C-c r") 'helm-recentf)
;;    (global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
;;    (define-key 'help-command (kbd "C-l") 'helm-locate-library)
#+end_src

** COMMENT Tuhdo function for hiding minibuffer

DGM comments it out in case it is responsible of minimizing the minibuffer so I don't see the systemtray!

#+begin_src emacs-lisp :tangle no
    (defun helm-hide-minibuffer-maybe ()
      (when (with-helm-buffer helm-echo-input-in-header-line)
        (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
          (overlay-put ov 'window (selected-window))
          (overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
                                  `(:background ,bg-color :foreground ,bg-color)))
          (setq-local cursor-type nil))))

    (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)
#+end_src

